<!DOCTYPE html>
<html lang="en">
<head>
  <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,400italic' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" type="text/css" href="//jguegant.github.io/blogs/tech/theme/css/style.min.css">
  <link rel="stylesheet" type="text/css" href="//jguegant.github.io/blogs/tech/theme/css/monokai.css">
  <link rel="stylesheet" type="text/css" href="//jguegant.github.io/blogs/tech/theme/css/font-awesome.min.css">
  <link href="//jguegant.github.io/blogs/tech/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Jean Guegant's Blog Atom">

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="index, follow" />
  <meta name="author" content="Jean Guegant" />
  <meta name="description" content="" />
<meta property="og:site_name" content="Jean Guegant's Blog"/>
<meta property="og:type" content="blog"/>
<meta property="og:title" content="Jean Guegant's Blog"/>
<meta property="og:description" content=""/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="//jguegant.github.io/blogs/tech"/>
<meta property="og:image" content="//jguegant.github.io/blogs/tech/images/myself.png">
  <title>Jean Guegant's Blog</title>
</head>
<body>
  <aside>
    <div>
      <a href="//jguegant.github.io/blogs/tech">
        <img src="//jguegant.github.io/blogs/tech/images/myself.png" alt="Jean Guegant" title="Jean Guegant">
      </a>
      <h1><a href="//jguegant.github.io/blogs/tech">Jean Guegant</a></h1>
      <p>Software Engineer - C++, security, game development and random thoughts.</p>
      <nav>
        <ul class="list">
          <li><a href="//jguegant.github.io/blogs/tech/pages/about.html#about">About</a></li>
          <li><a href="//jguegant.github.io/blogs/tech/pages/contact.html#contact">Contact</a></li>
        </ul>
      </nav>
      <ul class="social">
        <li><a class="sc-linkedin" href="https://se.linkedin.com/in/jguegant" target="_blank"><i class="fa fa-linkedin"></i></a></li>
        <li><a class="sc-github" href="https://github.com/Jiwan" target="_blank"><i class="fa fa-github"></i></a></li>
      </ul>
    </div>
  </aside>
  <main>
    <nav>
      <a href="//jguegant.github.io/blogs/tech">Home</a>
      <a href="//jguegant.github.io/blogs/tech/archives.html">Archives</a>
      <a href="//jguegant.github.io/blogs/tech/categories.html">Categories</a>
      <a href="//jguegant.github.io/blogs/tech/tags.html">Tags</a>
      <a href="//jguegant.github.io/blogs/tech/feeds/all.atom.xml">Atom</a>
    </nav>

<article>
  <header>
    <h2><a href="//jguegant.github.io/blogs/tech/thread-safe-multi-type-map.html#thread-safe-multi-type-map">An introduction to C++'s variadic templates: a thread-safe multi-type map</a></h2>
    <p>
      Posted on Mon 01 February 2016 in <a href="//jguegant.github.io/blogs/tech/category/c.html">C++</a>
      &#8226; Tagged with
      <a href="//jguegant.github.io/blogs/tech/tag/c11.html">C++11</a>,      <a href="//jguegant.github.io/blogs/tech/tag/c14.html">C++14</a>,      <a href="//jguegant.github.io/blogs/tech/tag/variadic-templates.html">variadic templates</a>,      <a href="//jguegant.github.io/blogs/tech/tag/meta-programming.html">meta programming</a>      &#8226; <a href="//jguegant.github.io/blogs/tech/thread-safe-multi-type-map.html#disqus_thread">Leave a comment</a>
    </p>
  </header>
  <div>
      <h3>Trivia:</h3>
<p>One of our favorite motto in our C++ team at work is: you shall use <strong>dependency injections</strong> instead of <strong>singletons</strong>! It actually comes with our unit-testing strategy. If the various components of your architecture are too tightly coupled, it becomes a tremendous effort to deeply test small critical chunks of your code. <strong>Singletons</strong> are that kind of beast that revives itself without your permission and comes from hell to haunt your lovely unit-tests. Our main project being multi-threaded (hence highly bug-prone) and vital for the company, "<strong>singleton</strong>" became a forbidden word. Yet, our team recently started going down the dark path. Thanks to C++11 and its variadic templates, I carefully crafted a <strong>thread-safe multi-type map container</strong> that simplified our configuration reloading system and saved us from the dark side of the coder force. If you always wondered what are <strong>variadic templates</strong>, how <strong>C++11's tuples</strong> can be implemented, I am going to present these concepts in this post using my container as a cobaye.</p>
<p>Note: for the sake of your sanity and the fact that <em>errare humanum est</em>, this article might not be 100% accurate!</p>
<h3>Why would I use a thread-safe multi-type map?</h3>
<p>Let me explain our odyssey: we are working on a highly modular and multi-threaded application. One of its core feature is the ability to reload various configuration files or assets used by some components spread accross many threads and a giant hierarchy of objects. The reloading process is automic using Linux's <a href="http://man7.org/linux/man-pages/man7/inotify.7.html">inotify</a> monitoring filesystem events. One thread is dedicated to the reception of filesystem events and must react accordingly by parsing any changes and pushing them to other threads. At first, we used, to pass-by any newly parsed asset, some thread-safe <strong>queues</strong> or something analog to <a href="https://tour.golang.org/concurrency/2">go channels</a>. Since we did not want to use <strong>singletons</strong>, we had to pass references to our queues all along our object hierarchy. Sadly, our <strong>queue</strong> implementation is <strong>one to one</strong> and supports only <strong>one type</strong>, none of our config/asset types share the same <strong>base-type</strong>. For each asset type and each component using this asset, we had to create a new <strong>queue</strong> and pass-it all along our hierarchy. That is certainely not convenient! What we really wanted was a hybrid class between a <a href="http://en.cppreference.com/w/cpp/container/map">std::map</a> and a <a href="http://en.cppreference.com/w/cpp/utility/tuple">std::tuple</a>.</p>
<p>We could have used a <strong>std::map</strong> with <a href="http://www.boost.org/doc/libs/1_60_0/doc/html/variant.html">Boost.Variant</a> to store our items, using a type like the following <strong>"std::map&lt; std::string, std::shared_ptr&lt; Boost.Variant &lt; ConfigType1, ConfigType2&gt;&gt;&gt;"</strong>. <strong>Boost.Variant</strong> permits to encapsulate a <strong>heterogeneous set of types</strong> without <strong>common base-type or base-class</strong>, which solves one of our point. Another solution would be to encapsulate manually all our configuration classes in the same familly of classes, that is pretty cumbersome. But anyway, <strong>std::map</strong> does not guaranty any safety if you are writing and reading at the same time on a map slot. Secondly, <strong>std::shared_ptr</strong> does guaranty a thread-safe destruction of the pointee object (i.e: the reference counter is thread-safe) but nothing for the <strong>std::shared_ptr</strong> object itself. It means that copying a <strong>std::shared_ptr</strong> that could potentially be modified from another thread, might lead to an undefined behaviour. Even if we were to encapsulate all these unsafe accesses with mutexes, we are still lacking a nice mechanism to get update notifications for our objects. We do not want to constantly poll the latest version and propagate it through our code. And finally, if that solution were elegant enough, why would I currently write this blog post?</p>
<p><strong>C++11</strong> brings another collection type called <strong>std::tuple</strong>. It permits to store a set of elements of <strong>heterogeneous types</strong>. Take a look at this short example:</p>
<div class="highlight"><pre><span class="k">auto</span> <span class="n">myTuple</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="s">&quot;Foo&quot;</span><span class="p">,</span> <span class="mi">1337</span><span class="p">,</span> <span class="mi">42</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">myTuple</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// Access element by index: &quot;Foo&quot;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">myTuple</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// Access element by index: 1337</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">myTuple</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// Access element by index: 42</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">myTuple</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// Access element by type: &quot;Foo&quot;</span>

<span class="c1">// compilation error: static_assert failed &quot;tuple_element index out of range&quot;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">(</span><span class="n">myTuple</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="c1">// compilation error: static_assert failed &quot;type can only occur once in type list&quot;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">myTuple</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>


<p><strong>Tuples</strong> are that kind of <strong>C++11</strong> jewelry that should decide your old-fashioned boss to upgrade your team's compiler (and his ugly tie). Not only I could store a <strong>const char* </strong> and two <strong>ints</strong> without any compiling error, but I could also access them using compile-time mechanisms. In some way, you can see tuples as a compile-time map using indexes or types as keys to reach its elements. You cannot use an index out of bands, it will be catched at compile-time anyway! Sadly, using a type as a key to retrieve an element is only possible if the type is unique in the <strong>tuple</strong>. At my work, we do have few config objects sharing the same class. Anyway, tuples weren't fitting our needs regarding thread safety and update events. Let's see what we could create using tasty <strong>tuples</strong> as an inspiration.</p>
<p>Note that some <strong>tuples</strong> implementations were already available before <strong>C++11</strong>, notably in <a href="http://www.boost.org/doc/libs/1_60_0/libs/tuple/doc/tuple_users_guide.html">boost</a>. <strong>C++11</strong> variadic templates are just very handy, as you will see, to construct such a class.</p>
<h3>A teaser for my repository class:</h3>
<p>To keep your attention for the rest of this post, here is my <strong>thread-safe multi-type map</strong> in action:</p>
<div class="highlight"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;memory&gt;</span>
<span class="cp">#include &lt;string&gt;</span>

<span class="cp">#include &quot;repository.hpp&quot;</span>

<span class="c1">// Incomplete types used as compile-time keys.</span>
<span class="k">struct</span> <span class="n">Key1</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">Key2</span><span class="p">;</span>

<span class="c1">// Create a type for our repository.</span>
<span class="k">using</span> <span class="n">MyRepository</span> <span class="o">=</span> <span class="n">Repository</span>
    <span class="o">&lt;</span>
        <span class="n">Slot</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">,</span> <span class="c1">// One slot for std::string.</span>
        <span class="n">Slot</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Key1</span><span class="o">&gt;</span><span class="p">,</span> <span class="c1">// Two slots for int.</span>
        <span class="n">Slot</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Key2</span><span class="o">&gt;</span> <span class="c1">// Must be differentiate using &quot;type keys&quot; (Key1, Key2).</span>
    <span class="o">&gt;</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">MyRepository</span> <span class="n">myRepository</span><span class="p">;</span>

    <span class="n">myRepository</span><span class="p">.</span><span class="n">emplace</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;test&quot;</span><span class="p">);</span> <span class="c1">// Construct the shared_ptr within the repository.</span>
    <span class="n">myRepository</span><span class="p">.</span><span class="n">emplace</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Key1</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1337</span><span class="p">);</span>
    <span class="n">myRepository</span><span class="p">.</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Key2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span> <span class="c1">// Set the shared_ptr manually.</span>

    <span class="c1">// Note: I use &#39;*&#39; as get returns a shared_ptr.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">myRepository</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// Print &quot;test&quot;.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">myRepository</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Key1</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// Print 1337.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">myRepository</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Key2</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// Print 42.</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">myRepository</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="c1">//             ^^^ Compilation error: which int shall be selected? Key1 or Key2?</span>

    <span class="k">auto</span> <span class="n">watcher</span> <span class="o">=</span> <span class="n">myRepository</span><span class="p">.</span><span class="n">getWatcher</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">();</span> <span class="c1">// Create a watcher object to observe changes on std::string.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">watcher</span><span class="o">-&gt;</span><span class="n">hasBeenChanged</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// 0: no changes since the watcher creation.</span>

    <span class="n">myRepository</span><span class="p">.</span><span class="n">emplace</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;yo&quot;</span><span class="p">);</span> <span class="c1">// Emplace a new value into the std::string slot.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">watcher</span><span class="o">-&gt;</span><span class="n">hasBeenChanged</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// 1: the std::string slot has been changed.</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">watcher</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// Poll the value and print &quot;yo&quot;.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">watcher</span><span class="o">-&gt;</span><span class="n">hasBeenChanged</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// 0: no changes since the last polling.</span>

    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>First and foremost, its name <strong>repository</strong> might not be well-suited for its responsibility. If your native language is the same as shakespeare and come-up with a better term, please feel free to submit it. In our internal usage, <strong>config repository</strong> sounded great!</p>
<p>I start by describing the slots necessary for my application by creating a new type <strong>MyRepository</strong> using a <a href="http://en.cppreference.com/w/cpp/language/type_alias">type alias</a>. As you can see, I use the type of the slots as a key for accessing elements. But in case of contention, I must use a second key: an "empty type" ; like <strong>Key1</strong> and <strong>Key2</strong> in this example.
If using types as keys seems odd for you, fear not! Here is the most rational explanation I can share with you: we are trying to benefit from our "know-it-all compiler". Your compiler is mainly manipulating types, one can change its flow using these types during the compilation process. Note that these structs are not even complete (no definition), it has <strong>no impact</strong> for the <strong>runtime memory</strong> or <strong>runtime execution</strong> and that's the amazing part of <strong>meta-programming</strong>. The dispatch of an expression such as <strong>"myRepository.get&lt; int, Key1&gt;()"</strong> is done during your build-time.</p>
<p>You may also notice that every slot is actually a <a href="http://en.cppreference.com/w/cpp/memory/shared_ptr">std::shared_ptr</a>. It enforces a clean ressource management: in a multithreaded application, one must be really careful of the lifetime of heap objects. <strong>std::shared_ptr</strong> in this case permits me to ensure that even if someone replaces a value in a slot, other components on other threads manipulating the old value won't end up with a <strong>dangling pointer/reference</strong> bomb in their hands. Another solution would be to use plain value objects, but not only it would require copying big objects in every other components but it would also remove polymorphism.</p>
<p>As for the updates signalisation, you first create a watcher object that establishes a contract between a desired slot to watch and your context. You can thereafter query in thread-safe way weither an update has been made and, if so, poll the latest changes. The watcher object is actually a <a href="http://en.cppreference.com/w/cpp/memory/unique_ptr">std::unique_ptr</a> for a special class, it cannot be moved nor copied without your permission and will automagically disable the signalisation contract between the slot and your context, once destroyed. We will dive deeper in this topic in the comming sections.</p>
<p>Within our application, the repository object is encapsulated into a RuntimeContext object. This RuntimeContext object is created explicitely within our main entry point and passed as a reference to a great part of our components. We therefore keep the possibility to test our code easily by setting this RuntimeContext with different implementations. Here is a simplified version of our usage:</p>
<div class="highlight"><pre><span class="c1">// runtimecontext.hpp</span>
<span class="cp">#include &quot;repository.hpp&quot;</span>

<span class="c1">// Incomplete types used as compile-time keys.</span>
<span class="k">struct</span> <span class="n">Key1</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">Key2</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">ConfigType1</span><span class="p">;</span> <span class="c1">// Defined in another file.</span>
<span class="k">class</span> <span class="nc">ConfigType2</span><span class="p">;</span> <span class="c1">// Defined in another file.</span>

<span class="c1">// Create a type for our repository.</span>
<span class="k">using</span> <span class="n">ConfigRepository</span> <span class="o">=</span> <span class="n">Repository</span>
    <span class="o">&lt;</span>
        <span class="n">Slot</span><span class="o">&lt;</span><span class="n">ConfigType1</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">Slot</span><span class="o">&lt;</span><span class="n">ConfigType2</span><span class="p">,</span> <span class="n">Key1</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">Slot</span><span class="o">&lt;</span><span class="n">ConfigType2</span><span class="p">,</span> <span class="n">Key2</span><span class="o">&gt;</span>
    <span class="o">&gt;</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">RuntimeContext</span>
<span class="p">{</span>
    <span class="n">ILogger</span><span class="o">*</span> <span class="n">logger</span><span class="p">;</span>
    <span class="c1">// ...</span>
    <span class="n">ConfigRepository</span> <span class="n">configRepository</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Main.cpp</span>

<span class="cp">#include &quot;runtimecontext.hpp&quot;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">RuntimeContext</span> <span class="n">runtimeContext</span><span class="p">;</span>
    <span class="c1">// Setup:</span>
    <span class="n">runtimeContext</span><span class="p">.</span><span class="n">logger</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StdOutLogger</span><span class="p">();</span>
    <span class="c1">// ...</span>

    <span class="c1">// Let&#39;s take a reference to the context and change the configuration repository when necessary. </span>
    <span class="n">startConfigurationMonitorThread</span><span class="p">(</span><span class="n">runtimeContext</span><span class="p">);</span>

    <span class="c1">// Let&#39;s take a reference and pass it down to all our components in various threads.</span>
    <span class="n">startOurApplicationLogic</span><span class="p">(</span><span class="n">runtimeContext</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h3>Time for a C++11 implementation:</h3>
<p>We can decompose the solution in 3 steps: at first we need to implement a map that accepts <strong>multiple types</strong>, we then need to work on the <strong>thread safety</strong> and finish by the <strong>watcher mechanism</strong>. Let's first fulfill the mission of this post: introducing you to <strong>variadic templates</strong> to solve the multiple-type problem.</p>
<h4>Variadic templates:</h4>
<p>You may not have heard of <strong>variadic templates</strong> in <strong>C++11</strong> but I bet that you already used <strong>variadic functions</strong> like <strong>printf</strong> in <strong>C</strong> (maybe in a previous unsafe life). As <a href="https://en.wikipedia.org/wiki/Variadic_function">wikipedia</a> kindly explains "a variadic function is a function of indefinite which accepts a variable number of arguments". In other words, a <strong>variadic function</strong> has potentially an infinite number of <strong>parameters</strong>. Likewise, a <strong>variadic template</strong> has potentially an infinite number of <strong>parameters</strong>. Let's see how to use them!</p>
<h5>Usage for variadic function templates:</h5>
<p>Let's say that you wish to create a template that accept an infinite number of class as arguments. You will use the following notation:</p>
<div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="n">class</span><span class="p">...</span> <span class="n">T</span><span class="o">&gt;</span>
</pre></div>


<p>You specify a group of template parameters using the ellipsis notation named <strong>T</strong>. Note that this <strong>ellipsis</strong> notation is consistent with <strong>C</strong>'s variadic function notation. This group of parameters, called a <strong>parameter-pack</strong>, can then be used in your function template or your class template by <strong>expanding</strong> them. One must use the <strong>ellipsis</strong> notation again (this time after T) to <strong>expand</strong> the parameter pack <strong>T</strong>:</p>
<div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="n">class</span><span class="p">...</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="p">...)</span>
<span class="c1">//              ^ pack T       ^expansion</span>
<span class="p">{</span>
    <span class="c1">// Your function content.</span>
<span class="p">}</span>
</pre></div>


<p>Now that we have expanded <strong>T</strong>, what can we do Sir? Well, first you give to your expanded parameter <strong>types</strong>, a fancy <strong>name</strong> like <strong>t</strong>.</p>
<div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="n">class</span><span class="p">...</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="p">...</span> <span class="n">t</span><span class="p">)</span>
<span class="c1">//                                ^ your fancy t.</span>
<span class="p">{</span>
    <span class="c1">// Your function content.</span>
<span class="p">}</span>
</pre></div>


<p>If <strong>T = T1, T2</strong>, then <strong>T... t = T1 t1, T2 t2</strong> and <strong>t = t1, t2</strong>. Brilliant, but is that all? Sure no! You can then <strong>expand</strong> again <strong>t</strong> using an "suffix-ellipsis" again:</p>
<div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="n">class</span><span class="p">...</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="p">...</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">anotherFunction</span><span class="p">(</span><span class="n">t</span><span class="p">...);</span>
    <span class="c1">//                ^ t is expanded here! </span>
<span class="p">}</span>
</pre></div>


<p>Finally, you can call this function <strong>f</strong> as you would with a normal function template:</p>
<div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="n">class</span><span class="p">...</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="p">...</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">anotherFunction</span><span class="p">(</span><span class="n">t</span><span class="p">...);</span>
<span class="p">}</span>

<span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="s">&quot;bar&quot;</span><span class="p">);</span> <span class="c1">// Note: the argument deduction avoids us to use f&lt;int, const char*, const char*&gt;</span>
<span class="c1">// f(1, &quot;foo&quot;, &quot;bar&quot;) calls a generated f(int t1, const char* t2, const char* t3)</span>
<span class="c1">// with T1 = int, T2 = const char* and T3 = const char*,</span>
<span class="c1">// that itself calls anotherFunction(t1, t2, t3) equivalent to call anotherFunction(1, &quot;foo&quot;, &quot;bar&quot;);</span>
</pre></div>


<p>Actually, the <strong>expansion mechanism</strong> is creating <strong>comma-separated</strong> replication of the <strong>pattern</strong> you apply the <strong>ellipsis</strong> onto. If you think I am tripping out with template-related wording, here is a much more concret example:</p>
<div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="n">class</span><span class="p">...</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">g</span><span class="p">(</span><span class="n">T</span><span class="p">...</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">anotherFunction</span><span class="p">(</span><span class="n">t</span><span class="p">...);</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="n">class</span><span class="p">...</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="p">...</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">g</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">)...);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

    <span class="n">f</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span> <span class="c1">// Call f(int* t1, int* t2).</span>
    <span class="c1">// Do a subcall to g(static_cast&lt;double&gt;(*t1), static_cast&lt;double&gt;(*t2)).</span>

    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>I could use the pattern <strong>'*'</strong> for <strong>f</strong> parameters and therefore take them as a pointer! In the same manner, I applied the pattern <strong>'static_cast&lt; double&gt;(*)</strong> to get the value of each arguments and cast them as doubles before forwarding them to <strong>g</strong>.</p>
<p>One last example before moving to <strong>variadic class templates</strong>. One can combine "normal" template parameters with parameter packs and initiate a compile recursion on function templates. Let's take a look at this printing function:</p>
<div class="highlight"><pre><span class="cp">#include &lt;iostream&gt;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">HEAD</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="n">HEAD</span> <span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Stop: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">head</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">HEAD</span><span class="p">,</span> <span class="n">class</span><span class="p">...</span> <span class="n">TAIL</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="n">HEAD</span> <span class="n">head</span><span class="p">,</span> <span class="n">TAIL</span><span class="p">...</span> <span class="n">tail</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Recurse: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">head</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">print</span><span class="p">(</span><span class="n">tail</span><span class="p">...);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span> <span class="mi">1337</span><span class="p">,</span> <span class="s">&quot;foo&quot;</span><span class="p">);</span>

    <span class="c1">// Print:</span>
    <span class="c1">// Recurse: 42</span>
    <span class="c1">// Recurse: 1337</span>
    <span class="c1">// Stop: foo</span>

    <span class="c1">// Call print&lt;int, int, const char*&gt; (second version of print).</span>
    <span class="c1">// The first int (head) is printed and we call print&lt;int, const char*&gt; (second version of print).</span>
    <span class="c1">// The second int (head again) is printed and we call print&lt;const char*&gt; (first version of print).</span>
    <span class="c1">// We reach recursion stopping condition, only one element left.</span>

    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p><strong>Variadic templates</strong> are very interesting and I wouldn't be able to cover all their features within this post. It roughly feels like functional programming using your compiler, and even some <strong>Haskellers</strong> might listen to you if you bring that topic during a dinner. For those interested, I would challenge them to write a type-safe version of <strong>printf</strong> using variadic templates with the help of this <a href="http://en.cppreference.com/w/cpp/language/parameter_pack">reference</a>. After that, you will run and scream of fear at the precense of <strong>C</strong>'s <strong>vargs</strong>.</p>
<h5>"Variadic" inheritance:</h5>
<p>Sometimes during my programming sessions, I have a very awkward sensation that my crazy code will never compile and, yet, I finally see "build finished" in my terminal. I am talking about that kind of Frankenstein constructions:</p>
<div class="highlight"><pre><span class="k">struct</span> <span class="n">A</span> <span class="p">{</span> <span class="p">};</span>

<span class="k">struct</span> <span class="n">B</span> <span class="p">{</span> <span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="n">class</span><span class="p">...</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nl">C</span><span class="p">:</span> <span class="k">public</span> <span class="n">T</span><span class="p">...</span> <span class="c1">// Variadic inheritance</span>
<span class="p">{</span>

<span class="p">};</span>

<span class="n">C</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="o">&gt;</span> <span class="n">c</span><span class="p">;</span>
</pre></div>


<p>Yes, we can now create a class inheriting of an infinite number of bases. If you remember my explanation about pattern replications separated by commas, you can imaginge that <strong>struct C: public T...</strong> will be "transformed" in <strong>struct C: public A, public B</strong>, <strong>public T</strong> being the pattern. We start to be able to combine multiple types, each exposing a small amount of methods, to create a flexible concret type. That's one step closer to our multi-type map, and if you are interested in this concept, take a look at <a href="https://en.wikipedia.org/wiki/Mixin">mixins</a>.</p>
<p>Instead of inheriting directly from multiple types, couldn't we inherit from some types that encapsulate our types? Absolutely! A traditional map has some <strong>slots</strong> accessible using keys and these slots contain a value. If you give me base-class you are looking for, I can give you access to the value it contains:</p>
<div class="highlight"><pre><span class="cp">#include &lt;iostream&gt;</span>

<span class="k">struct</span> <span class="n">SlotA</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">SlotB</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Note: private inheritance, no one can access directly to the slots other than C itself.</span>
<span class="k">struct</span> <span class="nl">Repository</span><span class="p">:</span> <span class="k">private</span> <span class="n">SlotA</span><span class="p">,</span> <span class="k">private</span> <span class="n">SlotB</span>
<span class="p">{</span>

    <span class="kt">void</span> <span class="n">setSlotA</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// I access the base-class&#39;s value</span>
        <span class="c1">// Since we have multiple base with a value field, we need to &quot;force&quot; the access to SlotA.</span>
        <span class="n">SlotA</span><span class="o">::</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">getSlotA</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">SlotA</span><span class="o">::</span><span class="n">value</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">setSlotB</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">SlotB</span><span class="o">::</span><span class="n">value</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getSlotB</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">SlotB</span><span class="o">::</span><span class="n">value</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Repository</span> <span class="n">r</span><span class="p">;</span>

    <span class="n">r</span><span class="p">.</span><span class="n">setSlotA</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">r</span><span class="p">.</span><span class="n">getSlotA</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// Print: 42.</span>

    <span class="n">r</span><span class="p">.</span><span class="n">setSlotB</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;toto&quot;</span><span class="p">));</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">r</span><span class="p">.</span><span class="n">getSlotB</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// Print: &quot;toto&quot;.</span>

    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>This code is not generic at all! We know how to create a generic <strong>Slot</strong> using a simple template, and we acquired the magic "create varidiac inheritance" skill. If my <strong>Repository</strong> class inherit from <strong>Slot&lt; TypeA&gt;</strong> and you call a method template with <strong>TypeA</strong> as a template argument, I can call the <strong>doGet</strong> method of the <strong>Slot&lt; TypeA&gt;</strong> base-class and give you back the <strong>value</strong> of <strong>TypeA</strong> in that repository. Let's fix the previous ugly copy-paste code:</p>
<div class="highlight"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;string&gt;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Type</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Slot</span>
<span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="n">Type</span><span class="o">&amp;</span> <span class="n">doGet</span><span class="p">()</span> <span class="c1">// A nice encapsulation, that will be usefull later on.</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">value_</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">doSet</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="c1">// Same encapsulation.</span>
    <span class="p">{</span>
        <span class="n">value_</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
    <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">Type</span> <span class="n">value_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="n">class</span><span class="p">...</span> <span class="n">Slots</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Repository</span> <span class="o">:</span> <span class="k">private</span> <span class="n">Slots</span><span class="p">...</span> <span class="c1">// inherit from our slots...</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Type</span><span class="o">&gt;</span> <span class="c1">// Give me a type and,</span>
    <span class="n">Type</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">Slot</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">doGet</span><span class="p">();</span> <span class="c1">// I can select the Base class.</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Type</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">set</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Slot</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">doSet</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Incomplete types used as compile-time keys.</span>
<span class="k">struct</span> <span class="n">Key1</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">Key2</span><span class="p">;</span>

<span class="c1">// Create a type for our repository.</span>
<span class="k">using</span> <span class="n">MyRepository</span> <span class="o">=</span> <span class="n">Repository</span>
        <span class="o">&lt;</span>
                <span class="n">Slot</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span>       <span class="c1">// Let&#39;s pick the type of our slots.</span>
                <span class="n">Slot</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span>
        <span class="o">&gt;</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">MyRepository</span> <span class="n">myRepository</span><span class="p">;</span>

    <span class="n">myRepository</span><span class="p">.</span><span class="n">set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;toto&quot;</span><span class="p">);</span>
    <span class="n">myRepository</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span> <span class="c1">// Notice the type deduction: we pass an int, so it writes in the int slot.</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">myRepository</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// Print: &quot;toto&quot;.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">myRepository</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// Print: 42.</span>

    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>This repository starts to take shape, but we are not yet done! If you try to have two int slots, you will raise a compilation error: "base class 'Slot<int>' specified more than once as a direct base class". We need to add another key-type to our slot class with a default value and we need to modify our repository methods to handle it:</p>
<div class="highlight"><pre><span class="k">struct</span> <span class="n">DefaultSlotKey</span><span class="p">;</span> <span class="c1">// No needs for a definition</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Key</span> <span class="o">=</span> <span class="n">DefaultSlotKey</span><span class="o">&gt;</span> <span class="c1">// The Key type will never be trully used. </span>
<span class="k">class</span> <span class="nc">Slot</span>
<span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="n">class</span><span class="p">...</span> <span class="n">Slots</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Repository</span> <span class="o">:</span> <span class="k">private</span> <span class="n">Slots</span><span class="p">...</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Type</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Key</span> <span class="o">=</span> <span class="n">DefaultSlotKey</span><span class="o">&gt;</span> <span class="c1">// The default key must be here too.</span>
    <span class="n">Type</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">Slot</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">Key</span><span class="o">&gt;::</span><span class="n">doGet</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Type</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Key</span> <span class="o">=</span> <span class="n">DefaultSlotKey</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">set</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Slot</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">Key</span><span class="o">&gt;::</span><span class="n">doSet</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">Key1</span><span class="p">;</span> <span class="c1">// No need for definition.</span>
<span class="k">struct</span> <span class="n">Key2</span><span class="p">;</span>

<span class="c1">// Now you can do:</span>
<span class="k">using</span> <span class="n">MyRepository</span> <span class="o">=</span> <span class="n">Repository</span>
    <span class="o">&lt;</span>
            <span class="n">Slot</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span>       <span class="c1">// Let&#39;s pick the type of our slots.</span>
            <span class="n">Slot</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">Key1</span><span class="o">&gt;</span><span class="p">,</span>
            <span class="n">Slot</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">Key2</span><span class="o">&gt;</span>
    <span class="o">&gt;</span><span class="p">;</span>
</pre></div>


<p>Here is a UML representation of this Repository using distinct <strong>Keys</strong> for the type <strong>std::string</strong>:
<img alt="A nice UML diagram of my classes" src="//jguegant.github.io/blogs/tech/images/repository_uml.png" /></p>
<p>Our repository class is missing an <strong>emplace</strong> method, right? <strong>emplace</strong> is taking a variable number of arguments with different types and <strong>forward</strong> them to create an object within one of our slots. A variable number of arguments and types must remind you something... <strong>variadic templates</strong>! Let's create this variadic <strong>emplace</strong> method as well as its equivalent in the Slot class:</p>
<div class="highlight"><pre><span class="c1">// In class Slot:</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="n">class</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">doEmplace</span><span class="p">(</span><span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="c1">// Here the pattern is const  &amp;.</span>
<span class="p">{</span>
    <span class="n">value_</span> <span class="o">=</span> <span class="n">Type</span><span class="p">(</span><span class="n">args</span><span class="p">...);</span> <span class="c1">// copy-operator (might use move semantics).</span>
<span class="p">}</span>

<span class="c1">// In class Repository:</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Type</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Key</span> <span class="o">=</span> <span class="n">DefaultSlotKey</span><span class="p">,</span> <span class="n">class</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">emplace</span><span class="p">(</span><span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="c1">// Here the pattern is const  &amp;.</span>
<span class="p">{</span>
    <span class="n">Slot</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">Key</span><span class="o">&gt;::</span><span class="n">doEmplace</span><span class="p">(</span><span class="n">args</span><span class="p">...);</span>
<span class="p">}</span>

<span class="c1">// Usage:</span>
<span class="n">myRepository</span><span class="p">.</span><span class="n">emplace</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">);</span> <span class="c1">// Create a std::string &quot;aaaa&quot;.</span>
</pre></div>


<p>One last improvement for the future users of your repositories! If one morning, badly awake, a coworker of yours is trying to get a type or key that doesn't exist (like myRepository.get&lt; double&gt;();), he might be welcomed by such a message:</p>
<div class="highlight"><pre><span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">jguegant</span><span class="o">/</span><span class="n">Coding</span><span class="o">/</span><span class="n">ConfigsRepo</span><span class="o">/</span><span class="n">main</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">36</span><span class="o">:</span><span class="mi">33</span><span class="o">:</span> <span class="nl">error</span><span class="p">:</span> <span class="n">call</span> <span class="n">to</span> <span class="n">non</span><span class="o">-</span><span class="k">static</span> <span class="n">member</span> <span class="n">function</span> <span class="n">without</span> <span class="n">an</span> <span class="n">object</span> <span class="n">argument</span>
    <span class="k">return</span> <span class="n">Slot</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">Key</span><span class="o">&gt;::</span><span class="n">doGet</span><span class="p">();</span>
           <span class="o">~~~~~~~~~~~~~~~~~^~~~~</span>
<span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">jguegant</span><span class="o">/</span><span class="n">Coding</span><span class="o">/</span><span class="n">ConfigsRepo</span><span class="o">/</span><span class="n">main</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">67</span><span class="o">:</span><span class="mi">18</span><span class="o">:</span> <span class="nl">note</span><span class="p">:</span> <span class="n">in</span> <span class="n">instantiation</span> <span class="n">of</span> <span class="n">function</span> <span class="k">template</span> <span class="n">specialization</span> <span class="err">&#39;</span><span class="n">Repository</span><span class="o">&lt;</span><span class="n">Slot</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">DefaultSlotKey</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Slot</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">__1</span><span class="o">::</span><span class="n">basic_string</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">DefaultSlotKey</span><span class="o">&gt;</span> <span class="o">&gt;::</span><span class="n">get</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">DefaultSlotKey</span><span class="o">&gt;</span><span class="err">&#39;</span> <span class="n">requested</span> <span class="n">here</span>
    <span class="n">myRepository</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">();</span>
                 <span class="o">^</span>
<span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">jguegant</span><span class="o">/</span><span class="n">Coding</span><span class="o">/</span><span class="n">ConfigsRepo</span><span class="o">/</span><span class="n">main</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">36</span><span class="o">:</span><span class="mi">33</span><span class="o">:</span> <span class="nl">error</span><span class="p">:</span> <span class="err">&#39;</span><span class="n">doGet</span><span class="err">&#39;</span> <span class="n">is</span> <span class="n">a</span> <span class="k">protected</span> <span class="n">member</span> <span class="n">of</span> <span class="err">&#39;</span><span class="n">Slot</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">DefaultSlotKey</span><span class="o">&gt;</span><span class="err">&#39;</span>
        <span class="k">return</span> <span class="n">Slot</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">Key</span><span class="o">&gt;::</span><span class="n">doGet</span><span class="p">();</span>
                                <span class="o">^</span>
<span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">jguegant</span><span class="o">/</span><span class="n">Coding</span><span class="o">/</span><span class="n">ConfigsRepo</span><span class="o">/</span><span class="n">main</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">10</span><span class="o">:</span><span class="mi">11</span><span class="o">:</span> <span class="nl">note</span><span class="p">:</span> <span class="n">declared</span> <span class="k">protected</span> <span class="n">here</span>
    <span class="n">Type</span><span class="o">&amp;</span> <span class="n">doGet</span><span class="p">()</span>
          <span class="o">^</span>
<span class="mi">2</span> <span class="n">errors</span> <span class="n">generated</span><span class="p">.</span>
</pre></div>


<p>This message is very confusing, our class does not inherit from <strong>Slot&lt; double, DefaultSlotKey&gt;</strong>! And we are talking about a <strong>clang</strong> output, I wonder what <strong>gcc</strong> or <strong>MSVC</strong> could produce... If you do not want to be assinated from your moody colleague with a spoon, here is a nice solution using <strong>C++11</strong>'s <a href="http://en.cppreference.com/w/cpp/language/static_assert">static_asserts</a>. <strong>Static asserts</strong> give you the possibility to generate your own compiler error messages in the same fashion as normal asserts but at compile-time. Using a the trait like <strong>std::is_base_of</strong>, you can suggest the user of your repository to check twice his type. Let's put this <strong>static_assert</strong> at the beggining of all the methods of <strong>Repository</strong>:</p>
<div class="highlight"><pre><span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_base_of</span><span class="o">&lt;</span><span class="n">Slot</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">Key</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Repository</span><span class="o">&lt;</span><span class="n">Slots</span><span class="p">...</span><span class="o">&gt;&gt;::</span><span class="n">value</span><span class="p">,</span> 
          <span class="s">&quot;Please ensure that this type or this key exists in this repository&quot;</span><span class="p">);</span>
</pre></div>


<p>We are done for this part (finally...), time to think about multi-threading! If you want to know more about the magic behind <strong>std::is_base_of</strong>, I would suggest you to read my previous post on <a href="//jguegant.github.io/blogs/tech/sfinae-introduction.html">SFINAE</a>, it might give you few hints. Here is a <a href="https://gist.github.com/Jiwan/c1daf7a80ebeb166dc61">gist</a> of what we achieved so far. Did you notice the change on <strong>emplace</strong>? If you do not understand it, have a look at <a href="http://thbecker.net/articles/rvalue_references/section_07.html">this explanation on perfect forwarding</a>. Sadly, it would be a way too long topic for this post (trust me on that point!) and has a minor impact on our repository right now.</p>
<h4>Let's play safe:</h4>
<p>The repository we just succeeded to craft can now be used in a single-thread environment without further investigation. But the initial decision was to make this class manipulable from multiple-threads without any worries considering the safety of our operations. As explained in the beginning of this post, we will not use direct values as we currently do, but instead allocate our objects on the heap and use some <strong>shared pointers</strong> to strictly control their <strong>lifetime</strong>. No matter which version (recent or deprecated) of the object a thread is manipulating, it's lifetime will be extended until the last thread using it definitely release it. It also implies that the objects themselves are thread-safe. In the case of read-only objects like configs or assets, it shouldn't be too much a burden. In this <a href="https://gist.github.com/Jiwan/cb66d01c38128a351f42">gist</a>, you will find a repository version using <strong>std::shared_ptrs</strong>.</p>
<p><strong>std::shared_ptr</strong> is an amazing feature of <strong>C++11</strong> when dealing with multi-threading, but has its weakness. Within my code (in the previous gist link) a race condition can occur:</p>
<div class="highlight"><pre><span class="c1">// What if I try to copy value_ at the return point...</span>
<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span> <span class="n">doGet</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">value_</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ... meanwhile another thread is changing value_ to value?</span>
<span class="kt">void</span> <span class="n">doSet</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">value_</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>As specified: "If multiple threads of execution access the <strong>same</strong> std::shared_ptr object without synchronization and any of those accesses uses a non-const member function of shared_ptr then a data race will occur". Note that we are talking about the <strong>same</strong> shared pointer. Multiple shared pointer <strong>copies</strong> pointing to the same object are fine, as long as these copies originated from the same shared pointer in first place. Copies are sharing the same <strong>control block</strong>, where the <strong>reference counters</strong> (one for shared_ptr and one for weak_ptr) are located, and the specification says "the control block of a shared_ptr is thread-safe: different std::shared_ptr objects can be accessed using mutable operations, such as operator= or reset, simultaneously by multiple threads, even when these instances are copies, and share the same control block internally.".</p>
<p>Depending on the age of your compiler and its standard library, I suggest two solutions:</p>
<h5>1) A global mutex:</h5>
<p>A straightforward solution relies on a <a href="http://en.cppreference.com/w/cpp/thread/mutex">std::mutex</a> that we lock during <strong>doGet</strong> and <strong>doSet</strong> execution:</p>
<div class="highlight"><pre><span class="p">...</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span> <span class="n">doGet</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// The lock is enabled until value_ has been copied!</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">value_</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">doSet</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// The lock is enabled until value has been copied into value!</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span>
        <span class="n">value_</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mutex_</span><span class="p">;</span>
<span class="p">...</span>
</pre></div>


<p>This solution is ideal if you have a <strong>Linux</strong> distribution that only ships <strong>gcc 4.8.x</strong> like mine. While not particularly elegant, it doesn't have a great impact on performances compared to the next solution. </p>
<h5>2) Atomic access functions:</h5>
<p>Starting from <strong>gcc 4.9</strong>, one can use <a href="http://en.cppreference.com/w/cpp/memory/shared_ptr/atomic">atomic access functions</a> to manipulate shared pointers. I dream of a day where a specialisation for <strong>std::atomic&lt; std::shared_ptr<T>&gt;</strong> exists, but from now, we will resort to use <strong>std::atomic_load</strong> and <strong>std::atomic_exchange</strong>:</p>
<div class="highlight"><pre><span class="p">...</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span> <span class="n">doGet</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">atomic_load</span><span class="p">(</span><span class="o">&amp;</span><span class="n">value_</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">doSet</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">atomic_exchange</span><span class="p">(</span><span class="o">&amp;</span><span class="n">value_</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span> <span class="n">value_</span><span class="p">;</span>
<span class="p">...</span>
</pre></div>


<p><strong>Atomics</strong> are elegants and can often bring a great increase of performances if using lock-free instructions internally. Sadly, in the case of <strong>shared_ptrs</strong>, <strong>atomic_is_lock_free</strong> will return you <strong>false</strong>. By digging in <strong>libstdc++</strong> and <strong>libc++</strong>, you will find some mutexes. <strong>gcc</strong> seems to use a fixed size "pool" of mutexes attributed to a shared_ptr according to a hash of its pointee address, when dealing with atomic operations. In other words, no rocket-science for atomic shared pointers until now.</p>
<h4>Our own watchers:</h4>
<p>"...I shall live and die at my post. I am the sword in the darkness. I am the watcher on the walls. I am the shield that guards the realms of men..." <strong>-- The Night's Watch oath</strong></p>
<p>We want to be able to seal a bond between one of the slot and a context. By context, I mean the lifetime of an object in a thread, a function or a method. If an update has been made on that slot, we must be signaled in that context and to retrieve the new update. The bond must be destroyed if the context does not exist anymore. It should reminds you the Night's Watch oath ... as well as the <a href="https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">RAII idiom</a>: "holding a resource is tied to object lifetime: resource acquisition is done during object creation, by the constructor, while resource deallocation is done during object destruction, by the destructor. If objects are destroyed properly, resource leaks do not occur.". A strong ownership policy can be obtained with the help of a <a href="http://en.cppreference.com/w/cpp/memory/unique_ptr">std::unique_ptr</a> and the signalisation can be done using a <strong>boolean flag</strong>.</p>
<p>We will, therefore, encapsulate a <a href="http://en.cppreference.com/w/cpp/atomic/atomic">std::atomic_bool</a> into a class <strong>Watcher</strong> automagically registered to a slot once created, and unregistered once destructed. This <strong>Watcher</strong> class also takes as a reference the slot in order to query its value as you can see:</p>
<div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Type</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Key</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Watcher</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Watcher</span><span class="p">(</span><span class="n">Slot</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">Key</span><span class="o">&gt;&amp;</span> <span class="n">slot</span><span class="p">)</span><span class="o">:</span>
            <span class="n">slot_</span><span class="p">(</span><span class="n">slot</span><span class="p">),</span>
            <span class="n">hasBeenChanged_</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="n">Watcher</span><span class="p">(</span><span class="k">const</span> <span class="n">Watcher</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>               <span class="c1">// Impossible to copy that class.</span>

    <span class="n">Watcher</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Watcher</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>   <span class="c1">// Impossible to copy that class.</span>

    <span class="kt">bool</span> <span class="n">hasBeenChanged</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">hasBeenChanged_</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">triggerChanges</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">hasBeenChanged_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">auto</span> <span class="n">get</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Slot</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">Key</span><span class="o">&gt;&gt;</span><span class="p">().</span><span class="n">doGet</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">hasBeenChanged_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// Note: even if there is an update of the value between this line and the getValue one,</span>
        <span class="c1">// we will still have the latest version.</span>
        <span class="c1">// Note 2: atomic_bool automatically use a barrier and the two operations can&#39;t be inversed.</span>
        <span class="k">return</span> <span class="n">slot_</span><span class="p">.</span><span class="n">doGet</span><span class="p">();</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">Slot</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">Key</span><span class="o">&gt;&amp;</span> <span class="n">slot_</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">atomic_bool</span> <span class="n">hasBeenChanged_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>As for the automatic registration, we will add two private methods <strong>registerWatcher</strong> and <strong>unregisterWatcher</strong> to our <strong>Slot</strong> class that add or remove a watcher from an internal list. The list is always protected, when accessed, with a <strong>std::mutex</strong> and tracks all the current watchers that must be signaled when <strong>set</strong> is called on that slot. </p>
<div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Type</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Key</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Slot</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">using</span> <span class="n">ThisType</span> <span class="o">=</span> <span class="n">Slot</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">Key</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">WatcherType</span> <span class="o">=</span> <span class="n">Watcher</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">Key</span><span class="o">&gt;</span><span class="p">;</span>

<span class="p">...</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">registerWatcher</span><span class="p">(</span><span class="n">WatcherType</span><span class="o">*</span> <span class="n">newWatcher</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">(</span><span class="n">watchers_mutex_</span><span class="p">);</span>
        <span class="n">watchers_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">newWatcher</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">unregisterWatcher</span><span class="p">(</span><span class="n">WatcherType</span> <span class="o">*</span><span class="n">toBeDelete</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">(</span><span class="n">watchers_mutex_</span><span class="p">);</span>
        <span class="n">watchers_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">remove</span><span class="p">(</span><span class="n">watchers_</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">watchers_</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">toBeDelete</span><span class="p">),</span> <span class="n">watchers_</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

        <span class="k">delete</span> <span class="n">toBeDelete</span><span class="p">;</span> <span class="c1">// Now that we removed the watcher from the list, we can proceed to delete it.</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">signal</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">(</span><span class="n">watchers_mutex_</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">watcher</span> <span class="p">:</span> <span class="n">watchers_</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">watcher</span><span class="o">-&gt;</span><span class="n">triggerChanges</span><span class="p">();</span> <span class="c1">// Let&#39;s raise the hasBeenChanged_ atomic boolean flag. </span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">WatcherType</span><span class="o">*&gt;</span> <span class="n">watchers_</span><span class="p">;</span> <span class="c1">// All the registered watchers are in that list.</span>

<span class="p">...</span>
<span class="p">};</span>
</pre></div>


<p>You may have notice that we are passing a bare <strong>WatcherType</strong> pointers. The ownership is actually given to whoever is using that watcher encapsulated within a <strong>std::unique_ptr</strong>. <strong>C++11</strong>'s unique pointers are designed such as you can pass a <strong>custom deleter</strong>, or a <strong>delete callback</strong> so to speak. Hence, we can create a method that get a <strong>Watcher</strong> for a <strong>Slot</strong>, and register as the deleter of that <strong>Watcher</strong> a <strong>lambda function</strong> designed to call <strong>unregisterWatcher</strong>. Note that the slot MUST always lives longer than the unique pointer and its associated watcher (it should not be a problem in most cases). Let's finish that <strong>Slot</strong> class forever and ever:</p>
<div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Type</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Key</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Slot</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">using</span> <span class="n">ThisType</span> <span class="o">=</span> <span class="n">Slot</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">Key</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">WatcherType</span> <span class="o">=</span> <span class="n">Watcher</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">Key</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="c1">// We use unique_ptr for a strong ownership policy.</span>
    <span class="c1">// We use std::function to declare the type of our deleter.</span>
    <span class="k">using</span> <span class="n">WatcherTypePtr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">WatcherType</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">WatcherType</span><span class="o">*</span><span class="p">)</span><span class="o">&gt;&gt;</span> <span class="p">;</span>

<span class="p">...</span>

<span class="k">public</span><span class="o">:</span>
    <span class="n">WatcherTypePtr</span> <span class="n">doGetWatcher</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// Create a unique_ptr and pass a lambda as a deleter.</span>
        <span class="c1">// The lambda capture &quot;this&quot; and will call unregisterWatcher.</span>
        <span class="n">WatcherTypePtr</span> <span class="n">watcher</span><span class="p">(</span><span class="k">new</span> <span class="n">WatcherType</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">),</span> <span class="p">[</span><span class="k">this</span><span class="p">](</span><span class="n">WatcherType</span><span class="o">*</span> <span class="n">toBeDelete</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">unregisterWatcher</span><span class="p">(</span><span class="n">toBeDelete</span><span class="p">);});</span>

        <span class="n">registerWatcher</span><span class="p">(</span><span class="n">watcher</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>

        <span class="k">return</span> <span class="n">watcher</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">...</span>
<span class="p">};</span>
</pre></div>


<p>Are we done? Hell no, but we will be really soon. All we need is to expose the possibility to acquire a watcher from the repository itself. In the same manner as <strong>set</strong> and <strong>get</strong>, we simply dispatch using the type and the key on one of our slot:</p>
<div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Type</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Key</span> <span class="o">=</span> <span class="n">DefaultSlotKey</span><span class="o">&gt;</span>
<span class="k">typename</span> <span class="n">Slot</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">Key</span><span class="o">&gt;::</span><span class="n">WatcherTypePtr</span> <span class="n">getWatcher</span><span class="p">()</span> <span class="c1">// typename is used for disambiguate</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">Slot</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">Key</span><span class="o">&gt;::</span><span class="n">doGetWatcher</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>


<p><strong>WAIT</strong>, don't close that page too fast. If you want to be able to snub everyone, you can replace this ugly <strong>typename Slot<Type, Key>::WatcherTypePtr</strong> with <strong>auto</strong> and claim that your repository class is <strong>C++14</strong> only! Grab the full code of what we build together on <a href="https://gist.github.com/Jiwan/31f8f837e4f4b90fed13">gist</a> and enjoy!</p>
<h3>Conclusion:</h3>
<p>Once again, I hope you enjoyed this post about one of my favourite subject: C++. I might not be the best teacher nor the best author but I wish that you learnt something today! Please, if you any suggestions or questions, feel free to post anything in the commentaries. My broken English being what it is, I kindly accept any help for my written mistakes.</p>
<p>Many thanks to my colleagues that greatly helped me by reviewing my code and for the time together.</p>
  </div>
  <hr />
</article>
<article>
  <header>
    <h2><a href="//jguegant.github.io/blogs/tech/sfinae-introduction.html#sfinae-introduction">An introduction to C++'s SFINAE concept: compile-time introspection of a class member</a></h2>
    <p>
      Posted on Sat 31 October 2015 in <a href="//jguegant.github.io/blogs/tech/category/c.html">C++</a>
      &#8226; Tagged with
      <a href="//jguegant.github.io/blogs/tech/tag/c11.html">C++11</a>,      <a href="//jguegant.github.io/blogs/tech/tag/c14.html">C++14</a>,      <a href="//jguegant.github.io/blogs/tech/tag/tmp.html">TMP</a>,      <a href="//jguegant.github.io/blogs/tech/tag/meta-programming.html">meta programming</a>      &#8226; <a href="//jguegant.github.io/blogs/tech/sfinae-introduction.html#disqus_thread">Leave a comment</a>
    </p>
  </header>
  <div>
      <!-- http://stackoverflow.com/questions/18570285/using-sfinae-to-detect-a-member-function -->

<h3>Trivia:</h3>
<p>As a C++ enthusiast, I usually follow the annual C++ conference <a href="http://cppcon.org/">cppconf</a> or at least try to keep myself up-to-date with the major events that happen there. One way to catch up, if you can't afford a plane ticket or the ticket, is to follow the <a href="https://www.youtube.com/channel/UCMlGfpWw-RUdWX_JbLCukXg">youtube channel</a> dedicated to this conference. This year, I was impressed by <strong>Louis Dionne</strong> talk entitled "C++ Metaprogramming: A Paradigm Shift". One feature called <strong>is_valid</strong> that can be found in Louis's <a href="http://github.com/boostorg/hana">Boost.Hana</a> library particulary caught my attention. This genious <strong>is_valid</strong> function heavily rely on an even more "magic" C++ programming technique coined with the term <strong>SFINAE</strong> discovered at the end of the previous century. If this acronym doesn't speak to you, don't be scared, we are going to dive straight in the subject.</p>
<p>Note: for the sake of your sanity and the fact that <em>errare humanum est</em>, this article might not be 100% accurate!</p>
<h3>Introspection in C++?</h3>
<p>Before explaining what is <strong>SFINAE</strong>, let's explore one of its main usage: <strong>introspection</strong>. As you might be aware, C++ doesn't excel when it comes to examine the type or properties of an object at runtime. The best ability provided by default would be <a href="https://en.wikipedia.org/wiki/Run-time_type_information">RTTI</a>. Not only <strong>RTTI</strong> isn't always available, but it also gives you barely more than the current type of the manipulated object. Dynamic languages or those having <strong>reflection</strong> on the other hand are really convenient in some situations like <strong>serialization</strong>.</p>
<p>For instance, in Python, using reflection, one can do the following:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="c"># Simply overrides the &#39;object.__str__&#39; method.</span>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;I am a A&quot;</span>

<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="c"># A custom method for my custom objects that I want to serialize.</span>
    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;I am a B&quot;</span>

<span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># Oups! &#39;serialize&#39; is not a method. </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">serialize</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;I am a C&quot;</span>

<span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="c"># Let&#39;s check if obj has an attribute called &#39;serialize&#39;.</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s">&quot;serialize&quot;</span><span class="p">):</span>
        <span class="c"># Let&#39;s check if this &#39;serialize&#39; attribute is a method.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">serialize</span><span class="p">,</span> <span class="s">&quot;__call__&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">serialize</span><span class="p">()</span>

    <span class="c"># Else we call the __str__ method.</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="p">()</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>

<span class="k">print</span><span class="p">(</span><span class="n">serialize</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="c"># output: I am a A.</span>
<span class="k">print</span><span class="p">(</span><span class="n">serialize</span><span class="p">(</span><span class="n">b</span><span class="p">))</span> <span class="c"># output: I am a B.</span>
<span class="k">print</span><span class="p">(</span><span class="n">serialize</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="c"># output: I am a C.</span>
</pre></div>


<p>As you can see, during serialization, it comes pretty handy to be able to check if an object has an attribute and to query the type of this attribute. In our case, it permits us to use the <strong>serialize</strong> method if available and fall back to the more generic method <strong>str</strong> otherwise. Powerful, isn't it? Well, we can do it <strong>in plain C++</strong>!</p>
<p>Here is the <strong>C++14</strong> solution mentionned in <strong>Boost.Hana</strong> documentation, using <strong>is_valid</strong>:</p>
<div class="highlight"><pre><span class="cp">#include &lt;boost/hana.hpp&gt;</span>
<span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;string&gt;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">namespace</span> <span class="n">hana</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">hana</span><span class="p">;</span>

<span class="c1">// Check if a type has a serialize method.</span>
<span class="k">auto</span> <span class="n">hasSerialize</span> <span class="o">=</span> <span class="n">hana</span><span class="o">::</span><span class="n">is_valid</span><span class="p">([](</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">serialize</span><span class="p">())</span> <span class="p">{</span> <span class="p">});</span>

<span class="c1">// Serialize any kind of objects.</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">serialize</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">hana</span><span class="o">::</span><span class="n">if_</span><span class="p">(</span><span class="n">hasSerialize</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="c1">// Serialize is selected if available!</span>
                     <span class="p">[](</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span><span class="p">.</span><span class="n">serialize</span><span class="p">();</span> <span class="p">},</span>
                     <span class="p">[](</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">to_string</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="p">}</span>
    <span class="p">)(</span><span class="n">obj</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Type A with only a to_string overload.</span>
<span class="k">struct</span> <span class="n">A</span> <span class="p">{};</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">to_string</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;I am a A!&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Type B with a serialize method.</span>
<span class="k">struct</span> <span class="n">B</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">serialize</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="s">&quot;I am a B!&quot;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Type C with a &quot;wrong&quot; serialize member (not a method) and a to_string overload.</span>
<span class="k">struct</span> <span class="n">C</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">serialize</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">to_string</span><span class="p">(</span><span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;I am a C!&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">A</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">B</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">C</span> <span class="n">c</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">serialize</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">serialize</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">serialize</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>As you can see, it only requires a bit more of boilerplate than Python, but not as much as you would expect from a language as complexe as C++. How does it work? Well if you are too lazy to read the rest, here is the simplest answer I can give you: unlike dynamically typed languages, your compiler has access a lot of static type information once fired. It makes sense that we can constraint your compiler to do a bit of work on these types! The next question that comes to your mind is "How to?". Well, right below we are going to explore the various options we have to enslave our favorite compiler for fun and profit! And we will eventually recreate our own <strong>is_valid</strong>.</p>
<h3>The old-fashioned C++98-way:</h3>
<p>Whether your compiler is a dinosaur, your boss refuses to pay for the latest Visual Studio license or you simply love archeology, this chapter will interest you. It's also interesting for the people stuck between C++11 and C++14. The solution in C++98 relies on 3 key concepts: <strong>overload resolution</strong>, <strong>SFINAE</strong> and the static behavior of <strong>sizeof</strong>. </p>
<h4>Overload resolution:</h4>
<p>A simple function call like "<strong>f(obj);</strong>"" in <strong>C++</strong> activates a mechanism to figure out which <strong>f</strong> function shoud be called according to the argument <strong>obj</strong>. If a <strong>set</strong> of <strong>f</strong> functions could accept <strong>obj</strong> as an argument, the compiler must choose the most appropriate function, or in other words <strong>resolve</strong> the best <strong>overload</strong>! Here is a good cppreference page explaining the full process: <a href="http://en.cppreference.com/w/cpp/language/overload_resolution">Overload resolution</a>. The rule of thumb in this case is <em>the compiler picks the candidate function whose parameters match the arguments most closely is the one that is called</em>. Nothing is better than a good example:</p>
<div class="highlight"><pre><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">);</span> <span class="c1">// int can&#39;t be convert into a string.</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">double</span> <span class="n">d</span><span class="p">);</span> <span class="c1">// int can be implicitly convert into a double, so this version could be selected, but...</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span> <span class="c1">// ... this version using the type int directly is even more close!</span>

<span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// Call f(int i);</span>
</pre></div>


<p>In C++ you also have some sink-hole functions that accept everything. First, function templates accept any kind of parameter (let's say T). But the true black-hole of your compiler, the devil variable vacuum, the oblivion of the forgotten types are the <a href="http://en.cppreference.com/w/cpp/utility/variadic">variadic functions</a>. Yes, exactly like the horrible C <strong>printf</strong>.</p>
<div class="highlight"><pre><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">f</span><span class="p">(...);</span> <span class="c1">// Variadic functions are so &quot;untyped&quot; that...</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">f</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">);</span> <span class="c1">// ...this templated function got the precedence!</span>

<span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// Call the templated function version of f.</span>
</pre></div>


<p>The fact that function templates are less generic than variadic functions is the first point you must remember!</p>
<p>Note: A <strong>templated function</strong> can actually be more precise than a <strong>normal function</strong>. However, in case of a draw, the <strong>normal function</strong> will have the precedence. </p>
<h4>SFINAE:</h4>
<p>I am already teasing you with the power for already few paragraphs and here finally comes the explanation of this not so complex acronym. <strong>SFINAE</strong> stands for <strong>S</strong>ubstitution <strong>F</strong>ailure <strong>I</strong>s <strong>N</strong>ot <strong>A</strong>n <strong>E</strong>rror. In rough terms, a <strong>substitution</strong> is the mechanism that tries to replace the template parameters with the provided types or values. In some cases, if the <strong>substitution</strong> leads to an invalid code, the compiler shouldn't throw a massive amount of errors but simply continue to try the other available <strong>overloads</strong>. The <strong>SFINAE</strong> concept simply guaranties such a "sane" behavior for a "sane" compiler. For instance:</p>
<div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> The compiler will try this overload since it&#39;s less generic than the variadic.</span>
<span class="cm"> T will be replace by int which gives us void f(const int&amp; t, int::iterator* b = nullptr);</span>
<span class="cm"> int doesn&#39;t have an iterator sub-type, but the compiler doesn&#39;t throw a bunch of errors.</span>
<span class="cm"> It simply tries the next overload. </span>
<span class="cm">*/</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">iterator</span><span class="o">*</span> <span class="n">it</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="c1">// The sink-hole.</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(...)</span> <span class="p">{</span> <span class="p">}</span>

<span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// Calls void f(...) { }</span>
</pre></div>


<p>All the expressions won't lead to a <strong>SFINAE</strong>. A broad rule would be to say that all the <strong>substitutions</strong> out of the function/methods <strong>body</strong> are "safes". For a better list, please take a look at this <a href="http://en.cppreference.com/w/cpp/language/sfinae">wiki page</a>. For instance, a wrong substitution within a function <strong>body</strong> will lead to a horrible C++ template error:</p>
<div class="highlight"><pre><span class="c1">// The compiler will be really unhappy when it will later discover the call to hahahaICrash. </span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="n">t</span><span class="p">.</span><span class="n">hahahaICrash</span><span class="p">();</span> <span class="p">}</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(...)</span> <span class="p">{</span> <span class="p">}</span> <span class="c1">// The sink-hole wasn&#39;t even considered.</span>

<span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</pre></div>


<h4>The operator sizeof:</h4>
<p>The <strong>sizeof operator</strong> is really a nice tool! It permits us to returns the size in bytes of a type or an expression at compilation time. <strong>sizeof</strong> is really interesting as it accurately evaluates an expression as precisely as if it were compiled.
One can for instance do:</p>
<div class="highlight"><pre><span class="k">typedef</span> <span class="kt">char</span> <span class="n">type_test</span><span class="p">[</span><span class="mi">42</span><span class="p">];</span>
<span class="n">type_test</span><span class="o">&amp;</span> <span class="n">f</span><span class="p">();</span>

<span class="c1">// In the following lines f won&#39;t even be truly called but we can still access to the size of its return type.</span>
<span class="c1">// Thanks to the &quot;fake evaluation&quot; of the sizeof operator.</span>
<span class="kt">char</span> <span class="n">arrayTest</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">f</span><span class="p">())];</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">f</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// Output 42.</span>
</pre></div>


<p>But wait! If we can manipulate some compile-time integers, couldn't we do some compile-time comparison? The answer is: absolutely yes, my dear reader! Here we are:</p>
<div class="highlight"><pre><span class="k">typedef</span> <span class="kt">char</span> <span class="n">yes</span><span class="p">;</span> <span class="c1">// Size: 1 byte.</span>
<span class="k">typedef</span> <span class="n">yes</span> <span class="n">no</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// Size: 2 bytes.</span>

<span class="c1">// Two functions using our type with different size.</span>
<span class="n">yes</span><span class="o">&amp;</span> <span class="n">f1</span><span class="p">();</span>
<span class="n">no</span><span class="o">&amp;</span> <span class="n">f2</span><span class="p">();</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">f1</span><span class="p">())</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">f2</span><span class="p">()))</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// Output 0.</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">f1</span><span class="p">())</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">f1</span><span class="p">()))</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// Output 1.</span>
</pre></div>


<h4>Combining everything:</h4>
<p>Now we have all the tools to create a solution to check the existence of a method within a type at compile time. You might even have already figured it out most of it by yourself. So let's create it:</p>
<div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">hasSerialize</span>
<span class="p">{</span>
    <span class="c1">// For the compile time comparison.</span>
    <span class="k">typedef</span> <span class="kt">char</span> <span class="n">yes</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="k">typedef</span> <span class="n">yes</span> <span class="n">no</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

    <span class="c1">// This helper struct permits us to check that serialize is truly a method.</span>
    <span class="c1">// The second argument must be of the type of the first.</span>
    <span class="c1">// For instance reallyHas&lt;int, 10&gt; would be substituted by reallyHas&lt;int, int 10&gt; and works!</span>
    <span class="c1">// reallyHas&lt;int, &amp;C::serialize&gt; would be substituted by reallyHas&lt;int, int &amp;C::serialize&gt; and fail!</span>
    <span class="c1">// Note: It only works with integral constants and pointers (so function pointers work).</span>
    <span class="c1">// In our case we check that &amp;C::serialize has the same signature as the first argument!</span>
    <span class="c1">// reallyHas&lt;std::string (C::*)(), &amp;C::serialize&gt; should be substituted by </span>
    <span class="c1">// reallyHas&lt;std::string (C::*)(), std::string (C::*)() &amp;C::serialize&gt; and work!</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">U</span><span class="p">,</span> <span class="n">U</span> <span class="n">u</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">reallyHas</span><span class="p">;</span>

    <span class="c1">// Two overloads for yes: one for the signature of a normal method, one is for the signature of a const method.</span>
    <span class="c1">// We accept a pointer to our helper struct, in order to avoid to instantiate a real instance of this type.</span>
    <span class="c1">// std::string (C::*)() is function pointer declaration.</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">C</span><span class="o">&gt;</span> <span class="k">static</span> <span class="n">yes</span><span class="o">&amp;</span> <span class="n">test</span><span class="p">(</span><span class="n">reallyHas</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="p">(</span><span class="n">C</span><span class="o">::*</span><span class="p">)(),</span> <span class="o">&amp;</span><span class="n">C</span><span class="o">::</span><span class="n">serialize</span><span class="o">&gt;*</span> <span class="cm">/*unused*/</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">C</span><span class="o">&gt;</span> <span class="k">static</span> <span class="n">yes</span><span class="o">&amp;</span> <span class="n">test</span><span class="p">(</span><span class="n">reallyHas</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="p">(</span><span class="n">C</span><span class="o">::*</span><span class="p">)()</span> <span class="k">const</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">C</span><span class="o">::</span><span class="n">serialize</span><span class="o">&gt;*</span> <span class="cm">/*unused*/</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

    <span class="c1">// The famous C++ sink-hole.</span>
    <span class="c1">// Note that sink-hole must be templated too as we are testing test&lt;T&gt;(0).</span>
    <span class="c1">// If the method serialize isn&#39;t available, we will end up in this method.</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">static</span> <span class="n">no</span><span class="o">&amp;</span> <span class="n">test</span><span class="p">(...)</span> <span class="p">{</span> <span class="cm">/* dark matter */</span> <span class="p">}</span>

    <span class="c1">// The constant used as a return value for the test.</span>
    <span class="c1">// The test is actually done here, thanks to the sizeof compile-time evaluation.</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">value</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">test</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">yes</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">// Using the struct A, B, C defined in the previous hasSerialize example.</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">hasSerialize</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">hasSerialize</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">hasSerialize</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>


<p>The <strong>reallyHas</strong> struct is kinda tricky but necessary to ensure that serialize is a method and not a simple member of the type. You can do a lot of test on a type using variants of this solution (test a member, a sub-type...) and I suggest you to google a bit more about <strong>SFINAE</strong> tricks. Note: if you truly want a pure compile-time constant and avoid some errors on old compilers, you can replace the last <strong>value</strong> evaluation by: "<strong>enum { value = sizeof(test<T>(0)) == sizeof(yes) };</strong>". </p>
<p>You might also wonder why it doesn't work with <strong>inheritence</strong>. <strong>Inheritence</strong> in C++ and <strong>dynamic polymorphism</strong> is a concept available at runtime, or in other words, a data that the compiler won't have and can't guess! However, compile time type inspection is much more efficient (0 impact at runtime) and almost as powerful as if it were at runtime.
For instance:</p>
<div class="highlight"><pre><span class="c1">// Using the previous A struct and hasSerialize helper.</span>

<span class="k">struct</span> <span class="nl">D</span> <span class="p">:</span> <span class="n">A</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">serialize</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="s">&quot;I am a D!&quot;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="kt">bool</span> <span class="n">testHasSerialize</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="cm">/*t*/</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">hasSerialize</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span> <span class="p">}</span>

<span class="n">D</span> <span class="n">d</span><span class="p">;</span>
<span class="n">A</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span> <span class="c1">// Here we lost the type of d at compile time.</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">testHasSerialize</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// Output 1.</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">testHasSerialize</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// Output 0.</span>
</pre></div>


<p>Last but no least, our test cover the main cases but not the tricky ones like a Functor: </p>
<div class="highlight"><pre><span class="k">struct</span> <span class="n">E</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">Functor</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">operator</span><span class="p">()()</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="s">&quot;I am a E!&quot;</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="n">Functor</span> <span class="n">serialize</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">E</span> <span class="n">e</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">serialize</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// Succefully call the functor.</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">testHasSerialize</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// Output 0.</span>
</pre></div>


<p>The trade-off for a full coverage would be the readability. As you will see, C++11 shines in that domain!</p>
<h4>Time to use our genius idea:</h4>
<p>Now you would think that it will be super easy to use our <strong>hasSerialize</strong> to create a <strong>serialize</strong> function! Okay let's try it:</p>
<div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">serialize</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hasSerialize</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">obj</span><span class="p">.</span><span class="n">serialize</span><span class="p">();</span> <span class="c1">// error: no member named &#39;serialize&#39; in &#39;A&#39;.</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">to_string</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">A</span> <span class="n">a</span><span class="p">;</span>
<span class="n">serialize</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
</pre></div>


<p>It might be hard to accept, but the error raised by your compiler is absolutely normal! If you consider the code that you will obtain after substitution and compile-time evaluation:</p>
<div class="highlight"><pre><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">serialize</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Dead branching, but the compiler will still consider it!</span>
        <span class="k">return</span> <span class="n">obj</span><span class="p">.</span><span class="n">serialize</span><span class="p">();</span> <span class="c1">// error: no member named &#39;serialize&#39; in &#39;A&#39;.</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">to_string</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>Your compiler is really a good guy and won't drop any dead-branch, and <strong>obj</strong> must therefore have both a <strong>serialize method</strong> and a <strong>to_string overload</strong> in this case. The solution consists in spliting the serialize function into two different functions: one where we solely use <strong>obj.serialize()</strong> and one where we use <strong>to_string</strong> according to <strong>obj's type</strong>. We come back to an earlier problem that we already solved, how to split according to a type? <strong>SFINAE</strong>, for sure! At that point we could re-work our <strong>hasSerialize</strong> function into a <strong>serialize</strong> function and make it return a <strong>std::string</strong> instead of compile time <strong>boolean</strong>. But we won't do it that way! It's cleaner to separate the <strong>hasSerialize</strong> test from its usage <strong>serialize</strong>.</p>
<p>We need to find a clever <strong>SFINAE</strong> solution on the signature of "<strong>template &lt;class T> std::string serialize(const T&amp; obj)</strong>". I bring you the last piece of the puzzle called <strong>enable_if</strong>.</p>
<div class="highlight"><pre><span class="k">template</span><span class="o">&lt;</span><span class="kt">bool</span> <span class="n">B</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span> <span class="o">=</span> <span class="kt">void</span><span class="o">&gt;</span> <span class="c1">// Default template version.</span>
<span class="k">struct</span> <span class="n">enable_if</span> <span class="p">{};</span> <span class="c1">// This struct doesn&#39;t define &quot;type&quot; and the substitution will fail if you try to access it.</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="c1">// A specialisation used if the expression is true. </span>
<span class="k">struct</span> <span class="n">enable_if</span><span class="o">&lt;</span><span class="nb">true</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span> <span class="k">typedef</span> <span class="n">T</span> <span class="n">type</span><span class="p">;</span> <span class="p">};</span> <span class="c1">// This struct do have a &quot;type&quot; and won&#39;t fail on access.</span>

<span class="c1">// Usage:</span>
<span class="n">enable_if</span><span class="o">&lt;</span><span class="nb">true</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">t1</span><span class="p">;</span> <span class="c1">// Compiler happy. t&#39;s type is int.</span>
<span class="n">enable_if</span><span class="o">&lt;</span><span class="n">hasSerialize</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">t2</span><span class="p">;</span> <span class="c1">// Compiler happy. t&#39;s type is int.</span>

<span class="n">enable_if</span><span class="o">&lt;</span><span class="nb">false</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">t3</span><span class="p">;</span> <span class="c1">// Compiler unhappy. no type named &#39;type&#39; in &#39;enable_if&lt;false, int&gt;&#39;;</span>
<span class="n">enable_if</span><span class="o">&lt;</span><span class="n">hasSerialize</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">t4</span><span class="p">;</span> <span class="c1">// no type named &#39;type&#39; in &#39;enable_if&lt;false, int&gt;&#39;;</span>
</pre></div>


<p>As you can see, we can trigger a substitution failure according to a compile time expression with <strong>enable_if</strong>. Now we can use this failure on the "<strong>template &lt;class T> std::string serialize(const T&amp; obj)</strong>" signature to dispatch to the right version. Finally, we have the true solution of our problem:</p>
<div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">typename</span> <span class="n">enable_if</span><span class="o">&lt;</span><span class="n">hasSerialize</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">serialize</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">obj</span><span class="p">.</span><span class="n">serialize</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">typename</span> <span class="n">enable_if</span><span class="o">&lt;!</span><span class="n">hasSerialize</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">serialize</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">to_string</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">A</span> <span class="n">a</span><span class="p">;</span>
<span class="n">B</span> <span class="n">b</span><span class="p">;</span>
<span class="n">C</span> <span class="n">c</span><span class="p">;</span>

<span class="c1">// The following lines work like a charm!</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">serialize</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">serialize</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">serialize</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>


<p>Two details worth being noted! Firstly we use <strong>enable_if</strong> on the return type, in order to keep the paramater deduction, otherwise we would have to specify the type explicitely "<strong>serialize&lt;A>(a)</strong>". Second, even the version using <strong>to_string</strong> must use the <strong>enable_if</strong>, otherwise <strong>serialize(b)</strong> would have two potential overloads available and raise an ambiguity. If you want to check the full code of this C++98 version, here is a <a href="https://gist.github.com/Jiwan/2573fc47e4fa5025306b">gist</a>.
Life is much easier in C++11, so let's see the beauty of this new standard!</p>
<p>Note: it's also important to know that this code creates a <strong>SFINAE</strong> on an expression ("<strong>&amp;C::serialize</strong>"). Whilst this feature wasn't required by the <strong>C++98</strong> standard, it was already in use depending on your compiler. It trully became a safe choice in <strong>C++11</strong>.</p>
<h3>When C++11 came to our help:</h3>
<p>After the great century leap year in 2000, people were fairly optimistic about the coming years. Some even decided to design a new standard for the next generation of <strong>C++</strong> coders like me! Not only this standard would ease <strong>TMP</strong> headaches (<strong>T</strong>emplate <strong>M</strong>eta <strong>P</strong>rogramming side-effects), but it would be available in the first decade, hence its code-name <strong>C++0x</strong>. Well, the standard sadly came the next decade (2011 ==&gt; <strong>C++11</strong>), but it brought a lot of features interesting for the purpose of this article. Let's review them!</p>
<h4>decltype, declval, auto &amp; co:</h4>
<p>Do you remember that the <strong>sizeof operator</strong> does a "fake evaluation" of the expression that you pass to it, and return gives you the size of the type of the expression? Well <strong>C++11</strong> adds a new operator called <strong>decltype</strong>. <a href="http://en.cppreference.com/w/cpp/language/decltype">decltype</a> gives you the type of the of the expression it will evaluate. As I am kind, I won't let you google an example and give it to you directly:</p>
<div class="highlight"><pre><span class="n">B</span> <span class="n">b</span><span class="p">;</span>
<span class="k">decltype</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">serialize</span><span class="p">())</span> <span class="n">test</span> <span class="o">=</span> <span class="s">&quot;test&quot;</span><span class="p">;</span> <span class="c1">// Evaluate b.serialize(), which is typed as std::string.</span>
<span class="c1">// Equivalent to std::string test = &quot;test&quot;;</span>
</pre></div>


<p><a href="http://en.cppreference.com/w/cpp/utility/declval">declval</a> is an utility that gives you a "fake reference" to an object of a type that couldn't be easily construct. <strong>declval</strong> is really handy for our <strong>SFINAE</strong> constructions. <strong>cppreference</strong> example is really straightforward, so here is a copy:</p>
<div class="highlight"><pre><span class="k">struct</span> <span class="n">Default</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">foo</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="mi">1</span><span class="p">;}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">NonDefault</span> <span class="p">{</span>
    <span class="n">NonDefault</span><span class="p">(</span><span class="k">const</span> <span class="n">NonDefault</span><span class="o">&amp;</span><span class="p">)</span> <span class="p">{}</span>
    <span class="kt">int</span> <span class="n">foo</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="mi">1</span><span class="p">;}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">decltype</span><span class="p">(</span><span class="n">Default</span><span class="p">().</span><span class="n">foo</span><span class="p">())</span> <span class="n">n1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// int n1</span>
<span class="c1">//  decltype(NonDefault().foo()) n2 = n1; // error: no default constructor</span>
    <span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">NonDefault</span><span class="o">&gt;</span><span class="p">().</span><span class="n">foo</span><span class="p">())</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">n1</span><span class="p">;</span> <span class="c1">// int n2</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;n2 = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">n2</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>The <strong>auto specifier</strong> <em>specifies that the type of the variable that is being declared will be automatically deduced</em>. <a href="http://en.cppreference.com/w/cpp/language/auto">auto</a> is equivalent of <strong>var</strong> in C#. <strong>auto</strong> in <strong>C++11</strong> has also a less famous but nonetheless usage for function declaration. Here is a good example:</p>
<div class="highlight"><pre><span class="kt">bool</span> <span class="nf">f</span><span class="p">();</span>
<span class="k">auto</span> <span class="n">test</span> <span class="o">=</span> <span class="n">f</span><span class="p">();</span> <span class="c1">// Famous usage, auto deduced that test is a boolean, hurray!</span>



<span class="c1">//                             vvv t wasn&#39;t declare at that point, it will be after as a parameter!</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">serialize</span><span class="p">())</span> <span class="n">g</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>   <span class="p">}</span> <span class="c1">// Compilation error</span>

<span class="c1">// Less famous usage:</span>
<span class="c1">//                    vvv auto delayed the return type specification!</span>
<span class="c1">//                    vvv                vvv the return type is specified here and use t!</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">auto</span> <span class="n">g</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">serialize</span><span class="p">())</span> <span class="p">{</span>   <span class="p">}</span> <span class="c1">// No compilation error.</span>
</pre></div>


<p>As you can see, <strong>auto</strong> permits to use the trailing return type syntax and use <strong>decltype</strong> coupled with an expression involving one of the function argument. Does it means that we can use it to test the existence of <strong>serialize</strong> with a SFINAE? Yes Dr. Watson! <strong>decltype</strong> will shine really soon, you will have to wait for the <strong>C++14</strong> for this tricky <strong>auto</strong> usage (but since it's a C++11 feature, it ends up here).</p>
<h4>constexpr:</h4>
<p>C++11 also came with a new way to do compile-time computations! The new keyword <strong>constexpr</strong> is a hint for your compiler, meaning that this expression is constant and could be evaluate directly at compile time. In C++11, <a href="http://en.cppreference.com/w/cpp/language/constexpr">constexpr</a> has a lot of rules and only a small subset of VIEs (Very Important Expression) expressions can be used (no loops...)! We still have enough for creating a compile-time factorial function:</p>
<div class="highlight"><pre><span class="k">constexpr</span> <span class="kt">int</span> <span class="nf">factorial</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">factorial</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">// Call to a constexpr function.</span>
<span class="c1">// Will be replace by a good compiler by:</span>
<span class="c1">// int i = 120;</span>
</pre></div>


<p><strong>constexpr</strong> increased the usage of <strong>std::true_type</strong> &amp; <strong>std::false_type</strong> from the STL. As their name suggest, these types encapsulate a constexpr boolean "true" and a constrexpr boolean "false". Their most important property is that a class or a struct can inherit from them. For instance:</p>
<div class="highlight"><pre><span class="k">struct</span> <span class="nl">testStruct</span> <span class="p">:</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span> <span class="p">{</span> <span class="p">};</span> <span class="c1">// Inherit from the true type.</span>

<span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">testVar</span> <span class="o">=</span> <span class="n">testStruct</span><span class="p">();</span> <span class="c1">// Generate a compile-time testStruct.</span>
<span class="kt">bool</span> <span class="n">test</span> <span class="o">=</span> <span class="n">testStruct</span><span class="o">::</span><span class="n">value</span><span class="p">;</span> <span class="c1">// Equivalent to: test = true;</span>
<span class="n">test</span> <span class="o">=</span> <span class="n">testVar</span><span class="p">;</span> <span class="c1">// true_type has a constexpr converter operator, equivalent to: test = true;</span>
</pre></div>


<h4>Blending time:</h4>
<h5>First solution:</h5>
<p>In cooking, a good recipe requires to mix all the best ingredients in the right proportions. If you don't want to have a spaghetti code dating from 1998 for dinner, let's revisit our C++98 <strong>hasSerialize</strong> and <strong>serialize</strong> functions with "fresh" ingredients from 2011. Let's start by removing the rotting <strong>reallyHas</strong> trick with a tasty <strong>decltype</strong> and bake a bit of <strong>constexpr</strong> instead of <strong>sizeof</strong>. After 15min in the oven (or fighting with a new headache), you will obtain:</p>
<div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">hasSerialize</span>
<span class="p">{</span>
    <span class="c1">// We test if the type has serialize using decltype and declval.</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">C</span><span class="o">&gt;</span> <span class="k">static</span> <span class="k">constexpr</span> <span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="p">().</span><span class="n">serialize</span><span class="p">(),</span> <span class="kt">bool</span><span class="p">())</span> <span class="n">test</span><span class="p">(</span><span class="kt">int</span> <span class="cm">/* unused */</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// We can return values, thanks to constexpr instead of playing with sizeof.</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">C</span><span class="o">&gt;</span> <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">test</span><span class="p">(...)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// int is used to give the precedence!</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">value</span> <span class="o">=</span> <span class="n">test</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">int</span><span class="p">());</span>
<span class="p">};</span>
</pre></div>


<p>You might be a bit puzzled by my usage of <strong>decltype</strong>. The C++ comma operator "<strong>,</strong>" can create a chain of multiple expressions. In <strong>decltype</strong>, all the expressions will be evaluated, but only the last expression will be considered for the type. The <strong>serialize</strong> doesn't need any changes, minus the fact that the <strong>enable_if</strong> function is now provided in the <strong>STL</strong>. For your tests, here is a <a href="https://gist.github.com/Jiwan/21f65ddbd91e7ce93384">gist</a>.</p>
<h5>Second solution:</h5>
<p>Another C++11 solution described in <strong>Boost.Hanna</strong> documentation and using <strong>std::true_type</strong> and <strong>std::false_type</strong>, would be this one:</p>
<div class="highlight"><pre><span class="c1">// Primary template, inherit from std::false_type.</span>
<span class="c1">// ::value will return false. </span>
<span class="c1">// Note: the second unused template parameter is set to default as std::string!!!</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nl">hasSerialize</span>
        <span class="p">:</span> <span class="n">std</span><span class="o">::</span><span class="n">false_type</span>
<span class="p">{</span>

<span class="p">};</span>

<span class="c1">// Partial template specialisation, inherit from std::true_type.</span>
<span class="c1">// ::value will return true. </span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">hasSerialize</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">().</span><span class="n">serialize</span><span class="p">())</span><span class="o">&gt;</span>
        <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span>
<span class="p">{</span>

<span class="p">};</span>
</pre></div>


<p>This solution is, in my own opinion, more sneaky! It relies on a not-so-famous-property of default template parameters. But if your soul is already (stack-)corrupted, you may be aware that the <strong>default parameters</strong> are propagated in the <strong>specialisations</strong>. So when we use <strong>hasSerialize&lt;OurType>::value</strong>, the default parameter comes into play and we are actually looking for <strong>hasSerialize&lt;OurType, std::string>::value</strong> both on the <strong>primary template</strong> and the <strong>specialisation</strong>. In the meantime, the <strong>substitution</strong> and the evaluation of <strong>decltype</strong> are processed and our <strong>specialisation</strong> has the signature <strong>hasSerialize&lt;OurType, std::string></strong> if <strong>OurType</strong> has a <strong>serialize</strong> method that returns a <strong>std::string</strong>, otherwise the substitution fails. The <strong>specialisation</strong> has therefore the precedence in the good cases. One will be able to use the <a href="http://en.cppreference.com/w/cpp/types/void_t">std::void_t</a> C++17 helper in these cases. Anyway, here is a <a href="https://gist.github.com/Jiwan/160a64a5d1d25e4bdf6b">gist</a> you can play with!</p>
<p>I told you that this second solution hides a lot of complexity, and we still have a lot of C++11 features unexploited like <strong>nullptr</strong>, <strong>lambda</strong>, <strong>r-values</strong>. No worries, we are going to use some of them in <strong>C++14</strong>!</p>
<h3>The supremacy of C++14:</h3>
<p>According to the Gregorian calendar in the upper-right corner of my XFCE environment, we are in 2015! I can turn on the <strong>C++14</strong> compilation flag on my favorite compiler safely, isn't it? Well, I can with <strong>clang</strong> (is <strong>MSVC</strong> using a maya calendar?).
Once again, let's explore the new features, and use them to build something wonderful! We will even recreate an <strong>is_valid</strong>, like I promised at the beggining of this article.</p>
<h4>auto &amp; lambdas:</h4>
<h6>Return type inference:</h6>
<p>Some cool features in <strong>C++14</strong> come from the relaxed usage of the <strong>auto</strong> keyword (the one used for type inference).</p>
<p>Now, <strong>auto</strong> can be used on the return type of a function or a method. For instance:</p>
<div class="highlight"><pre><span class="k">auto</span> <span class="nf">myFunction</span><span class="p">()</span> <span class="c1">// Automagically figures out that myFunction returns ints.</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="kt">int</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>


<p>It works as long as the type is easily "guessable" by the compiler. We are coding in C++ after all, not OCaml! </p>
<h6>A feature for functional lovers:</h6>
<p><strong>C++11</strong> introduced <a href="http://en.cppreference.com/w/cpp/language/lambda">lambdas</a>. A lambda has the following syntax: </p>
<div class="highlight"><pre>[capture-list](params) -&gt; non-mandatory-return-type { ...body... }
</pre></div>


<p>A useful example in our case would be:</p>
<div class="highlight"><pre><span class="k">auto</span> <span class="n">l1</span> <span class="o">=</span> <span class="p">[](</span><span class="n">B</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">b</span><span class="p">.</span><span class="n">serialize</span><span class="p">();</span> <span class="p">};</span> <span class="c1">// Return type figured-out by the return statement.</span>
<span class="k">auto</span> <span class="n">l3</span> <span class="o">=</span> <span class="p">[](</span><span class="n">B</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="p">{</span> <span class="k">return</span> <span class="n">b</span><span class="p">.</span><span class="n">serialize</span><span class="p">();</span> <span class="p">};</span> <span class="c1">// Fixed return type.</span>
<span class="k">auto</span> <span class="n">l2</span> <span class="o">=</span> <span class="p">[](</span><span class="n">B</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">serialize</span><span class="p">())</span> <span class="p">{</span> <span class="k">return</span> <span class="n">b</span><span class="p">.</span><span class="n">serialize</span><span class="p">();</span> <span class="p">};</span> <span class="c1">// Return type dependant to the B type.</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">l1</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// Output: I am a B!</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">l2</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// Output: I am a B!</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">l3</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// Output: I am a B!</span>
</pre></div>


<p><strong>C++14</strong> brings a small change to the <strong>lambdas</strong> but with a big impact! <strong>Lambdas</strong> accept <strong>auto parameters</strong>: the parameter type is deduced according the argument. <strong>Lambdas</strong> are implemented as an object having an newly created <strong>unnamed type</strong>, also called <strong>closure type</strong>. If a <strong>lambda</strong> has some <strong>auto parameters</strong>, its "Functor operator" <strong>operator()</strong> will be simply templated. Let's take a look:</p>
<div class="highlight"><pre><span class="c1">// ***** Simple lambda unamed type *****</span>
<span class="k">auto</span> <span class="n">l4</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">l4</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// Output 9.</span>

<span class="c1">// Equivalent to:</span>
<span class="k">struct</span> <span class="n">l4UnamedType</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="n">l4UnamedType</span> <span class="n">l4Equivalent</span> <span class="o">=</span> <span class="n">l4UnamedType</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">l4Equivalent</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// Output 9 too.</span>



<span class="c1">// ***** auto parameters lambda unnamed type *****</span>

<span class="c1">// b&#39;s type is automagically deduced!</span>
<span class="k">auto</span> <span class="n">l5</span> <span class="o">=</span> <span class="p">[](</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">serialize</span><span class="p">())</span> <span class="p">{</span> <span class="k">return</span> <span class="n">t</span><span class="p">.</span><span class="n">serialize</span><span class="p">();</span> <span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">l5</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// Output: I am a B!</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">l5</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// Error: no member named &#39;serialize&#39; in &#39;A&#39;.</span>

<span class="c1">// Equivalent to:</span>
<span class="k">struct</span> <span class="n">l5UnamedType</span>
<span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">serialize</span><span class="p">())</span> <span class="c1">// /!\ This signature is nice for a SFINAE!</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">t</span><span class="p">.</span><span class="n">serialize</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="n">l5UnamedType</span> <span class="n">l5Equivalent</span> <span class="o">=</span> <span class="n">l5UnamedType</span><span class="p">();</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">l5Equivalent</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// Output: I am a B!</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">l5Equivalent</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// Error: no member named &#39;serialize&#39; in &#39;A&#39;.</span>
</pre></div>


<p>More than the <strong>lambda</strong> itself, we are interested by the generated <strong>unnamed type</strong>: its lambda <strong>operator()</strong> can be used as a SFINAE! And as you can see, writing a <strong>lambda</strong> is less cumbersome than writing the equivalent type. It should remind you the beggining of my initial solution:</p>
<div class="highlight"><pre><span class="c1">// Check if a type has a serialize method.</span>
<span class="k">auto</span> <span class="n">hasSerialize</span> <span class="o">=</span> <span class="n">hana</span><span class="o">::</span><span class="n">is_valid</span><span class="p">([](</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">serialize</span><span class="p">())</span> <span class="p">{</span> <span class="p">});</span>
</pre></div>


<p>And the good new is that we have everything to recreate <strong>is_valid</strong>, right now!</p>
<h4>The making-of a valid <strong>is_valid</strong>:</h4>
<p>Now that we have a really stylish manner to generate a <strong>unnamed types</strong> with potential <strong>SFINAE</strong> properties using <strong>lambdas</strong>, we need to figure out how to use them! As you can see, <strong>hana::is_valid</strong> is a function that takes our lambda as a parameter and return a type. We will call the type returned by <strong>is_valid</strong> the <strong>container</strong>. The <strong>container</strong> will be in charge to keep the lambda's <strong>unnamed type</strong> for a later usage. Let's start by writing the <strong>is_valid</strong> function and its the <strong>containter</strong>:</p>
<div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">UnnamedType</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">container</span>
<span class="p">{</span>
    <span class="c1">// Remembers UnnamedType.</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">UnnamedType</span><span class="o">&gt;</span> <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">is_valid</span><span class="p">(</span><span class="k">const</span> <span class="n">UnnamedType</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="c1">// We used auto for the return type: it will be deduced here.</span>
    <span class="k">return</span> <span class="n">container</span><span class="o">&lt;</span><span class="n">UnnamedType</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">auto</span> <span class="n">test</span> <span class="o">=</span> <span class="n">is_valid</span><span class="p">([](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">serialize</span><span class="p">())</span> <span class="p">{})</span>
<span class="c1">// Now &#39;test&#39; remembers the type of the lambda and the signature of its operator()!</span>
</pre></div>


<p>The next step consists at extending <strong>container</strong> with the operator <strong>operator()</strong> such as we can call it with an argument. This argument type will be tested against the <strong>UnnamedType</strong>! In order to do a test on the argument type, we can use once again a SFINAE on a reacreated 'UnnamedType' object! It gives us this solution:</p>
<div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">UnnamedType</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">container</span>
<span class="p">{</span>
<span class="c1">// Let&#39;s put the test in private.</span>
<span class="k">private</span><span class="o">:</span>
    <span class="c1">// We use std::declval to &#39;recreate&#39; an object of &#39;UnnamedType&#39;.</span>
    <span class="c1">// We use std::declval to also &#39;recreate&#39; an object of type &#39;Param&#39;.</span>
    <span class="c1">// We can use both of these recreated objects to test the validity!</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Param</span><span class="o">&gt;</span> <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">testValidity</span><span class="p">(</span><span class="kt">int</span> <span class="cm">/* unused */</span><span class="p">)</span>
    <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">UnnamedType</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Param</span><span class="o">&gt;</span><span class="p">()),</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="c1">// If substitution didn&#39;t fail, we can return a true_type.</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Param</span><span class="o">&gt;</span> <span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="n">false_type</span> <span class="n">testValidity</span><span class="p">(...)</span>
    <span class="p">{</span>
        <span class="c1">// Our sink-hole returns a false_type.</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">false_type</span><span class="p">();</span>
    <span class="p">}</span>

<span class="k">public</span><span class="o">:</span>
    <span class="c1">// A public operator() that accept the argument we wish to test onto the UnnamedType.</span>
    <span class="c1">// Notice that the return type is automatic!</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Param</span><span class="o">&gt;</span> <span class="k">constexpr</span> <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Param</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// The argument is forwarded to one of the two overloads.</span>
        <span class="c1">// The SFINAE on the &#39;true_type&#39; will come into play to dispatch.</span>
        <span class="c1">// Once again, we use the int for the precedence.</span>
        <span class="k">return</span> <span class="n">testValidity</span><span class="o">&lt;</span><span class="n">Param</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">int</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">UnnamedType</span><span class="o">&gt;</span> <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">is_valid</span><span class="p">(</span><span class="k">const</span> <span class="n">UnnamedType</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="c1">// We used auto for the return type: it will be deduced here.</span>
    <span class="k">return</span> <span class="n">container</span><span class="o">&lt;</span><span class="n">UnnamedType</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Check if a type has a serialize method.</span>
<span class="k">auto</span> <span class="n">hasSerialize</span> <span class="o">=</span> <span class="n">is_valid</span><span class="p">([](</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">serialize</span><span class="p">())</span> <span class="p">{</span> <span class="p">});</span>
</pre></div>


<p>If you are a bit lost at that point, I suggest you take your time and re-read all the previous example. You have all the weapons you need, now fight <strong>C++</strong>!</p>
<p>Our <strong>hasSerialize</strong> now takes an argument, we therefore need some changes for our serialize function. We can simply post-pone the return type using <strong>auto</strong> and use the argument in a <strong>decltype</strong> as we learn. Which gives us:</p>
<div class="highlight"><pre><span class="c1">// Notice how I simply swapped the return type on the right?</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">auto</span> <span class="n">serialize</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">)</span> 
<span class="o">-&gt;</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">hasSerialize</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span><span class="o">::</span><span class="n">value</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">type</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">obj</span><span class="p">.</span><span class="n">serialize</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">auto</span> <span class="n">serialize</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">)</span> 
<span class="o">-&gt;</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;!</span><span class="k">decltype</span><span class="p">(</span><span class="n">hasSerialize</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span><span class="o">::</span><span class="n">value</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">type</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">to_string</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p><strong>FINALLY!!!</strong> We do have a working <strong>is_valid</strong> and we could use it for serialization! If I were as vicious as my SFINAE tricks, I would let you copy each code pieces to recreate a fully working solution. But today, Halloween's spirit is with me and here is <a href="https://gist.github.com/Jiwan/7a586c739a30dd90d259">gist</a>. Hey, hey! Don't close this article so fast! If you are true a warrior, you can read the last part!</p>
<h4>For the fun:</h4>
<p>There are few things I didn't tell you, on purpose. This article would otherwise be twice longer, I fear. I highly suggest you to google a bit more about what I am going to speak about.</p>
<ul>
<li>
<p>Firstly, if you wish to have a solution that works with the <strong>Boost.Hana</strong> static <strong>if_</strong>, you need to change the return type of our <strong>testValidity</strong> methods by Hana's equivalents, like the following:</p>
<div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Param</span><span class="o">&gt;</span> <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">test_validity</span><span class="p">(</span><span class="kt">int</span> <span class="cm">/* unused */</span><span class="p">)</span>
<span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">UnnamedType</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Param</span><span class="o">&gt;</span><span class="p">()),</span> <span class="n">boost</span><span class="o">::</span><span class="n">hana</span><span class="o">::</span><span class="n">true_c</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// If substitution didn&#39;t fail, we can return a true_type.</span>
    <span class="k">return</span> <span class="n">boost</span><span class="o">::</span><span class="n">hana</span><span class="o">::</span><span class="n">true_c</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Param</span><span class="o">&gt;</span> <span class="k">constexpr</span> <span class="k">decltype</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">hana</span><span class="o">::</span><span class="n">false_c</span><span class="p">)</span> <span class="n">test_validity</span><span class="p">(...)</span>
<span class="p">{</span>
    <span class="c1">// Our sink-hole returns a false_type.</span>
    <span class="k">return</span> <span class="n">boost</span><span class="o">::</span><span class="n">hana</span><span class="o">::</span><span class="n">false_c</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>The static <strong>if_</strong> implementation is really interesting, but at least as hard as our <strong>is_valid</strong> problem solved in this article. I might dedicate another article about it, one day!</p>
</li>
<li>
<p>Did you noticed that we only check one argument at a time? Couldn't we do something like:</p>
<div class="highlight"><pre><span class="k">auto</span> <span class="n">test</span> <span class="o">=</span> <span class="n">is_valid</span><span class="p">([](</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">serialize</span><span class="p">(),</span> <span class="n">b</span><span class="p">.</span><span class="n">serialize</span><span class="p">())</span> <span class="p">{</span> <span class="p">});</span>
<span class="n">A</span> <span class="n">a</span><span class="p">;</span>
<span class="n">B</span> <span class="n">b</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">test</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>


<p>Actually we can, using some <a href="http://en.cppreference.com/w/cpp/language/parameter_pack">parameter packs</a>. Here is the solution:</p>
<div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">UnnamedType</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">container</span>
<span class="p">{</span>
<span class="c1">// Let&#39;s put the test in private.</span>
<span class="k">private</span><span class="o">:</span>
    <span class="c1">// We use std::declval to &#39;recreate&#39; an object of &#39;UnnamedType&#39;.</span>
    <span class="c1">// We use std::declval to also &#39;recreate&#39; an object of type &#39;Param&#39;.</span>
    <span class="c1">// We can use both of these recreated objects to test the validity!</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Params</span><span class="o">&gt;</span> <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">test_validity</span><span class="p">(</span><span class="kt">int</span> <span class="cm">/* unused */</span><span class="p">)</span>
    <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">UnnamedType</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Params</span><span class="o">&gt;</span><span class="p">()...),</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="c1">// If substitution didn&#39;t fail, we can return a true_type.</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Params</span><span class="o">&gt;</span> <span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="n">false_type</span> <span class="n">test_validity</span><span class="p">(...)</span>
    <span class="p">{</span>
        <span class="c1">// Our sink-hole returns a false_type.</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">false_type</span><span class="p">();</span>
    <span class="p">}</span>

<span class="k">public</span><span class="o">:</span>
    <span class="c1">// A public operator() that accept the argument we wish to test onto the UnnamedType.</span>
    <span class="c1">// Notice that the return type is automatic!</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Params</span><span class="o">&gt;</span> <span class="k">constexpr</span> <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="n">Params</span><span class="o">&amp;&amp;</span> <span class="p">...)</span>
    <span class="p">{</span>
        <span class="c1">// The argument is forwarded to one of the two overloads.</span>
        <span class="c1">// The SFINAE on the &#39;true_type&#39; will come into play to dispatch.</span>
        <span class="k">return</span> <span class="n">test_validity</span><span class="o">&lt;</span><span class="n">Params</span><span class="p">...</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">int</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">UnnamedType</span><span class="o">&gt;</span> <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">is_valid</span><span class="p">(</span><span class="n">UnnamedType</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="c1">// We used auto for the return type: it will be deduced here.</span>
    <span class="k">return</span> <span class="n">container</span><span class="o">&lt;</span><span class="n">UnnamedType</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>


</li>
<li>
<p>This code is working even if my types are incomplete, for instance a forward declaration, or a normal declaration but with a missing definition. What can I do? Well, you can insert a check on the size of your type either in the <strong>SFINAE</strong> construction or before calling it: "<strong>static_assert( sizeof( T ), "type is incomplete." );</strong>".</p>
</li>
<li>
<p>Finally, why are using the notation "<strong>&amp;&amp;</strong>" for the <strong>lambdas</strong> parameters? Well, these are called <strong>forwarding references</strong>. It's a really complex topic, and if you are interested, here is good <a href="http://thbecker.net/articles/rvalue_references/section_01.html">article</a> about it. You need to use "<strong>auto&amp;&amp;</strong>" due to the way <strong>declval</strong> is working in our <strong>is_valid</strong> implementation!</p>
</li>
</ul>
<h4>Notes:</h4>
<p>This is my first serious article about <strong>C++</strong> on the web and I hope you enjoyed it! I would be glad if you have any suggestions or questions and that you wish to share with me in the commentaries.</p>
<p>Anyway, thanks to <a href="https://github.com/Naav">Naav</a> and <a href="https://github.com/superboum">Superboum</a> for rereading this article and theirs suggestions. Few suggestions were also provided by the reddit community or in the commentaries of this post, thanks a lot guys!</p>
  </div>
  <hr />
</article>
<article>
  <header>
    <h2><a href="//jguegant.github.io/blogs/tech/first-post.html#first-post">Why starting this blog?</a></h2>
    <p>
      Posted on Sat 17 October 2015 in <a href="//jguegant.github.io/blogs/tech/category/news.html">News</a>
      &#8226; Tagged with
      <a href="//jguegant.github.io/blogs/tech/tag/blog.html">blog</a>      &#8226; <a href="//jguegant.github.io/blogs/tech/first-post.html#disqus_thread">Leave a comment</a>
    </p>
  </header>
  <div>
      <p>Whilst I never had an urge to daily browse the various social networks, I have always liked to read technical articles and to follow few blogs. I wanted, since few years, to write my thoughts somewhere in order to clarify them and be able to easily fetch them later on. I procrastinated the idea of running a tech blog for few years, my aversion for the over-engineered web technologies and a lack of motivation restrained me. However, I have more spare time these days and I stumbled upon a simple and elegant Python static blog generator called <a href="http://blog.getpelican.com/">Pelican</a>. With <strong>Pelican</strong> I don't have to pull a thousand of npm packages for a sanatizing function neither to use the latest language for hipsters with an eccentric syntax. Static pages also greatly simplify the maintenance and decrease the security burdens of dynamic websites.</p>
<p>If this blog is mostly for my own purpose, I also hope that I could get an external opinion on my posts, my methods or even my skills in the beautiful English language.</p>
  </div>
</article>

  <div class="pagination">
  </div>

    <footer>
<p>
  &copy; Jean Guegant 2015 - This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>
</p>
<p>Built using <a href="http://getpelican.com" target="_blank">Pelican</a> - <a href="https://github.com/alexandrevicenzi/flex" target="_blank">Flex</a> theme by <a href="http://alexandrevicenzi.com" target="_blank">Alexandre Vicenzi</a></p><p>
  <a rel="license"
     href="http://creativecommons.org/licenses/by-sa/4.0/"
     target="_blank">
    <img alt="Creative Commons License"
         title="Creative Commons License"
         style="border-width:0"
         src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png"
         width="80"
         height="15"/>
  </a>
</p>    </footer>
  </main>
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-68827527-1', 'auto');
  ga('send', 'pageview');
</script>
<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Jean Guegant's Blog ",
  "url" : "//jguegant.github.io/blogs/tech",
  "image": "//jguegant.github.io/blogs/tech/images/myself.png",
  "description": ""
}
</script><script type="text/javascript">
    var disqus_shortname = 'jeanguegantswebsite';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
</body>
</html>
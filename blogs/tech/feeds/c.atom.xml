<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Jean Guegant's Blog - C++</title><link href="https://jguegant.github.io/blogs/tech/" rel="alternate"></link><link href="https://jguegant.github.io/blogs/tech/feeds/c.atom.xml" rel="self"></link><id>https://jguegant.github.io/blogs/tech/</id><updated>2020-04-13T17:40:00+02:00</updated><subtitle>Software Engineer - C++, security, game development and random thoughts.</subtitle><entry><title>Making a STL-compatible hash map from scratch - Part 2 - Growth Policies &amp; The Schrodinger std::pair</title><link href="https://jguegant.github.io/blogs/tech/dense-hash-map2.html" rel="alternate"></link><published>2020-04-13T17:40:00+02:00</published><updated>2020-04-13T17:40:00+02:00</updated><author><name>Jean Guegant</name></author><id>tag:jguegant.github.io,2020-04-13:/blogs/tech/dense-hash-map2.html</id><summary type="html">&lt;p&gt;This post is part of a series of posts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://jguegant.github.io/blogs/tech/dense-hash-map.html"&gt;Part 1 - Beating std::unordered_map&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Part 2 - Growth Policies &amp;amp; The Schrodinger std::pair (Current)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Part 3 - The wonderful world of iterators and allocators (Coming Soon)&lt;/li&gt;
&lt;li&gt;Part 4 - ... (Coming Soon)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the &lt;a href="https://jguegant.github.io/blogs/tech/dense-hash-map.html"&gt;previous post&lt;/a&gt;, we started a quest that consists in implementing …&lt;/p&gt;</summary><content type="html">&lt;p&gt;This post is part of a series of posts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://jguegant.github.io/blogs/tech/dense-hash-map.html"&gt;Part 1 - Beating std::unordered_map&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Part 2 - Growth Policies &amp;amp; The Schrodinger std::pair (Current)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Part 3 - The wonderful world of iterators and allocators (Coming Soon)&lt;/li&gt;
&lt;li&gt;Part 4 - ... (Coming Soon)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the &lt;a href="https://jguegant.github.io/blogs/tech/dense-hash-map.html"&gt;previous post&lt;/a&gt;, we started a quest that consists in implementing an associative container similar to &lt;code&gt;std::unordered_map&lt;/code&gt; in the C++ standard library. We saw two approaches that could help us in beating the performance of most &lt;code&gt;std::unordered_map&lt;/code&gt; implementations: freeing ourselves from stable-addressing and swapping the modulo operation with some bit-wise operations.
Due to its layout, we called this new associative container a &lt;code&gt;dense_hash_map&lt;/code&gt;. You can find a reference implementation &lt;a href="https://github.com/Jiwan/dense_hash_map"&gt;right here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Let's carry-on and start our own implementation right now!&lt;/p&gt;
&lt;h1&gt;Part 2 - Structuring our code &amp;amp; Dealing with value_type:&lt;/h1&gt;
&lt;h2&gt;Preparing for the adventure:&lt;/h2&gt;
&lt;p&gt;Disclaimer: this section starts very gently, if your C++ e-beard or e-hair is already pretty long, you may want to skip to the &lt;strong&gt;Structuring our code&lt;/strong&gt; section. &lt;/p&gt;
&lt;p&gt;Like any hero starting her/his journey, we need to ensure we have the right items in our inventory.&lt;/p&gt;
&lt;p&gt;For C++, here is my list of handy things to have when working on some standard-ish looking code:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://eel.is/c++draft/"&gt;eel.is C++ draft&lt;/a&gt;, the holly bible of C++ itself (the latest draft of the C++ standard).
eel.is's transformation of the standard latex source files to a clean HTML version is a godsent gift. You can navigate in each of the sections of the standard with ease. In our case, we will mainly refer ourselves to the sections &lt;a href="http://eel.is/c++draft/unord.map"&gt;unord.map&lt;/a&gt;, &lt;a href="http://eel.is/c++draft/associative.reqmts"&gt;associative.reqmts&lt;/a&gt; and &lt;a href="http://eel.is/c++draft/containers"&gt;container&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.cppreference.com"&gt;cppreference&lt;/a&gt;, the tuned-down version of the standard. This wiki is of great help when the lawyer language of the standard is too advanced for your taste (sometimes the standard feels downright insulting to your intellectual abilities). On some rare occasions, I have seen &lt;strong&gt;cppreference&lt;/strong&gt; have slightly inacurate descriptions of the standard. It always nice to cross-check the holly bible and this wiki. In our case, we will most refer to the &lt;a href="https://en.cppreference.com/w/cpp/container/unordered_map"&gt;unordered_map section&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://godbolt.org/"&gt;godbolt&lt;/a&gt; to experiment quickly your ideas on different compilers and check how the standard reacts for certain use-cases. With the recently added feature that permits you to run code, &lt;strong&gt;godbolt&lt;/strong&gt; is extremely handy. &lt;strong&gt;Goldbot's&lt;/strong&gt; grand cousin, &lt;a href="https://cppinsights.io/"&gt;cppinsights&lt;/a&gt; can help you to explore complicated expressions. &lt;/li&gt;
&lt;li&gt;&lt;a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines"&gt;The C++ core guidelines&lt;/a&gt;, a bunch of C++ precepts written or more or less by those behind the holly C++ standard. When given multiples way of doing one task, the core guidelines will direct you towards the better way to achieve that task.&lt;/li&gt;
&lt;li&gt;Some linter and formatting tools. I personally like &lt;a href="https://clang.llvm.org/extra/clang-tidy/"&gt;clang-tidy&lt;/a&gt; and &lt;a href="https://clang.llvm.org/docs/ClangFormat.html"&gt;clang-format&lt;/a&gt;. &lt;/li&gt;
&lt;li&gt;A good unit-test framework like &lt;a href="https://github.com/catchorg/Catch2"&gt;catch2&lt;/a&gt;. Writing such standard-like code without writing unit-tests is like running naked towards a level 100 creature and expecting to beat it with a simple bamboo stick. Good luck to you to achieve that!&lt;/li&gt;
&lt;li&gt;A bunch of warnings applied to your compiler. For the unix-like compilers (GCC or clang), a bare minimum would be  &lt;code&gt;-Wall -Wextra -pedantic -Werror&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;&lt;img width=50% height=50% src="https://jguegant.github.io/blogs/tech/images/the-holly-cpp-standard.jpg" alt="The Holly C++ Standard"/&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;And some optional items:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A recent compiler that supports a recent version of the language (C++17 in my case). Technically, nothing prevents you to write standard-library-like code with ancient C++, but each version of the standard made it a lot simpler. This is especially true for the meta-programming part.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://cmake.org/"&gt;cmake&lt;/a&gt;. Whether you find cmake's syntax an abomination or poetry, it is currently the de-facto standard build tool for any C++ projects.
Just for that sake of consistency in the C++ ecosystem, I would advise to support some sort of &lt;strong&gt;cmake&lt;/strong&gt; bindings for your project. &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Structuring our code:&lt;/h2&gt;
&lt;h3&gt;A header only Library:&lt;/h3&gt;
&lt;p&gt;Given that most of the classes, functions or even variables will have template parameters, there will be very little code that could end-up in its own compilation unit. So the &lt;code&gt;dense_hash_map&lt;/code&gt; will be header library. The file layout is fairly standard:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;├── CMakeLists.txt                                &lt;span class="c1"&gt;# Main CMakeLists.txt file that defines.&lt;/span&gt;
├── include
│   └── jg
│       ├── dense_hash_map.hpp                    &lt;span class="c1"&gt;# Main file to be included by users.&lt;/span&gt;
│       └── details                               &lt;span class="c1"&gt;# Folder that contains internal structures that users should not depend-on.&lt;/span&gt;
│           ├── bucket_iterator.hpp
│           ├── dense_hash_map_iterator.hpp
│           ├── node.hpp
│           ├── power_of_two_growth_policy.hpp
│           └── type_traits.hpp
├── tests                                         &lt;span class="c1"&gt;# Unit-tests folder.&lt;/span&gt;
│   ├── CMakeLists.txt
│   └── src
│       └── dense_hash_map_tests.cpp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Note: as any C++ egomaniac would do when facing the hard issue of choosing a namespace for his/her project, I went for my initial "jg".&lt;/p&gt;
&lt;h3&gt;Our main class in dense_hash_map.hpp:&lt;/h3&gt;
&lt;p&gt;To be able to organise our code correctly, let's have look at the "dense" layout we saw in the last &lt;a href="https://jguegant.github.io/blogs/tech/dense-hash-map.html"&gt;post&lt;/a&gt;: &lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img width=60% height=60% src="https://jguegant.github.io/blogs/tech/images/dense_hash_map_layout2.png" alt="The definitive layout"/&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;We will have &lt;strong&gt;two vectors&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;One for the &lt;strong&gt;buckets&lt;/strong&gt;. More precisely, these are the indices for the first node of the linked-list of each of our buckets.&lt;/li&gt;
&lt;li&gt;One for all the &lt;strong&gt;nodes&lt;/strong&gt;. These are the nodes in the interleaved linked-lists that hold the key/value pairs.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;While we are crafting our &lt;code&gt;dense_hash_map&lt;/code&gt; from scratch, it doesn't mean that we cannot reuse some of the other containers in the standard library.
Naturally, our &lt;strong&gt;two vectors&lt;/strong&gt; will be some good old &lt;code&gt;std::vector&lt;/code&gt;. Both of those will be members of our &lt;a href="https://github.com/Jiwan/dense_hash_map/blob/master/include/jg/dense_hash_map.hpp#L892"&gt;dense_hash_map class&lt;/a&gt;. If we inspire ourselves from &lt;a href="https://en.cppreference.com/w/cpp/container/unordered_map"&gt;std::unordered_map's signature&lt;/a&gt;, this gives us our first piece of code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;
    &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
    &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
    &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Hash&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Key&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
    &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Pred&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;equal_to&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Key&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Allocator&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;allocator&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;pair&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;GrowthPolicy&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;details&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;power_of_two_growth_policy&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;dense_hash_map&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="n"&gt;GrowthPolicy&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;// Define some aliases to avoid further typing later on.&lt;/span&gt;
    &lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;node_type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;details&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// A node type that contains our key/value.&lt;/span&gt;
    &lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;nodes_container_type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;node_type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;nodes_size_type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;nodes_container_type&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;size_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;buckets_container_type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;nodes_size_type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;// ...&lt;/span&gt;

&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;nodes_container_type&lt;/span&gt; &lt;span class="n"&gt;nodes_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;buckets_container_type&lt;/span&gt; &lt;span class="n"&gt;buckets_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The &lt;code&gt;buckets_container_type&lt;/code&gt; is dependent on the &lt;code&gt;size_type&lt;/code&gt; of the &lt;code&gt;nodes_container_type&lt;/code&gt;. In a &lt;code&gt;std::vector&lt;/code&gt;, &lt;code&gt;size_type&lt;/code&gt; is the type used for accessing elements using the subscript operator &lt;code&gt;operator[]&lt;/code&gt;. It makes sense, since &lt;strong&gt;buckets_&lt;/strong&gt; contains indices for &lt;strong&gt;nodes_&lt;/strong&gt;. Traditionnaly, and to the &lt;a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1428r0.pdf"&gt;dismay of plenty&lt;/a&gt;, &lt;code&gt;size_type&lt;/code&gt; is &lt;code&gt;std::size_t&lt;/code&gt; which is an unsigned integer. We will use the value of &lt;code&gt;std::numeric_limits&amp;lt;nodes_size_type&amp;gt;::max()&lt;/code&gt; to represent an invalid index into &lt;strong&gt;nodes_&lt;/strong&gt; or the end of our linked-lists:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kr"&gt;inline&lt;/span&gt; &lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="n"&gt;nodes_size_type&lt;/span&gt; &lt;span class="n"&gt;node_end_index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;numeric_limits&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;nodes_size_type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;For instance, &lt;strong&gt;buckets_&lt;/strong&gt; will be initialized, at the construction of an empty &lt;code&gt;dense_hash_map&lt;/code&gt;, with &lt;code&gt;node_end_index&lt;/code&gt; since all the buckets are empty.&lt;/p&gt;
&lt;p&gt;If you were attentive, you would notice that there was also an extra template parameter &lt;code&gt;GrowthPolicy&lt;/code&gt; to &lt;code&gt;dense_hash_map&lt;/code&gt;. Let's have a closer look at it!&lt;/p&gt;
&lt;h3&gt;Growth Policy:&lt;/h3&gt;
&lt;p&gt;In the last &lt;a href="https://jguegant.github.io/blogs/tech/dense-hash-map.html"&gt;post&lt;/a&gt;, we discovered some bit-wise operation tricks to increase the speed when mapping a &lt;strong&gt;key&lt;/strong&gt; to its &lt;strong&gt;bucket&lt;/strong&gt;.
We also saw that there were drawbacks in doing so. So instead of forcing this design choice on our &lt;code&gt;dense_hash_map&lt;/code&gt; users, we can make this behaviour a &lt;a href="https://en.wikipedia.org/wiki/Modern_C%2B%2B_Design#Policy-based_design"&gt;policy&lt;/a&gt;. The default policy will be the &lt;a href="https://github.com/Jiwan/dense_hash_map/blob/master/include/jg/details/power_of_two_growth_policy.hpp"&gt;power_of_two_growth_policy&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// power_of_two_growth_policy.hpp&lt;/span&gt;
&lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;jg&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;details&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;power_of_two_growth_policy&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Given a hash and the current capacity, use bit-wise trick to return the bucket index.&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;compute_index&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;hash&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;capacity&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// We saw that trick in the previous post.&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;// Given a desired new capacity for the bucket container, pick the closest power of two. &lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;compute_closest_capacity&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;min_capacity&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// We didn&amp;#39;t see that trick yet.&lt;/span&gt;

        &lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;highest_capacity&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;numeric_limits&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;digits&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;min_capacity&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;highest_capacity&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;false&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Maximum capacity for the dense_hash_map reached.&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;highest_capacity&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;min_capacity&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                  

        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;numeric_limits&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;digits&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;*=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;min_capacity&lt;/span&gt; &lt;span class="o"&gt;|=&lt;/span&gt; &lt;span class="n"&gt;min_capacity&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;min_capacity&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;// Returns the minimum capacity (~= initial capacity) the bucket container must have.&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;minimum_capacity&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;8u&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;All the growth policies will have to respect an implicit &lt;a href="https://en.cppreference.com/w/cpp/language/constraints"&gt;C++ concept&lt;/a&gt;: it must have the three static member functions &lt;code&gt;compute_index&lt;/code&gt;, &lt;code&gt;compute_closest_capacity&lt;/code&gt; and &lt;code&gt;minimum_capacity&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;These specific &lt;code&gt;compute_index&lt;/code&gt; and &lt;code&gt;minimum_capacity&lt;/code&gt; functions are self-explanatory. But &lt;code&gt;compute_closest_capacity&lt;/code&gt; is interesting: it tries to find the closest upper power of two given a random capacity.
A clever way that achieve that task is to fill your capacity number in its bit representation with &lt;code&gt;1&lt;/code&gt; starting from the right until you reach the highest bit already toggled on with &lt;code&gt;1&lt;/code&gt;. Afterwards, you can just increment and tada... you get your upper power of two.
Here is an example with the number 18 to clarify a bit (no pun intended):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;18 (decimal) == 0001 0010 (binary)
                   ^ Highest bit already toggle on.

After filling starting from the right:
0001 1111 (binary)

And if we add one:
0010 0000 (binary) == 32 (decimal)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;compute_closest_capacity&lt;/code&gt; is doing exactly that with the operator &lt;code&gt;|=&lt;/code&gt; and some bit-shifting with the operator &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;. It handles the case where we already have a power two by substracting one before processing the number. We also cap the minimum capacity to the highest power of two we can represent to avoid an overflow in the result.&lt;/p&gt;
&lt;p&gt;Note: you can also achieve a similar effect with some built-ins in your conpiler. For instance, GCC provides &lt;a href="https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html"&gt;__builtin_clz&lt;/a&gt; which can be of great help.&lt;/p&gt;
&lt;p&gt;Afterwards, we rely on the growth policy in our &lt;code&gt;dense_hash_map&lt;/code&gt; by "using" its functions:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;dense_hash_map&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="n"&gt;GrowthPolicy&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;GrowthPolicy&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;compute_closest_capacity&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// &amp;quot;Import&amp;quot; the policy&amp;#39;s functions in this scope.&lt;/span&gt;
    &lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;GrowthPolicy&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;compute_index&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;GrowthPolicy&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;minimum_capacity&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;// ...&lt;/span&gt;

    &lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;rehash&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size_type&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// ...&lt;/span&gt;
        &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;compute_closest_capacity&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="c1"&gt;// ...&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;So what's left of the first code snippet that we didn't dive into? The node type: &lt;code&gt;details::node&amp;lt;Key, T&amp;gt;&lt;/code&gt;. By now, you should have a vague feeling that there is something is fishy with this one, it has its own class in the detail namespace. But is that so complicated to make a node holding a key/value pair?&lt;/p&gt;
&lt;h2&gt;Dealing with a const value_type:&lt;/h2&gt;
&lt;p&gt;So here is the deal, &lt;code&gt;std::unordered_map&lt;/code&gt; has a peculiar &lt;code&gt;value_type&lt;/code&gt; (&lt;code&gt;value_type&lt;/code&gt; is the type you obtain as a reference when querying most containers in the standard library when using iterators) which is &lt;code&gt;std::pair&amp;lt;const Key, T&amp;gt;&lt;/code&gt;. Whenever you supply a template argument &lt;code&gt;Key&lt;/code&gt;, all the key/value pairs you obtain from &lt;code&gt;std::unordered_map&lt;/code&gt; will have their first member, which is the key, stored as &lt;code&gt;const Key&lt;/code&gt;. And, this, ladies and gentlemen, is can of giant worms ready to devore your last bits of sanity. So... let's open it!&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img width=40% height=40% src="https://jguegant.github.io/blogs/tech/images/dark-soul-open-door.jpg" alt="Opening the const value_type door"/&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;When you think a bit more about it, this design prevents you to put yourself in serious troubles. You cannot mutate the keys in your associative container once you have inserted them. Typically, without a &lt;code&gt;const Key&lt;/code&gt;, you would be able to do such crazy moves: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;jg&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;dense_hash_map&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;hero&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;my_map&lt;/span&gt;&lt;span class="p"&gt;{{&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;spongebob&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;hero&lt;/span&gt;&lt;span class="p"&gt;{}},&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;chuck norris&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;hero&lt;/span&gt;&lt;span class="p"&gt;{}}};&lt;/span&gt;
&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;it&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;my_map&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;find&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;chuck norris&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;it&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Chuck Norris&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// We are mutating the key to properly capitalise the venerable chuck.&lt;/span&gt;
&lt;span class="c1"&gt;// my_map after that would be in sad state.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;When mutating a key, your key will very likely have a new hash (unless you are the lucky winner of a collision...) which means that it probably belongs to a new bucket (unless both hashes belong to the same bucket...). Sadly, there is no way for your container to be aware that you mutated a &lt;code&gt;std::pair&amp;lt;const Key, T&amp;gt;&lt;/code&gt; it gave you as reference, which implies that the container cannot handle properly the hash change. Its internal data-structure would be in a broken state rather quickly. By having a &lt;code&gt;const Key&lt;/code&gt;, the standard shields itself from this issue: the key becomes immutable.&lt;/p&gt;
&lt;p&gt;Now, let's assume that our &lt;code&gt;details::node&amp;lt;Key, T&amp;gt;&lt;/code&gt; has a &lt;code&gt;std::pair&amp;lt;const Key, T&amp;gt;&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;pair&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;pair&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="c1"&gt;// Our glorious pair.&lt;/span&gt;
    &lt;span class="n"&gt;nodes_size_type&lt;/span&gt; &lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;node_end_index&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Next index of the node in the linked-list.&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;With our "dense" design, this becomes a &lt;strong&gt;performance issue&lt;/strong&gt;. Our &lt;code&gt;std::pair&amp;lt;const Key, T&amp;gt;&lt;/code&gt; will have its &lt;strong&gt;move-constructor&lt;/strong&gt; and &lt;strong&gt;move-assignment operator&lt;/strong&gt; disabled forever and ever, and so does the node type. All our nodes are stored in a packed vector &lt;code&gt;nodes_&lt;/code&gt;, which sometimes reallocate itself and send all its content into a bigger buffer. Not being to able to &lt;strong&gt;move&lt;/strong&gt; our objects accross memory is a huge bummer. We would have to copy them around. That's unacceptable! Even more irritating, &lt;strong&gt;std::unordered_map&lt;/strong&gt; does not suffer from this as its design allocates each nodes separately.&lt;/p&gt;
&lt;p&gt;Big problems require big &lt;strike&gt;solutions&lt;/strike&gt; hacks. Here are our two choices:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We make a &lt;code&gt;std::pair&lt;/code&gt; type on steroids that communicates back and forth with the container when the key change.
  This also requires our new type to be interoperable with &lt;code&gt;std::pair&lt;/code&gt;. It might be possible to partially fake a &lt;code&gt;std::pair&lt;/code&gt; with some implicit conversions, but we will never make our &lt;code&gt;dense_hash_map&lt;/code&gt; a drop-in replacement that way.&lt;/li&gt;
&lt;li&gt;We circumvent the type system with some &lt;a href="https://en.wikipedia.org/wiki/Type_punning"&gt;type punning&lt;/a&gt; and create a Schrodinger &lt;code&gt;std::pair&lt;/code&gt; that has both a &lt;code&gt;Key&lt;/code&gt; and a &lt;code&gt;const Key&lt;/code&gt; as its first member. In other words, we store internally a &lt;code&gt;std::pair&amp;lt;Key, T&amp;gt;&lt;/code&gt; in our node but expose it as a &lt;code&gt;std::pair&amp;lt;const Key, T&amp;gt;&lt;/code&gt; to the user.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Obviously, the Schrodinger &lt;code&gt;std::pair&lt;/code&gt; sounds the most dangerous creature of the two. So... let's pick it!&lt;/p&gt;
&lt;h4&gt;The Schrodinger &lt;strong&gt;std::pair&lt;/strong&gt;:&lt;/h4&gt;
&lt;p&gt;C++ offers at least two official ways to perform type-punning: &lt;a href="https://en.cppreference.com/w/cpp/language/reinterpret_cast"&gt;reinterpret_cast&lt;/a&gt; and &lt;a href="https://en.cppreference.com/w/cpp/language/union"&gt;unions&lt;/a&gt;.&lt;/p&gt;
&lt;h5&gt;reinterpret_cast:&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;reinterpret_cast&lt;/strong&gt; sounds quite attractive: "it is purely a compile-time directive which instructs the compiler to treat expression as if it had the type new_type". But if you read closely &lt;a href="http://eel.is/c++draft/expr.reinterpret.cast#:cast,reinterpret"&gt;along the standard lines&lt;/a&gt;, it has a very restricted usage. It is often used when casting to &lt;code&gt;const char*&lt;/code&gt; (&lt;code&gt;const std::byte*&lt;/code&gt;) to manipulate your types as raw data. But even doing so is harder than you expect. A fun-fact is that the classic pattern in many C++ code-base of reinterpret_casting a memory buffer to a &lt;a href="https://en.cppreference.com/w/cpp/named_req/PODType"&gt;POD&lt;/a&gt; is actually not &lt;a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0593r2.html"&gt;allowed&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;network_buffer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;get_buffer&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

&lt;span class="c1"&gt;// The following code is not allowed as explained by, you would need std:bless from p0593r2.&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;my_a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;reinterpret_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;network_buffer&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Clearly, &lt;strong&gt;reinterpret_cast&lt;/strong&gt; is not our friend here. &lt;a href="https://en.cppreference.com/w/cpp/language/reinterpret_cast"&gt;cppreference&lt;/a&gt; even gently warn us:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;The behavior is undefined unless one of the following is true:
- AliasedType and DynamicType are similar.
...
std::pair&amp;lt;int, int&amp;gt; and std::pair&amp;lt;const int, int&amp;gt; are not similar.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h5&gt;union:&lt;/h5&gt;
&lt;p&gt;We are left with C++'s &lt;a href="https://en.cppreference.com/w/cpp/language/union"&gt;unions&lt;/a&gt; to perform our type-punning. Let's write one:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;union&lt;/span&gt; &lt;span class="n"&gt;union_key_value_pair&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;pair_t&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;pair&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;const_key_pair_t&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;pair&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;class&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;Args&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="n"&gt;union_key_value_pair&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Args&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; 
        &lt;span class="n"&gt;pair_&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;forward&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Args&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)...)&lt;/span&gt; &lt;span class="c1"&gt;// Construct the active member.&lt;/span&gt;
    &lt;span class="p"&gt;{}&lt;/span&gt;

    &lt;span class="c1"&gt;// Special members need to be explicitely defined for unions.&lt;/span&gt;
    &lt;span class="n"&gt;union_key_value_pair&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;union_key_value_pair&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
    &lt;span class="n"&gt;union_key_value_pair&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;union_key_value_pair&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
    &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;union_key_value_pair&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;union_key_value_pair&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;pair_&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pair_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;union_key_value_pair&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;union_key_value_pair&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;pair_&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;move&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;pair_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;union_key_value_pair&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;pair_&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;pair_t&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;// Accessors to the two members.&lt;/span&gt;
    &lt;span class="n"&gt;pair_t&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;pair&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;pair_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;pair_t&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;pair&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;pair_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;const_key_pair_t&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;const_key_pair&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;const_key_pair_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;const_key_pair_t&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;const_key_pair&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;const_key_pair_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;pair_t&lt;/span&gt; &lt;span class="n"&gt;pair_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                           &lt;span class="c1"&gt;// Our active member.&lt;/span&gt;
    &lt;span class="n"&gt;const_key_pair_t&lt;/span&gt; &lt;span class="n"&gt;const_key_pair_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Unions have this concept of an &lt;strong&gt;active member&lt;/strong&gt;: the latest member you constructed. You can only have one active member at a time for a union.
In our case, the active member will always be &lt;code&gt;pair_&lt;/code&gt;, a &lt;code&gt;std::pair&amp;lt;Key, T&amp;gt;&lt;/code&gt;, since this is how we truly want to store the pair.
It is also why we defined all the special members (copy/move constructors/assignment operators) in terms of the &lt;code&gt;pair_&lt;/code&gt; member.
Now the interesting question is what can we do with the "inactive member" &lt;code&gt;const_key_pair_&lt;/code&gt;? Can we expose it to the user directly?&lt;/p&gt;
&lt;p&gt;The standard is suprisingly &lt;a href="http://eel.is/c++draft/class.union#2"&gt;quite clear&lt;/a&gt; on that topic:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;One special guarantee is made in order to simplify the use of unions: 
If a standard-layout union contains several standard-layout structs that share a common initial sequence ([class.mem]), and if a non-static data member of an object of this standard-layout union type is active and is one of the standard-layout structs, it is permitted to inspect the common initial sequence of any of the standard-layout struct members; see [class.mem].&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In rough terms, we will be able to access the inactive member &lt;code&gt;const_key_pair_&lt;/code&gt; if both &lt;code&gt;std::pair&amp;lt;Key, T&amp;gt;&lt;/code&gt; and &lt;code&gt;std::pair&amp;lt;const Key, T&amp;gt;&lt;/code&gt; share the &lt;strong&gt;same layout for their members&lt;/strong&gt; &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;second&lt;/code&gt; and both are &lt;strong&gt;standard-layout structs&lt;/strong&gt;. If you take a look at all the three main standard libraries (&lt;a href="https://github.com/llvm-mirror/libcxx/blob/master/include/utility#L305"&gt;libc++&lt;/a&gt;, &lt;a href="https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/stl_pair.h#L216"&gt;libstdc++&lt;/a&gt;, &lt;a href="https://github.com/microsoft/STL/blob/master/stl/inc/utility#L330"&gt;MSVC's STL&lt;/a&gt;), we can assume that the &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;second&lt;/code&gt; members will always be at the same position (no weird template specialisation going on). But having the guarantee that our pair types will be &lt;strong&gt;standard-layout structs&lt;/strong&gt; is much harder. For that to happen, the types &lt;code&gt;Key&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; they store need to be &lt;strong&gt;standard-layout structs&lt;/strong&gt; themselves.
Here we have to make a hard choice, to follow or not to follow the standard. Please, roll a binary dice and observe the result:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1 - To follow the standard: &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;We decided to listen to the standard and will stick to the &lt;strong&gt;standard-layout structs&lt;/strong&gt; rule. In this scenario, we will conditionally enable our &lt;code&gt;union_key_value_pair&lt;/code&gt; optimisation:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// Our safe fallback to store key/value pairs.&lt;/span&gt;
&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;safe_key_value_pair&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;const_key_pair_t&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;pair&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;class&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;Args&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="n"&gt;safe_key_value_pair&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Args&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;const_key_pair_&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;forward&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Args&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)...)&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;

    &lt;span class="c1"&gt;// Accessors to the two members.&lt;/span&gt;
    &lt;span class="n"&gt;const_key_pair_t&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;pair&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;const_key_pair_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;const_key_pair_t&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;pair&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;const_key_pair_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;const_key_pair_t&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;const_key_pair&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;const_key_pair_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;const_key_pair_t&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;const_key_pair&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;const_key_pair_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;const_key_pair_t&lt;/span&gt; &lt;span class="n"&gt;const_key_pair_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="c1"&gt;// Given a two types Key and T, checks if a pair of the two would be of standard-layout.&lt;/span&gt;
&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kr"&gt;inline&lt;/span&gt; &lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;are_pairs_standard_layout_v&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;is_standard_layout_v&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;pair&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; 
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;is_standard_layout_v&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;pair&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// Given a two types Key and T, returns you the best storage for your pair: the optimised one or the safe one.&lt;/span&gt;
&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;key_value_pair_t&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;conditional_t&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;
    &lt;span class="n"&gt;are_pairs_standard_layout_v&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
    &lt;span class="n"&gt;union_key_value_pair&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
    &lt;span class="n"&gt;safe_key_value_pair&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We start by defining a safe container &lt;code&gt;safe_key_value_pair&lt;/code&gt;. This container is &lt;strong&gt;not a union&lt;/strong&gt; and has only one member of type &lt;code&gt;std::pair&amp;lt;const Key, T&amp;gt;&lt;/code&gt;.
The accessors to the "two members" are behind the scene redirecting to only one member. This type will always perform a copy when moved accross memory, but hey... at least it is safe. Now, when you are crafting your node type, you can use the meta-function &lt;code&gt;key_value_pair_t&lt;/code&gt; that checks whether your pair is of &lt;strong&gt;standard-layout&lt;/strong&gt; and if we should optimise or not the storage. If the pair's type has a &lt;strong&gt;standard-layout&lt;/strong&gt;, we can use the optimised union &lt;code&gt;union_key_value_pair&lt;/code&gt;, if not, we fallback to &lt;code&gt;safe_key_value_pair&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;Finally, if we are so zealous about the standard, we can always add an extra safety net to &lt;code&gt;union_key_value_pair&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;union&lt;/span&gt; &lt;span class="n"&gt;union_key_value_pair&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;static_assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;offsetof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pair_t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;offsetof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;const_key_pair_t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;
        &lt;span class="n"&gt;offsetof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pair_t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;second&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;offsetof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;const_key_pair_t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;second&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This &lt;a href="https://en.cppreference.com/w/cpp/language/static_assert"&gt;static_assert&lt;/a&gt; ensure that the &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;second&lt;/code&gt; members are truly located in the same memory area in both &lt;code&gt;std::pair&amp;lt;Key, T&amp;gt;&lt;/code&gt; and &lt;code&gt;std::pair&amp;lt;const Key, T&amp;gt;&lt;/code&gt;. Even if one of the three main standard library implementation were to sabotage our &lt;code&gt;union_key_value_pair&lt;/code&gt; by shuffling members, we would be warned about it!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;0 - To dodge the standard: &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Note: If you are a C++ purist that never abuse the standard or write his own undefined behaviour, here is the exact point in this post where you should use your jetpack and fly away to a better place.&lt;/p&gt;
&lt;p&gt;In this scenario, we are as paranoid as &lt;a href="https://www.youtube.com/watch?v=IAdLwUXRUvg"&gt;Miro Knejp&lt;/a&gt;: clearly, the standard committee is trying to hide the true power of unions to us. Yes, we can pun!
&lt;center&gt;&lt;a href="https://www.youtube.com/watch?v=IAdLwUXRUvg"&gt;&lt;img width=35% height=35% src="https://jguegant.github.io/blogs/tech/images/non-conforming-cpp.png" alt="Miro Knejp talk"/&gt;&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;Type-punning through unions have been unofficially supported in all three major compilers for longer than I am alive.
Our case is quite safe, given that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Our types would differ from a single &lt;code&gt;const&lt;/code&gt;, this shouldn't have any impact on the size of &lt;code&gt;first&lt;/code&gt; nor its alignment.&lt;/li&gt;
&lt;li&gt;We made the &lt;code&gt;const&lt;/code&gt; version the inactive member that we expose to the user. Going from &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;const T&lt;/code&gt; is a LOT safer than the other way around.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So, we will unconditionally use the &lt;code&gt;union_key_value_pair&lt;/code&gt; container, but we will keep the &lt;code&gt;static_assert&lt;/code&gt; from the previous solution.
We still want to ensure that the memory layout of &lt;code&gt;std::pair&amp;lt;Key, T&amp;gt;&lt;/code&gt; and &lt;code&gt;std::pair&amp;lt;const Key, T&amp;gt;&lt;/code&gt; are strictly the same.
By doing so, we will actually disrespect the standard &lt;a href="http://eel.is/c++draft/support.types.layout#1"&gt;once again&lt;/a&gt;: "the offsetof macro with a type other than a standard-layout class is conditionally-supported". Thankfully, the three main compilers do seem to support it! We can silence GCC's warning on that topic with a well-placed &lt;code&gt;#pragma GCC diagnostic ignored "-Winvalid-offsetof"&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now, we have a fast container for our key/value pairs no matter the types we receive for &lt;code&gt;Key&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt;.
Our last move will be a gesture towards our strict friends, we will wrap all our dangerously-undefined-type-punning into an &lt;code&gt;#ifdef&lt;/code&gt; directive:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;#ifdef JG_STRICT_TYPE_PUNNING&lt;/span&gt;
&lt;span class="c1"&gt;// Use the previous solution.&lt;/span&gt;
&lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="cp"&gt;#else&lt;/span&gt;

&lt;span class="c1"&gt;// Use our hacky but fast solution.&lt;/span&gt;
&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;key_value_pair_t&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;union_key_value_pair&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="cp"&gt;#endif&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;/!\ On a more serious note: you should really be aware of the undefined behaviour of this solution. If your application is used in critical operations, you should refrain yourself from defying the standard. On the other hand, if your application is non-critical (or have a rock-solid release process), you could give a try on the fast type punning. Choose wisely!&lt;/p&gt;
&lt;h2&gt;Conclusion:&lt;/h2&gt;
&lt;p&gt;We survived this first day of our journey! We can control the growth of our container using a policy pattern.
We also have a &lt;strong&gt;Schrodinger std::pair&lt;/strong&gt; at our disposal to move our key/value pairs blazingly fast accross memory while preventing our users to shoot themselves in the feet.&lt;/p&gt;
&lt;p&gt;Be ready for the next phase: the dreaded iterators and allocators are waiting for you!&lt;/p&gt;</content><category term="C++"></category><category term="C++17"></category><category term="hash map"></category><category term="unordered_map."></category></entry><entry><title>Making a STL-compatible hash map from scratch - Part 1 - Beating std::unordered_map</title><link href="https://jguegant.github.io/blogs/tech/dense-hash-map.html" rel="alternate"></link><published>2020-04-06T17:40:00+02:00</published><updated>2020-04-06T17:40:00+02:00</updated><author><name>Jean Guegant</name></author><id>tag:jguegant.github.io,2020-04-06:/blogs/tech/dense-hash-map.html</id><summary type="html">&lt;p&gt;This post is part of a planned series of posts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Part 1 - Beating std::unordered_map (Current)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Part 2 - &lt;a href="https://jguegant.github.io/blogs/tech/dense-hash-map2.html"&gt;Growth Policies &amp;amp; The Schrodinger std::pair&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Part 3 - ... (Coming Soon)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Part 1 - Beating std::unordered_map&lt;/h1&gt;
&lt;h2&gt;Trivia:&lt;/h2&gt;
&lt;p&gt;If C++ had an equivalent in the video game world, it would be similar to Dark …&lt;/p&gt;</summary><content type="html">&lt;p&gt;This post is part of a planned series of posts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Part 1 - Beating std::unordered_map (Current)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Part 2 - &lt;a href="https://jguegant.github.io/blogs/tech/dense-hash-map2.html"&gt;Growth Policies &amp;amp; The Schrodinger std::pair&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Part 3 - ... (Coming Soon)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Part 1 - Beating std::unordered_map&lt;/h1&gt;
&lt;h2&gt;Trivia:&lt;/h2&gt;
&lt;p&gt;If C++ had an equivalent in the video game world, it would be similar to Dark Souls: a dark, violent, punishing game.
Yet, the emotion you get after successfully assimilating all the moves required to overcome a challenge is absolutely impossible to replicate.
You are able to reproduce a sort of dance to defeat any boss in your way.
Speaking of which... what could be the final boss of C++?
According to &lt;a href="https://twitter.com/stephantlavavej"&gt;Stephan T. Lavavej (STL)&lt;/a&gt; this would be the &lt;a href="https://cppcon2019.sched.com/event/Sft8/floating-point-charconv-making-your-code-10x-faster-with-c17s-final-boss"&gt;Floating-Point charconv of the C++17's standard&lt;/a&gt;.
While I wouldn't be able to beat this boss by myself anytime soon, I can tackle a tiny boss: making a standard-compatible (but not necessarily standard-compliant) container from scratch.
I would like to share with you how to beat this kind of smaller bosses by yourself!&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img width=35% height=35% src="https://jguegant.github.io/blogs/tech/images/dark-souls.webp" alt="Dark Souls"/&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;We will build a &lt;code&gt;unordered_map&lt;/code&gt; together, with all the arcane beasts that come along: iterators, allocators, type traits... and we will survive it.&lt;/p&gt;
&lt;p&gt;I encourage you to read this post as an introduction to the wonderful world of hash maps and the ways of the standard. You can find the code for the hash-map I am describing thorough this series of posts &lt;a href="https://github.com/Jiwan/dense_hash_map"&gt;right here&lt;/a&gt;.
Hopefully when you are done reading this series, you will be ready to explore a bit more what the talented people in the C++ community have produced recently.&lt;/p&gt;
&lt;p&gt;Disclaimer: there are lots of extremely talented people (abseil team with their Swiss Tables, Malte Skarupke's flat hash map...) 
that have been researching for years how to make the quintessence of an associative container.
While the one I am presenting here has a really decent performance (more so than the standard ones at least), it is not bleeding-edge.
On the other hand, its design is fairly simple to explain and easy to maintain.&lt;/p&gt;
&lt;h2&gt;Freeing ourselves from the standard constraints:&lt;/h2&gt;
&lt;p&gt;Implementing a standard associative container like &lt;code&gt;std::unordered_map&lt;/code&gt; wouldn't be satisfying enough.
We have to do better! Let's make a faster one! &lt;/p&gt;
&lt;p&gt;The standard library (and its ancestor the STL) is almost as old as me.
You would think that the people working on an implementation of it (libc++, libstdc++...) would have had enough to polish it until there is no room to improvement.
So how could we beat them in their own domain? Well... we are going to cheat... but in a good way.
The standard library is made to be used by the commoners.
The noble ladies and gentlemen in the standard committee stated some constraints to protect us from killing ourselves while using their &lt;code&gt;std::unordered_map&lt;/code&gt;. 
May this over-protective behaviour be damned! We know better!&lt;/p&gt;
&lt;h3&gt;Breaking stable addressing&lt;/h3&gt;
&lt;p&gt;The standard implicitly mandates &lt;strong&gt;stable addressing&lt;/strong&gt; for any implementation of &lt;code&gt;std::unordered_map&lt;/code&gt;.
&lt;strong&gt;Stable addressing&lt;/strong&gt; means that the insertion or deletion of a &lt;strong&gt;key/value pair&lt;/strong&gt; in a &lt;code&gt;std::unordered_map&lt;/code&gt; should not affect the memory location of other &lt;strong&gt;key/value&lt;/strong&gt; pairs in the same &lt;code&gt;std::unordered_map&lt;/code&gt;. More precisely, the standard does not mention, in the &lt;a href="https://eel.is/c++draft/unord.map.modifiers"&gt;Effects&lt;/a&gt; sections of std::unordered_map's modifiers, anything about reference, pointer or iterator invalidation.&lt;/p&gt;
&lt;p&gt;This forces any standard implementation of &lt;code&gt;std::unordered_map&lt;/code&gt; to use linked-list for the buckets of pairs rather than contiguous memory.
&lt;code&gt;std::unordered_map&lt;/code&gt; should look roughly like this in memory:&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img width=50% height=50% src="https://jguegant.github.io/blogs/tech/images/unordered_map_layout.png" alt="unordered_map layout"/&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;As you can see, the &lt;strong&gt;entries&lt;/strong&gt; are stored in a giant &lt;strong&gt;linked-list&lt;/strong&gt;. Each of the &lt;strong&gt;buckets&lt;/strong&gt; are themselves &lt;strong&gt;sub-parts&lt;/strong&gt; of the linked-list.
Here each colors represent different buckets of key/value pairs.
When a &lt;strong&gt;key/value pair&lt;/strong&gt; is &lt;strong&gt;inserted&lt;/strong&gt;, the &lt;strong&gt;key&lt;/strong&gt; is somehow &lt;strong&gt;hashed&lt;/strong&gt; and adjusted (usually using modulo on the amount of buckets) to find which bucket it belongs to, and the key/value pair gets inserted into that bucket. 
Here, the &lt;strong&gt;key1&lt;/strong&gt; and &lt;strong&gt;key2&lt;/strong&gt; somehow ended-up belonging to the &lt;strong&gt;bucket 1&lt;/strong&gt;.
Whereas the &lt;strong&gt;key3&lt;/strong&gt; belongs to the &lt;strong&gt;bucket 5&lt;/strong&gt;.&lt;br&gt;
When doing a lookup using a key, the key is hashed and adjusted to find the bucket it should belong to.
The bucket of the key is &lt;strong&gt;iterated&lt;/strong&gt; until the key is found or the end of the bucket is reached (meaning no key is in the map). 
Finally, the buckets are linked between each others to be able to do a traversal of all the key/value pairs within the &lt;code&gt;std::unordered_map&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This memory layout is &lt;strong&gt;really bad&lt;/strong&gt; for your CPU!
Each of the nodes of the linked-list(s) could be spread across memory and that would play against all the caches of your CPU.
Traversing buckets made of a linked-list is slow, but you could pray that your hash function save you by spreading keys as much as possible and therefore have tiny buckets.
But even the most brilliant hash function will not help you with a common use-case of an associative container: iterating through all the key/value pairs.
Each dereference of the pointer to the next node will be a huge drag on your CPU.
On the other hand, since each node are separately allocated, they can stay wherever they are in memory even if others are added or removed, which provides &lt;strong&gt;stable addressing&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;So what could we obtain if we were to free ourselves from &lt;strong&gt;stable addressing&lt;/strong&gt;?
Well, we could wrap our buckets into contiguous memory like so:&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img width=50% height=50% src="https://jguegant.github.io/blogs/tech/images/dense_hash_map_layout.png" alt="dense_hash_map layout"/&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;Here we are still keeping a linked-list for each buckets, but all the nodes are stored in a vector, therefore one after each others in memory.
Let's call this a &lt;strong&gt;dense hash map.&lt;/strong&gt;
Instead of using pointers between nodes, we are expressing their relations with indexes within the vector: here the node with &lt;strong&gt;key1&lt;/strong&gt; store a "next index" having a value of &lt;strong&gt;2&lt;/strong&gt; which is the index of the node with &lt;strong&gt;key2&lt;/strong&gt;. And all of that is a huge improvement! We are gaining on all fronts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Iterating over all the key/value pairs is as fast as iterating over a vector, which is lightning fast.&lt;/li&gt;
&lt;li&gt;We are saving a pointer on all nodes - the "prev pointer". We don't need any sort of reverse-traversal of a given bucket, but just a global reverse-traversal of all buckets. &lt;/li&gt;
&lt;li&gt;We don't need to maintain a begin and end pointer for the list of nodes.&lt;/li&gt;
&lt;li&gt;Even iterating over a bucket could be faster as the node shouldn't be too scattered in memory since they all belong to one vector.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;All these new properties have a lot of use-cases in the domains I dabble with.
For instance, the &lt;a href="https://en.wikipedia.org/wiki/Entity_component_system"&gt;ECS (Entity-Component-System) pattern&lt;/a&gt; often demands a container where you can do lookup for a component associated to a given entity and at the same being able to traverse all components in one-shot. &lt;/p&gt;
&lt;p&gt;With that said, the &lt;strong&gt;stable addressing&lt;/strong&gt; is now gone: any insertion into the vector could produce a reallocation of its internal buffer, ending in a massive move of all the nodes across memory. So what if your user really need stable addressing? As &lt;strong&gt;David Wheeler&lt;/strong&gt; would say: "just use another level of indirection".
Instead of a using a &lt;code&gt;dense_hash_map&amp;lt;Key, Value&amp;gt;&lt;/code&gt;, your user can always use a &lt;code&gt;dense_hash_map&amp;lt;Key, unique_ptr&amp;lt;Value&amp;gt;&amp;gt;&lt;/code&gt;: &lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img width=50% height=50% src="https://jguegant.github.io/blogs/tech/images/dense_hash_map_unique_ptr_layout.png" alt="layout"/&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;We are reintroducing pointers, which is obviously not great for the cache again.
But this time when iterating over all the key/value pairs you will very likely see a substantial improvement over the first layout.
The pattern of the nodes is clearly more predictable and prefetching abilities of your CPU may come to your help. &lt;/p&gt;
&lt;p&gt;There a lot more layouts for hash tables that I did not mention here and could have suited my needs. 
For instance, any of the &lt;a href="https://en.wikipedia.org/wiki/Hash_table#Open_addressing"&gt;open-addressing&lt;/a&gt; strategies could bring their own pros and cons.
Once again, if you are interested, there are a plethora of cppcon talks on that subject.&lt;/p&gt;
&lt;h4&gt;Caveats&lt;/h4&gt;
&lt;p&gt;By breaking stable-addressing, we cannot retain the address or the reference of a key-value pair from our map carelessly.
Some operations like adding or removing a key/value pair in the map can provoke invalidation of references or pointers to the other pairs.
This is the kind of danger I am speaking of:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;jg&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;dense_hash_map&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;hero&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;my_map&lt;/span&gt;&lt;span class="p"&gt;{{&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;spongebob&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;hero&lt;/span&gt;&lt;span class="p"&gt;{}},&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;chuck norris&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;hero&lt;/span&gt;&lt;span class="p"&gt;{}}};&lt;/span&gt;
&lt;span class="k"&gt;auto&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;chuck_ref&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;my_map&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;chuck norris&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="n"&gt;my_map&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;erase&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;spongebob&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Invalidate all the nodes after spongebob.&lt;/span&gt;

&lt;span class="n"&gt;chuck_ref&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;punch_your_face&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// One should never try to retain &amp;quot;chuck norris&amp;quot; as a ref.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Due to the call to erase, "chuck norris" is moved into the first slot of the internal vector, which ultimately makes chuck's address change.
Accessing "chuck norris" with a previously acquired reference becomes a danger.
While this can surprise at first, it is no different than trying to retain a reference to a value in a vector.
And once again, if you need stable addressing, you are welcome to store &lt;strong&gt;unique_ptrs&lt;/strong&gt; within your map.&lt;/p&gt;
&lt;p&gt;For the same stable-addressing reasons, implementing the &lt;strong&gt;node API of std::unordered_map&lt;/strong&gt; like &lt;a href="https://en.cppreference.com/w/cpp/container/unordered_map/extract"&gt;extract&lt;/a&gt; becomes very challenging. To be fair, I have never seen a real usage of that API in any project.
It might be useful in scenarios where you run long instances of backend-applications and want to move things across maps without a huge performance impact.
If by any chance, you have witnessed a usage of that feature, it would be a pleasure to have some explanations in the comments section.&lt;/p&gt;
&lt;p&gt;Finally, as we will see in a later post, the &lt;strong&gt;erase&lt;/strong&gt; operation of such dense_hash_map becomes &lt;strong&gt;slower&lt;/strong&gt;. For any erase operation, one &lt;strong&gt;extra swap operation&lt;/strong&gt; is needed on top of the destruction and deallocation ones. Thankfully, a standard usage of a map will have little erase operations compared to lookup or even insertion operations. Speaking of which, how could we improve on those operations?&lt;/p&gt;
&lt;h3&gt;Faster modulo operation&lt;/h3&gt;
&lt;p&gt;As I mentioned previously, a lookup will require that your key is hashed and adjusted with modulo to fit in the amount of buckets available.
The amount of buckets is changing depending on how many key/value pairs are stored in your map. The more pairs, the more buckets.
In a &lt;code&gt;std::unordered_map&lt;/code&gt;, the growth is triggered every time the &lt;a href="https://en.cppreference.com/w/cpp/container/unordered_map/load_factor"&gt;load factor&lt;/a&gt; (average number of elements per bucket) is above a certain &lt;a href="https://en.cppreference.com/w/cpp/container/unordered_map/max_load_factor"&gt;threshold&lt;/a&gt;.
Adjusting your hash with a "simple modulo operation" is as it turns out not a trivial operation for your hardware. 
Let's &lt;a href="https://godbolt.org/"&gt;godbolt&lt;/a&gt; a bit!  &lt;/p&gt;
&lt;p&gt;If we write a simple modulo function, this is what godbolt gives to us (on GCC 9.0 with -O3):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// C++&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;modulo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;bucket_count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;hash&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;bucket_count&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// x86 assembly&lt;/span&gt;
&lt;span class="nf"&gt;modulo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;int&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="nf"&gt;mov&lt;/span&gt;     &lt;span class="no"&gt;eax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;edi&lt;/span&gt;  &lt;span class="c1"&gt;// Prepare the hash into eax&lt;/span&gt;
    &lt;span class="nf"&gt;cdq&lt;/span&gt;               &lt;span class="c1"&gt;// Prepare registers for an idiv operation. &lt;/span&gt;
    &lt;span class="nf"&gt;idiv&lt;/span&gt;    &lt;span class="no"&gt;esi&lt;/span&gt;       &lt;span class="c1"&gt;// Divide by esi which contains bucket_count&lt;/span&gt;
    &lt;span class="nf"&gt;mov&lt;/span&gt;     &lt;span class="no"&gt;eax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;edx&lt;/span&gt;  &lt;span class="c1"&gt;// Get the modulo value that ends-up in edx and return it into eax&lt;/span&gt;
    &lt;span class="nf"&gt;ret&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;So far things look rather good. The &lt;code&gt;idiv&lt;/code&gt; operation seems to do most of the work by itself. 
But, what if we made bucket_count a constant? Having more information at compile-time should help the compiler, isn't it?&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// C++&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;modulo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// x86&lt;/span&gt;
&lt;span class="nf"&gt;modulo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;int&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="nf"&gt;movsx&lt;/span&gt;   &lt;span class="no"&gt;rax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;edi&lt;/span&gt;
    &lt;span class="nf"&gt;mov&lt;/span&gt;     &lt;span class="no"&gt;edx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;edi&lt;/span&gt;
    &lt;span class="nf"&gt;imul&lt;/span&gt;    &lt;span class="no"&gt;rax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;rax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1717986919&lt;/span&gt; &lt;span class="c1"&gt;// LOTS OF SHENANIGANS GOING HERE.&lt;/span&gt;
    &lt;span class="nf"&gt;sar&lt;/span&gt;     &lt;span class="no"&gt;edx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;31&lt;/span&gt;
    &lt;span class="nf"&gt;sar&lt;/span&gt;     &lt;span class="no"&gt;rax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;33&lt;/span&gt;
    &lt;span class="nf"&gt;sub&lt;/span&gt;     &lt;span class="no"&gt;eax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;edx&lt;/span&gt;
    &lt;span class="nf"&gt;lea&lt;/span&gt;     &lt;span class="no"&gt;eax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;rax&lt;/span&gt;&lt;span class="err"&gt;+&lt;/span&gt;&lt;span class="no"&gt;rax&lt;/span&gt;&lt;span class="p"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="nf"&gt;sub&lt;/span&gt;     &lt;span class="no"&gt;edi&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;eax&lt;/span&gt;
    &lt;span class="nf"&gt;mov&lt;/span&gt;     &lt;span class="no"&gt;eax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;edi&lt;/span&gt;
    &lt;span class="nf"&gt;ret&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Interesting! The compiler is spitting a lot more operations. Wouldn't it be simpler to keep &lt;code&gt;idiv&lt;/code&gt; here? A single operation... &lt;br&gt;
Believe it or not, your compiler is as smart as a whip and wouldn't do this extra work without significant gains.
So we can clearly extrapolate that our innocent &lt;code&gt;idiv&lt;/code&gt; must be seriously costly if it happens to be less efficient than a couple of other operations.&lt;/p&gt;
&lt;p&gt;So how can we optimize this modulo operation without using &lt;code&gt;idiv&lt;/code&gt; or a constant?
We can use bitwise operations and restrict ourselves to sizes made of power of two.
Assuming that &lt;code&gt;y&lt;/code&gt; is a power of two in the expression &lt;code&gt;x % y&lt;/code&gt;, we can replace this expression with: &lt;code&gt;x &amp;amp; (y - 1)&lt;/code&gt;.
You can think of this bitwise operation as a "filter" on the lower bits of a number, which happen to be the same as a modulo operation when it comes to power of two.
So what do we obtain in this conditions?&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// C++&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;fast_module&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;bucket_count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hash&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bucket_count&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// x86&lt;/span&gt;
&lt;span class="nf"&gt;fast_module&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;int&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="nf"&gt;lea&lt;/span&gt;     &lt;span class="no"&gt;eax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;rsi-1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="nf"&gt;and&lt;/span&gt;     &lt;span class="no"&gt;eax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;edi&lt;/span&gt;
    &lt;span class="nf"&gt;ret&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Not only we have less operations, but &lt;code&gt;lea&lt;/code&gt; (compute a memory address) and &lt;code&gt;and&lt;/code&gt; have much less associated cost than &lt;code&gt;idiv&lt;/code&gt;.
This micro-optimisation may look a bit far-fetched, but it actually matters a lot, as proved by &lt;a href="https://www.youtube.com/watch?v=M2fKMP47slQ"&gt;Malte Skarupke&lt;/a&gt;, when it comes to lookup operations.&lt;/p&gt;
&lt;p&gt;To further convince you, I have run both implementations of modulo on &lt;a href="http://quick-bench.com/XZGeHdIRvI8tjsgHHmPP22bN8us"&gt;quick-bench&lt;/a&gt;.
And here are the results:&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img width=70% height=70% src="https://jguegant.github.io/blogs/tech/images/modulo-benchmarks.png" alt="layout"/&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;There is no doubts, using &lt;strong&gt;bit operations&lt;/strong&gt; instead of &lt;strong&gt;modulo&lt;/strong&gt; is indeed faster!&lt;/p&gt;
&lt;p&gt;Note: For the purists, the so-called modulo operator &lt;code&gt;%&lt;/code&gt; in C++ is actually an integer remainder operator since it does not handle negative value as a mathematical modulo operation would. One can only imagine how costly a proper modulo would be... &lt;/p&gt;
&lt;h4&gt;Caveats&lt;/h4&gt;
&lt;p&gt;Unlike the previous improvement, this one does not seem to collide too much with the holly standard. So how come it is not used in every implementations?
Well, fiddling with bit operations comes with few drawbacks.&lt;/p&gt;
&lt;p&gt;Firstly, the growth of the container for the buckets must always be done following a power of two. This limits you on how creative you can be with your growth strategy. In theory, this could also create subtle performance issues in some scenarios, like &lt;a href="https://tech.labs.oliverwyman.com/blog/2013/10/08/cpu-cache-collisions-in-the-context-of-performance/"&gt;cache line collisions&lt;/a&gt;. In practice, you should never have an access pattern that triggers such an issue on the container of buckets. It is not like you are going to iterate over that container at any time.&lt;/p&gt;
&lt;p&gt;Secondly, in a subtle way you are making the first bits of your keys have more importance than they should.
Let's assume that you have some bit flags (flag sets) as a key:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;    &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;a_precious_flag&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;another_flag&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;// ...&lt;/span&gt;
    &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;yet_another_flag&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;


    &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;a_set_of_flags&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;yet_another_flag&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;a_precious_flag&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;another_flag&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;another_set_of_flags&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a_precious_flag&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;another_flag&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;jg&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;dense_hash_map&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;my_map&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// A map with a buckets container of size 4 (2 ^ 2).&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now, if you were to take these two flag sets and feed them directly to the modulo operation of the map, they would end-up in the same bucket simply because both of them have &lt;code&gt;a_precious_flag&lt;/code&gt; and &lt;code&gt;another_flag&lt;/code&gt; on. This gives way too much importance to the bits that &lt;code&gt;a_precious_flag&lt;/code&gt; and &lt;code&gt;another_flag&lt;/code&gt; represent.
The fact that we are using a power two (4 in this case) will always make the lower bits very significant.
It is not often that you store flag sets or bit fields as keys in a map, I will give you that, but as a good practice you should:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Remind yourself not to create a corner-case with bits more important than others in your key.&lt;/li&gt;
&lt;li&gt;And if it happens, you should re-write your hash function to shuffle your bits around. &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;First conclusion&lt;/h2&gt;
&lt;p&gt;Now we have a grand master plan to beat &lt;code&gt;std::unordered_map&lt;/code&gt; by removing some assumptions the standard had to make to be preserve us from some dangers.
The hacks used are not even too difficult to grasp, so where is the difficulty in writing new containers? Well, some creepy C++ features are waiting for us around the corner.&lt;/p&gt;
&lt;p&gt;Be ready for the next phase: &lt;a href="https://jguegant.github.io/blogs/tech/dense-hash-map2.html"&gt;Part 2 - Growth Policies &amp;amp; The Schrodinger std::pair&lt;/a&gt;!&lt;/p&gt;</content><category term="C++"></category><category term="C++17"></category><category term="hash map"></category><category term="unordered_map."></category></entry><entry><title>Trip report - Meeting C++ 2019</title><link href="https://jguegant.github.io/blogs/tech/trip-report-meetingcpp-2019.html" rel="alternate"></link><published>2019-11-29T22:30:00+01:00</published><updated>2019-11-29T22:30:00+01:00</updated><author><name>Jean Guegant</name></author><id>tag:jguegant.github.io,2019-11-29:/blogs/tech/trip-report-meetingcpp-2019.html</id><summary type="html">&lt;p&gt;Time to go back to the roots!
Me and a few colleagues have been travelling across the old continent to attend the renowned &lt;a href="https://meetingcpp.com/"&gt;Meeting C++&lt;/a&gt; conference in Berlin.&lt;br&gt;
Fully backed by our employer, &lt;a href="https://discover.king.com/about/"&gt;King&lt;/a&gt;, we were able to enjoy a yearly dose of C++ talks at an excellent venue.
I …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Time to go back to the roots!
Me and a few colleagues have been travelling across the old continent to attend the renowned &lt;a href="https://meetingcpp.com/"&gt;Meeting C++&lt;/a&gt; conference in Berlin.&lt;br&gt;
Fully backed by our employer, &lt;a href="https://discover.king.com/about/"&gt;King&lt;/a&gt;, we were able to enjoy a yearly dose of C++ talks at an excellent venue.
I was thrilled at the idea of retrying the "German C++ experience" and my expectation were once again met! 
&lt;strong&gt;C++20&lt;/strong&gt; being right at the corner, I also had in mind to prioritise talks on this topic as much as possible.&lt;/p&gt;
&lt;p&gt;As the tradition goes, I will relate a bit my experience of the event and dress-up a list of the talks I would highly suggest to search for! &lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img width=50% height=50% src="https://jguegant.github.io/blogs/tech/images/berlin-night.jpg"/&gt;&lt;/center&gt;&lt;/p&gt;
&lt;h1&gt;A tour of Meeting (2019):&lt;/h1&gt;
&lt;p&gt;I did a decent &lt;a href="https://jguegant.github.io/blogs/tech/trip-report-meetingcpp-2017.html"&gt;introduction of the event two years ago&lt;/a&gt; and most of it stand true.
Rather than doing another summary, I will compare and contrast my experience at &lt;strong&gt;Meeting C++&lt;/strong&gt; with the one I had last year at &lt;strong&gt;Cppcon&lt;/strong&gt;. &lt;/p&gt;
&lt;h2&gt;The venue:&lt;/h2&gt;
&lt;p&gt;When it comes to the facilities of the venue, I found the rooms in the Andels Hotel to have unequal quality.
While the two big rooms on the lower floors are excellent, the upper floor ones are really long and narrow. 
If the nature made you of a short stature or you don't have the best eyesight (or both like me), you will have a hard time following some of the slides.
I cannot remember having any issue with that at &lt;strong&gt;CppCon&lt;/strong&gt;. Having rooms with inclined rows helps a lot!&lt;/p&gt;
&lt;p&gt;Note: apparently, the organisers are well-aware of this issue and may come up with a nice solution for the next round of Meeting C++! &lt;/p&gt;
&lt;p&gt;Probably to avoid having crammed rooms and irritating noises, &lt;strong&gt;Meeting C++&lt;/strong&gt; also has this concept of closing doors of the tracks as soon as the talk starts and not letting annoying enter. I am not quite convinced by this idea, it extremely frustrating to not be able to move to another talk if the current one is not to your taste. &lt;/p&gt;
&lt;h2&gt;The German cuisine:&lt;/h2&gt;
&lt;p&gt;Being French, a detail often comes to my mind... the food provided during the event!
Unlike &lt;strong&gt;CppCon&lt;/strong&gt;, this event offers catering all day long, and tasty one mind you. 
Obviously you cannot expect conference meals to deserve a &lt;a href="https://en.wikipedia.org/wiki/Michelin"&gt;Michelin stars's&lt;/a&gt;, but there was plenty and with a lot of variety. Is that a must-do for a conference? Probably not, but it is both really convenient and it also brings a LOT of interactions between members of the community. People will tend to have more casual conversations if they are dinning in the same place rather than going out. From what I can recall, &lt;strong&gt;CppCon&lt;/strong&gt; provided snacks here and there, but nothing worth remembering.&lt;/p&gt;
&lt;h2&gt;The talks:&lt;/h2&gt;
&lt;p&gt;Last but not least, the speakers! On one hand, &lt;strong&gt;Meeting C++&lt;/strong&gt; has more diversity: the speakers are coming from all around Europe and you may discover a lot of new names and some hidden gems that didn't/wouldn't make it to &lt;strong&gt;CppCon&lt;/strong&gt; - not everyone is willing or can afford to travel to the USA. On the other hand, the amount of C++ committee members and famous speakers per square kilometre felt higher at &lt;strong&gt;CppCon&lt;/strong&gt; which probably made the talks of a slightly better quality overall.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Meeting C++&lt;/strong&gt; offers you the possibility to go to four different tracks for a given time slot.
It is enough choices that you will always find a talk to your liking.
The talks are also explicitly tagged with a level of experience required to enjoy them: beginner to advanced.
Once again, going only to talks with topics that you like is often not the best strategy to fully enjoy this conference.
It can be very rewarding to go out of your comfort zone and try a talk not a single word on its title make sense to you. 
Likewise, do not underestimate the quality of beginner talks. You may learn more than you would expect!&lt;/p&gt;
&lt;p&gt;I have had a first hand, albeit short, experience on what it takes to be a speaker at such an event.
I gave a lightning talk highly inspired on the &lt;a href="https://jguegant.github.io/blogs/tech/trip-report-meetingcpp-2017.html"&gt;performing try emplace post&lt;/a&gt; I did at the beginning of this year.
While it went rather smoothly (if not for a small technical issue with my slides), I felt intimidated when I went on stage in front of maybe 300 people (best-guess estimation). &lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img width=50% height=50% src="https://jguegant.github.io/blogs/tech/images/my-lightning-talk-meeting-cpp-2019.jpg"/&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;You can find a pdf version of the slides right &lt;a href="https://jguegant.github.io/blogs/tech/images/associative-containers-the-art-of-inserting-gracefully.pdf"&gt;here&lt;/a&gt; and maybe a YouTube record of that talk will pop at one point on the &lt;a href="https://www.youtube.com/user/MeetingCPP"&gt;Meeting C++ channel&lt;/a&gt;.
It was interesting to see that the &lt;strong&gt;lightning talks&lt;/strong&gt; were a lot more formal than at &lt;strong&gt;CppCon&lt;/strong&gt; where jokes and bad-puns are a constant.
I believe that the lightning talks format was changed recently at &lt;strong&gt;Meeting C++&lt;/strong&gt;: it used to be its own dedicated track on a full afternoon, and it became a more casual evening event. We, the lightning speakers, were also informed a bit late on where, when and how should the talks happen.&lt;/p&gt;
&lt;p&gt;Doing a presentation on an innovative topic, interesting and understandable by all requires a lot of upfront work.
Having to do it in a foreign language, for one hour, in front of a rather massive crowd is even more demanding.
I am still amazed by what all these speakers gave us during these three days! &lt;/p&gt;
&lt;h1&gt;The chief's suggestions of the year:&lt;/h1&gt;
&lt;p&gt;Here comes again the menu of the talks I particularly enjoyed. The legend follow the usual rules:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;💀 : The difficulty of the talk (💀: Beginner friendly, 💀💀: Intermediate, 💀💀💀: High exposure to C++'s dark corners)&lt;/li&gt;
&lt;li&gt;★ : My interest for the talk (★: Good talk, ★★: Tasty talk, ★★★: Legendary talk)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;No need to say that I will not spoil everything in the talks, but I will simply try to give an idea of what the talk was about. If the talk seems to be of your taste, I highly encourage you to watch the video record of it or the slides. 
 If your talk or a talk that you liked very much is not part of this menu, do not feel too disenchanted about it.
 I had to curate this list to a few talks or I would have to write an entire novel.
 Feel free to post your opinion about the talks in the comment section.&lt;/p&gt;
&lt;h3&gt;[Keynote] Design Rationale for &lt;chrono&gt; - Howard Hinnant - 💀💀★★:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Slides: &lt;a href="https://meetingcpp.com/mcpp/slides/2019/Hinnant.pdf"&gt;link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Video: &lt;a href=""&gt;coming soon&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The &lt;strong&gt;Howard Hinnant&lt;/strong&gt;, himself, came to present his new-born baby: the support of dates, calendars and time-zones in the &lt;a href="https://en.cppreference.com/w/cpp/chrono"&gt;chrono header&lt;/a&gt;. 
For those out-of-the-loop, &lt;a href="https://howardhinnant.github.io/HowardHinnant.html"&gt;Howard Hinnant&lt;/a&gt; has been a massive contributor to what C++ is nowadays.
He is known for bringing &lt;strong&gt;move semantics&lt;/strong&gt; to the language, introducing &lt;code&gt;std::unique_ptr&lt;/code&gt;, being lead author of &lt;strong&gt;libc++&lt;/strong&gt;... a myriad of things... and the notion of time in the standard through the header &lt;code&gt;&amp;lt;chrono&amp;gt;&lt;/code&gt;. It should not come as surprise that Howard is also the man being the dates and calendars coming to the new C++ standard. &lt;/p&gt;
&lt;p&gt;Howard's talk was very educating on this addition to &lt;strong&gt;C++20&lt;/strong&gt;. Within two hours, I had a fairly good overview of what we will get and more importantly an answer to why &lt;strong&gt;chrono&lt;/strong&gt; is so verbose.
Here is the gist of what we will have:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://en.cppreference.com/w/cpp/chrono/time_point"&gt;std::chrono::time_point&lt;/a&gt; (already in C++11) get a specialized alias &lt;code&gt;sys_days&lt;/code&gt; equal to &lt;code&gt;std::chrono::time_point&amp;lt;std::chrono::system_clock, std::chrono::days&amp;gt;&lt;/code&gt;. In other word &lt;code&gt;sys_days&lt;/code&gt; represent a time point using the system clock and expressed in days. This &lt;code&gt;sys_days&lt;/code&gt; can be thought as an integer representing a value in days.&lt;/li&gt;
&lt;li&gt;We can convert this &lt;code&gt;sys_days&lt;/code&gt; time point into a &lt;a href="https://en.cppreference.com/w/cpp/chrono/year_month_day"&gt;year_month_day&lt;/a&gt; representation and vice-versa.
This is the same representation of that time point but in a much more human-friendly way: it uses the Gregorian calendar to express that point in time. 
A time point in the Gregorian calendar is made of three parts: a year, a month and a day of the month.
The new standard offers lots of arithmetic operators, conversion operators, helpers structs... to manipulate these parts easily.&lt;/li&gt;
&lt;li&gt;A new type, with a self-explanatory name, &lt;a href="https://en.cppreference.com/w/cpp/chrono/time_zone"&gt;std::chrono::time_zone&lt;/a&gt; has been introduced.
If you combine a &lt;code&gt;sys_days&lt;/code&gt; with a &lt;code&gt;time_zone&lt;/code&gt;, you obtain a &lt;code&gt;zoned_time&lt;/code&gt;. &lt;code&gt;zoned_time&lt;/code&gt; handles conversion from one &lt;code&gt;time_zone&lt;/code&gt; to another for you.
It is highly convenient! &lt;/li&gt;
&lt;li&gt;Finally, almost all the types in the &lt;code&gt;&amp;lt;chrono&amp;gt;&lt;/code&gt; header have conversion facilities to and from strings. It even works with the new &lt;a href="https://en.cppreference.com/w/cpp/utility/format"&gt;std::format&lt;/a&gt; library. &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Equipped with this extended &lt;code&gt;&amp;lt;chrono&amp;gt;&lt;/code&gt; header, you can easily write such things:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;January&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2019&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;year&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;2020&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sys_days&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;weeks&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;zoned_time&lt;/span&gt; &lt;span class="n"&gt;london&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Europe/London&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;local_days&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;18&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;    
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;london&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;zoned_time&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;America/New_York&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;london&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In this example, we are displaying the time in "New York" every two weeks, starting from the 9th of January, for the year 2019, when it is 18.00 in "London".
As Howard pointed out, this is far from being trivial to do by hand: both the UK and USA have different daylight savings rules.&lt;/p&gt;
&lt;p&gt;Some people may complain of the &lt;strong&gt;verbosity&lt;/strong&gt;. Firstly, I find the code very readable even without prior knowledge of this new part of &lt;code&gt;&amp;lt;chrono&amp;gt;&lt;/code&gt;
Second, &lt;strong&gt;safety&lt;/strong&gt; was a key-point in Howard's design. At multiple time, he gave us example on how his design prevents wrongdoings at compile-time. 
For instance: what is a time difference? Can this be considered a date? Can &lt;code&gt;2 hours&lt;/code&gt; be translated to a date in a calendar? Probably not! &lt;/p&gt;
&lt;p&gt;I am quite eager to get this part of C++20! &lt;/p&gt;
&lt;h3&gt;[Talk] 10 techniques to understand existing code - Jonathan Boccara - 💀★★★:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Slides: &lt;a href="https://meetingcpp.com/mcpp/slides/2019/understand_code.pdf"&gt;link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Video: &lt;a href=""&gt;coming soon&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Jonathan Boccara&lt;/strong&gt;, known for his awesome blog &lt;a href="https://www.fluentcpp.com/"&gt;fluentcpp.com&lt;/a&gt;, is always a safe bet when it comes to C++ talks.
You should not necessarily expect learning bleeding-edge techniques with Jonathan, but he is extremely talented at putting words on things!&lt;/p&gt;
&lt;p&gt;This time, he was presenting us his favourite approaches to code you have never seen before. Especially, when it comes to intricate code-bases.
My favourite analogy was the &lt;strong&gt;stronghold&lt;/strong&gt; one: start your exploration of the code from a place (a function, a routine...) that is crucial in the code-base and that you can easily understand. Like a &lt;strong&gt;fog of war&lt;/strong&gt; in a video-game, the rest of the code is unknown to you at first. But slowly, you can explore the rest of the map/code-base by sending minions/yourself into the callers or the callees related to that function. One strategy to know where to "expand your territory for a maximum of profit" is by looking at &lt;strong&gt;call stacks&lt;/strong&gt;: by jumping in the frames above the current function, this can give you an idea of what is the critical path of your program.&lt;/p&gt;
&lt;p&gt;Here is an awesome representation, from Jonathan, of &lt;strong&gt;call stacks&lt;/strong&gt; in a video-game universe:&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img width=50% height=50% src="https://jguegant.github.io/blogs/tech/images/call-stack-fog-of-war.png"/&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;Not only this applies to decipher a code-base, but it is also a very efficient technique in &lt;strong&gt;reverse engineering&lt;/strong&gt;.
When trying to reverse a native application, it is often quite rewarding to put a breakpoint on the system calls: these are your strongholds.
Without source-code, you have very little places where you know what the assembly you are reading does.
System calls are well documented and exposed, so it is naturally a good place to start.&lt;/p&gt;
&lt;p&gt;I believe that I am already applying most of these techniques on a daily-basis.
But if I had to explain to a junior programmer what programming on a large code-base is all about, 
I would probably recommend that person to have a look at this talk.&lt;/p&gt;
&lt;h3&gt;[Talk] Testing Legacy Code - Fuzzing for Better Input Data - Tina Ulbrich, Niel Waldren - 💀💀★★★:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Slides: &lt;a href="https://meetingcpp.com/mcpp/slides/2019/Testing%20Legacy%20Code%20-%20Fuzzing%20for%20Better%20Input%20Data.pdf"&gt;link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Video: &lt;a href=""&gt;coming soon&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;During such conferences, you may end-up for various reasons (entering the wrong door, following someone, not getting on time to a room...) into a talk that you did not expect on your schedule. Sometimes, you may regret your unfortunate choice as much as &lt;code&gt;std::vector&amp;lt;bool&amp;gt;&lt;/code&gt; being in the standard, but it can also turn out into your favour: you may discover one of the best presentation of that day. This is exactly what happened to me with the talk from &lt;strong&gt;Tina Ulbrich&lt;/strong&gt; and &lt;strong&gt;Niel Waldren&lt;/strong&gt; about &lt;a href="https://en.wikipedia.org/wiki/Fuzzing"&gt;fuzzing&lt;/a&gt; and unit-testing.&lt;/p&gt;
&lt;p&gt;Usually, &lt;strong&gt;fuzzing&lt;/strong&gt; consists in feeding an application or part of an application with pseudo-random data to explore as much code-path as possible.
The end-goal is to find code-paths that lead to crashes or bugs which can be exploit for malicious purposes.&lt;br&gt;
Once an exploit found, the fuzzer will often try to reduce the "buggy input" to a minimal set to clearly isolate the corner case.&lt;/p&gt;
&lt;p&gt;I have heard about fuzzing for a while, but I never had the opportunity to use it myself.
This technique is really appealing if you are working in the security business or if your application is critical part of system.
If you are developing an application a bit less demanding on the stability, like video-games, fuzzing is not necessarily the number one priority.
&lt;strong&gt;Tina&lt;/strong&gt; and &lt;strong&gt;Niel&lt;/strong&gt; twisted the usage of fuzzing to find exploits to improve the test-coverage of their library.
They used &lt;a href="https://llvm.org/docs/LibFuzzer.html"&gt;libFuzzer&lt;/a&gt; which is, from what I understand, a LLVM library that combine &lt;a href="https://clang.llvm.org/docs/SanitizerCoverage.html"&gt;LLVM's code coverage tool - SanitizerCoverage&lt;/a&gt; with a fuzzer engine like &lt;a href="http://lcamtuf.coredump.cx/afl/"&gt;AFL&lt;/a&gt;.
&lt;strong&gt;libFuzzer&lt;/strong&gt; will try to maximize the code-coverage with the minimum input data.
This is really appealing for all projects relying on unit-tests. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tina&lt;/strong&gt; and &lt;strong&gt;Niel&lt;/strong&gt; did a step by step explanation on how to use &lt;strong&gt;libFuzzer&lt;/strong&gt; and what are its benefits:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;How to tweak the random data you receive to valid parameters.&lt;/li&gt;
&lt;li&gt;How to reuse the best input data corpus to write new unit-tests for your application.&lt;/li&gt;
&lt;li&gt;Why you can use this to detect very subtle changes in your API's behaviour. Changes that you would not necessarily catch with usual unit-tests.&lt;/li&gt;
&lt;li&gt;A lot more...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I will have a second watch of their talk as soon as their video is available on the conference's Youtube channel.
It was a very innovative topic to me!&lt;/p&gt;
&lt;h3&gt;[Talk] Modules - The Beginner's Guide - Daniela Engert - 💀💀★★:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Slides: &lt;a href="https://meetingcpp.com/mcpp/slides/2019/modules-the-beginners-guide-meetingcpp2019.pdf"&gt;link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Video: &lt;a href=""&gt;coming soon&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Out of the three major language features coming to C++20 (concepts, coroutines and modules), I was the least familiar with &lt;strong&gt;modules&lt;/strong&gt;.
The committee is often very active on the standard until the last months before the release of a version. 
While I had a rough idea of module were about in C++, I did not bother to learn about the syntax and the exact implementation.
You never know if the feature you read about in a white paper while look any different in the actual standard!
So, I was very grateful that &lt;a href="https://github.com/DanielaE"&gt;Daniela Engert&lt;/a&gt; came up with that talk right before 2020.
Being so close to the standard release, the module part was unlikely to change too much! &lt;/p&gt;
&lt;p&gt;So what are modules in a few words?
Traditionally, a C++ code-base is separated into multiple &lt;strong&gt;compilation units&lt;/strong&gt; which are in most case your &lt;code&gt;.cpp&lt;/code&gt; files.
These compilation units are &lt;strong&gt;compiled&lt;/strong&gt; separately and &lt;strong&gt;combined&lt;/strong&gt; by the &lt;strong&gt;linker&lt;/strong&gt;.
If you want to share functions or objects between two compilation units, you must have a &lt;strong&gt;common interface&lt;/strong&gt; for them: one or more &lt;strong&gt;header files&lt;/strong&gt; (.h/.hpp) that declare what is available.
The problem is that header files are:&lt;/p&gt;
&lt;p&gt;1) Shared in a very primitive way. The &lt;code&gt;#include&lt;/code&gt; directive is doing dumb copy-paste of the header content into your cpp file.
2) Often full of complicated content for the compiler and not just few declarations. In those, you can have macros, templates, inline functions, include of includes... &lt;/p&gt;
&lt;p&gt;This results in your compiler doing a lot of unnecessary work parsing these headers for all the compilation units. 
Wouldn't it be better if compilation units themselves could expose directly what they provide instead of using these hackish headers?
This is exactly what modules try to solve!&lt;/p&gt;
&lt;p&gt;So writing a very basic module becomes as simple as writing a &lt;code&gt;.cpp&lt;/code&gt; file with few annotations to expose what we want:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;export&lt;/span&gt; &lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="n"&gt;my&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// This is the name of our module&lt;/span&gt;
&lt;span class="k"&gt;export&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Expose a variable.&lt;/span&gt;

&lt;span class="k"&gt;export&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Expose a function.&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt; 

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// No export keyword == no exposition.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;When compiling this &lt;code&gt;.cpp&lt;/code&gt; file, this will create two others files: an object file that contains binary code (OBJ) and a file for interfacing with that module called Binary Module Interface. Unlike a header file, the BMI file and its associated OBJ file can have a highly &lt;strong&gt;optimized representation&lt;/strong&gt; of what is available in the module. &lt;/p&gt;
&lt;p&gt;As a user of a module into another compilation unit, you will pass this BMI file as parameter to your compiler and write an import statement:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="n"&gt;my&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Ask the compiler to use that module in here.&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// This is using bar from the other module.&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;And voilà! These are the new C++ module in all their glory.
Except that it gets quite a lot more complicated when you are mixing old header includes, namespaces, special support for standard headers...
&lt;strong&gt;Daniela&lt;/strong&gt; was really good at explaining all these quirks that you may encounter in the rough transition that will happen from headers to modules.&lt;/p&gt;
&lt;p&gt;As for performance, she observed an improvement from 1546 milliseconds to 62 milliseconds when using a library as a module on a huge-scale project at work. 
This gives a lot of hope on what modules will offer to us when available on all major compilers!&lt;/p&gt;
&lt;h3&gt;[Talk] C++20 The small things - Timur Doumler - 💀★★:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Slides: &lt;a href="https://meetingcpp.com/mcpp/slides/2019/talk.pdf"&gt;link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Video: &lt;a href="https://www.youtube.com/watch?v=Xb6u8BrfHjw"&gt;cppcon link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You probably have heard of the major features coming to C++20: concepts, coroutines and modules. And you would think that this is enough on your C++ plate for a few years.
Well, even without these three features, C++20 still has plenty to offer. This is what &lt;a href="https://twitter.com/timur_audio"&gt;Timur Doumler&lt;/a&gt; demonstrated to us for one hour!   &lt;/p&gt;
&lt;p&gt;Amongst a plethora of small improvements, here are my favourite so far:&lt;/p&gt;
&lt;h4&gt;Designated initialisers&lt;/h4&gt;
&lt;p&gt;Let's imagine that you have a &lt;code&gt;struct&lt;/code&gt; with quite a few members in it. Now let's pretend that we want to initialize this structure with a few variables using the &lt;a href="https://en.cppreference.com/w/cpp/language/aggregate_initialization"&gt;aggregate initilization from C++11&lt;/a&gt;.
What are the chances that you assign the correct members from the first try? &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;my_struct&lt;/span&gt; 
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;b2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;b3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="n"&gt;my_struct&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;43&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1337&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;54&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="cm"&gt;/*...*/&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I tell you, the chances are low. You will have to double-check the &lt;code&gt;struct&lt;/code&gt; definition more than once to order things accurately!
So what if you could specify which member you designate? This is where C++20 comes to save the day:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;my_struct&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;{.&lt;/span&gt;&lt;span class="n"&gt;a1&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;43&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;a2&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1337&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;b2&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;54&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="cm"&gt;/*...*/&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I can hear YOU the C programmer, this has been in C99 for a while...
And you will also point with your smug face that you must respect the order (by appearance in the definition) of the members when using C++'s designated initializers unlike C.
It happens that C++ has much more complicated rules of evaluation than C. Allowing for random order of assignment could be troublesome.
What this is feature is about is 1) &lt;strong&gt;safety&lt;/strong&gt; 2) a nice way to get &lt;strong&gt;auto-completion&lt;/strong&gt; from your IDE on what member you need to fill in.&lt;/p&gt;
&lt;h4&gt;Improved lambdas&lt;/h4&gt;
&lt;p&gt;If you want to capture a &lt;strong&gt;parameter pack&lt;/strong&gt; within a lambda before C++20, you will have to be &lt;a href="https://stackoverflow.com/questions/47496358/c-lambdas-how-to-capture-variadic-parameter-pack-from-the-upper-scope"&gt;extremely creative&lt;/a&gt;. This is even more frustrating that lambdas are great to combine with templates.
This very tedious task becomes trivial in C++20:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;class&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;Args&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Args&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;[...&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;move&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)]()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
        &lt;span class="c1"&gt;// Do whatever you want with args...&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt; 
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;std::mindblowing()! Sprinkling a bit of &lt;code&gt;...&lt;/code&gt; where it should... works as expected!&lt;/p&gt;
&lt;p&gt;Lambdas become, in C++20, allowed in a &lt;strong&gt;unevaluated contexts&lt;/strong&gt;. What are unevaluated contexts? Whenever you have an expression within a &lt;code&gt;sizeof(...)&lt;/code&gt; or &lt;code&gt;decltype&lt;/code&gt;.
Is that something you would frequently do? Actually yes. Whenever you want a custom deleter for your &lt;code&gt;std::unique_ptr&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// Before C++20:&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;custom_deleter&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt; &lt;span class="cm"&gt;/* Do something with h. */&lt;/span&gt; &lt;span class="n"&gt;release&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt; 
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;unique_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;decltype&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;custom_deleter&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// Becomes a one liner:&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;unique_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;decltype&lt;/span&gt;&lt;span class="p"&gt;([](&lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt; &lt;span class="cm"&gt;/* Do something with h. */&lt;/span&gt; &lt;span class="n"&gt;release&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;Timur&lt;/strong&gt; came up with other examples like having a custom comparison template parameter for &lt;code&gt;std::set&lt;/code&gt;.&lt;/p&gt;
&lt;h4&gt;Extended Non-Type Template Parameter (NTTP)&lt;/h4&gt;
&lt;p&gt;If you are a &lt;strong&gt;template meta-programming&lt;/strong&gt; (TMP) enthusiast like me, this will be a game changer!
Right now, the standard only allow integer-like (integer, enumeration, pointers...) and types as template parameter. This is highly restrictive and frustrating at times.
When pushing template meta-programming to its limit, you will often want to manipulate strings. Right now you will need to decompose your string into &lt;code&gt;char&lt;/code&gt; that you pass as template arguments.&lt;/p&gt;
&lt;p&gt;For instance, these bits of code would never work in &lt;strong&gt;C++17&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;vec2&lt;/span&gt; 
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;vec2&lt;/span&gt; &lt;span class="n"&gt;V&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="c1"&gt;// error: vec2 - illegal type for non-type template parameter  &lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;my_struct&lt;/span&gt; 
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;V&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;V&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;bla&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;


&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;InitValue&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="c1"&gt;// error: std::string - illegal type for non-type template parameter  &lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;my_struct2&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;InitValue&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Good news! These restrictions have been lifted as long as your &lt;strong&gt;non-type template parameter&lt;/strong&gt;'s type (I know the usage of "type" twice here is confusing):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1) Has a comparison operator available (&lt;code&gt;operator==&lt;/code&gt;) at compile time: it is &lt;strong&gt;constexpr&lt;/strong&gt;.
The goal is that the compiler should be able to check if two template instantiations are the same by checking if all template parameters are equal. &lt;/li&gt;
&lt;li&gt;2) Can be constructed at compile-time: its construction can be done in a constexpr context.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;[Talk] Compile Time Regular Expressions with Deterministic Finite Automaton - Hana Dusíková - 💀💀💀★:&lt;/h3&gt;
&lt;p&gt;Speaking of template meta-programming, NTTP and strings, &lt;a href="https://twitter.com/hankadusikova"&gt;Hana Dusíková&lt;/a&gt; improved her &lt;a href="https://github.com/hanickadot/compile-time-regular-expressions"&gt;compile-time regular expression&lt;/a&gt; library. 
At last year's &lt;strong&gt;CppCon&lt;/strong&gt;, Hana impressed the crowd with her library: it exploited template meta-programming in C++17 to its maximum to generate a regex parser at compile-time from a string literal. 
This makes her library ridiculously fast compared to &lt;code&gt;std::regex&lt;/code&gt;, which works at runtime. Surprisingly, the library does not affect compilation at all. 
In fact, it improves a lot the compilation time compared to &lt;code&gt;std::regex&lt;/code&gt;! Does this implies that there is such a thing as "Zero-cost Abstractions"? Maybe...&lt;/p&gt;
&lt;p&gt;I have to admit that I was part of the people who missed the chance to see her talk live when I could have...
So this year, I took my revenge and went to her follow-up talk.
Using some of the C++20 template features, Hana succeeded to make a new regexp engine using a &lt;a href="https://en.wikipedia.org/wiki/Deterministic_finite_automaton"&gt;Deterministic Finite Automaton&lt;/a&gt;. Do not ask me to summarise properly what I have witnessed during this talk, it was... complicated!
But it is also fascinating, it combines a hefty does of meta-programming with language theory: that's a lot of mental stimulation.&lt;/p&gt;
&lt;p&gt;If that sounds fun to you, I would probably suggest to watch her &lt;a href="https://www.youtube.com/watch?v=QM3W36COnE4"&gt;initial talk&lt;/a&gt; and come back to this one afterwards.&lt;/p&gt;
&lt;h3&gt;[Other]:&lt;/h3&gt;
&lt;p&gt;There are a lot of other talks that would be worth using your &lt;strong&gt;Google-Fu&lt;/strong&gt; to find them:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Using C++20's Three-way Comparison &amp;lt;=&amp;gt; - Jonathan Müller&lt;/li&gt;
&lt;li&gt;Oh No! More Modern CMake - Deniz Bahadir&lt;/li&gt;
&lt;li&gt;C++20 Coroutines - Milosz Warzecha  &lt;/li&gt;
&lt;li&gt;And many more...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You will surely find the &lt;strong&gt;lightning talks&lt;/strong&gt; on the &lt;a href="https://www.youtube.com/user/MeetingCPP/videos"&gt;Meeting C++'s Youtube Channel&lt;/a&gt; at one point.
These short talks are like snack foods, they vary a lot in their content and quality and don't take long to process. &lt;/p&gt;
&lt;h1&gt;Conclusion:&lt;/h1&gt;
&lt;p&gt;This was another very fruitful event for the &lt;strong&gt;C++&lt;/strong&gt; community. I am glad that our beloved C++ language receive so much attention by its users and the committee. 
It will be interesting to see how long it will take for the major compiler to be fully C++20 compliant: this &lt;strong&gt;release is massive&lt;/strong&gt;!
I was slightly overwhelmed by the amount of new features.&lt;br&gt;
I am also wondering how much of the newly acquired C++20 knowledge will stay true once the standard is released.
I guess that I will have to check that by going to another C++ event next year ;) &lt;/p&gt;</content><category term="C++"></category><category term="C++"></category><category term="event"></category><category term="meetingcpp"></category></entry><entry><title>How to make your maps, try_emplace and smart pointers play nicely with each others in C++17.</title><link href="https://jguegant.github.io/blogs/tech/performing-try-emplace.html" rel="alternate"></link><published>2018-11-18T15:30:00+01:00</published><updated>2018-11-18T15:35:00+01:00</updated><author><name>Jean Guegant</name></author><id>tag:jguegant.github.io,2018-11-18:/blogs/tech/performing-try-emplace.html</id><summary type="html">&lt;h2&gt;Trivia:&lt;/h2&gt;
&lt;p&gt;Lately, I have been working on the reincarnation of a &lt;strong&gt;class&lt;/strong&gt; at work: a hash map. 
While this class had interesting internals (a sort of dense hash map) and performed really well, its interface was not up to standard both literally and metaphorically.
After much of lipstick applied to …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;Trivia:&lt;/h2&gt;
&lt;p&gt;Lately, I have been working on the reincarnation of a &lt;strong&gt;class&lt;/strong&gt; at work: a hash map. 
While this class had interesting internals (a sort of dense hash map) and performed really well, its interface was not up to standard both literally and metaphorically.
After much of lipstick applied to it, the &lt;strong&gt;class&lt;/strong&gt; now fully mimic the interface of the beloved &lt;a href="https://en.cppreference.com/w/cpp/container/unordered_map"&gt;std::unordered_map&lt;/a&gt; from the standard library.
A close look on &lt;code&gt;std::unordered_map&lt;/code&gt; and its sister &lt;a href="https://en.cppreference.com/w/cpp/container/map"&gt;std::map&lt;/a&gt; reveals few interesting design choices.
Combining this interface with some smart pointer types can present some challenges to squeeze performance out of your maps.
We will explore these challenges in this blog post, and try to figure out some solutions.&lt;/p&gt;
&lt;p&gt;Disclaimer: C++ being C++, I would not be suprise if 1) I wrote some unacurracies here 2) Some guru could reduce this entire article in a phantasmagoric one liner.&lt;/p&gt;
&lt;h3&gt;Some peculiar modifier member functions:&lt;/h3&gt;
&lt;p&gt;Note: This part of the post will serve as a reminder for some of the folks that are not well versed in the &lt;strong&gt;associative containers&lt;/strong&gt; of the standard. If you are confident, you can always jump straight to the dilemma part. &lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img width=25% height=25% src="https://jguegant.github.io/blogs/tech/images/container-ship.png" alt="A container"/&gt;&lt;/center&gt;&lt;/p&gt;
&lt;h4&gt;insert:&lt;/h4&gt;
&lt;p&gt;If you observe the interface of the &lt;strong&gt;associative containers&lt;/strong&gt; (like &lt;a href="https://en.cppreference.com/w/cpp/container/map"&gt;std::map&lt;/a&gt; or &lt;a href="https://en.cppreference.com/w/cpp/container/unordered_map"&gt;std::unordered_map&lt;/a&gt;) in the current standard you will notice that there are 6 member functions to map a value to a given key: &lt;code&gt;insert&lt;/code&gt;, &lt;code&gt;insert_or_assign&lt;/code&gt;, &lt;code&gt;emplace&lt;/code&gt;, &lt;code&gt;emplace_hint&lt;/code&gt;, &lt;code&gt;try_emplace&lt;/code&gt; and the &lt;strong&gt;subscript operator&lt;/strong&gt; (operator[]). That number does not include all the overloads for each of these member functions. It is not a wonder that a lot of C++ users will tend to do suboptimal calls to insert values in their &lt;strong&gt;associative containers&lt;/strong&gt;, the choice is not always obvious when you have 6 different functions with slightly different behaviour. &lt;/p&gt;
&lt;p&gt;Typically, you will often this pattern within a code-base:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;unordered_map&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// Check if the key is already in m.&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;find&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;johannes&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// Often written as m.count(&amp;quot;johannes&amp;quot;) == 0&lt;/span&gt;
    &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;johannes&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;lucio&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// If not insert they key&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Little did your colleague, boss, or tired ego know that such a code will do twice a relatively costly job: checking the existence of the key in the map.
Indeed, in the case of a &lt;code&gt;std::unordered_map&lt;/code&gt;, the key &lt;code&gt;"johannes"&lt;/code&gt; will be hashed twice: in &lt;code&gt;find&lt;/code&gt; and in the &lt;code&gt;operator[]&lt;/code&gt;. In both member functions, the &lt;code&gt;std::unoredered_map&lt;/code&gt; has to know in which bucket the key will fall into. Worst! If you are having collisions between your keys, checking the existence of a key may induce up to N comparisons (even your hash function can be drunk sometimes) where N is the amount of stored key-value pairs. Potentially mutiplying these comparisons by two is not something you should desire. Such a situation in &lt;code&gt;std::map&lt;/code&gt; is even worst, this will always bring roughly O(log(N)) comparisons. Comparing two keys may not always be as cheap as it seems and if you add on top of that the cost of jumping through a linked list of nodes, this should be considered harmful.&lt;/p&gt;
&lt;p&gt;Obviously the answer to this problem is to use &lt;a href="https://en.cppreference.com/w/cpp/container/map/insert"&gt;insert&lt;/a&gt;. &lt;code&gt;insert&lt;/code&gt; as its name implies, will only work if it can insert the key in the &lt;strong&gt;associative container&lt;/strong&gt;, meaning that the insertion will not happen if the same key is already in the map. If you really care to know whether the insertion happend, &lt;code&gt;insert&lt;/code&gt; will return a &lt;code&gt;pair&lt;/code&gt; of an iterator and a boolean that you can query. The iterator points to the newly inserted key-value pair or the already existing one, the boolean indicates whether the insertion happened or not.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// Use C++17 structured bindings and class template argument deduction (CTAD)&lt;/span&gt;
&lt;span class="c1"&gt;// See more on my previous post on that topics&lt;/span&gt;
&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;it&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;pair&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;johannes&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;lucio&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt; &lt;span class="c1"&gt;// Construct a pair and insert it if needed.&lt;/span&gt;
&lt;span class="c1"&gt;// Do whatever you want with it and result.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Here only one check for the existence will be done, that is much better, isn't it?
Well, while this snippet is shorter and performs better, there is still room for improvement.
Here we are constructing a &lt;code&gt;pair&lt;/code&gt; out of the map, the same &lt;code&gt;pair&lt;/code&gt; that needs to be created in a node of the &lt;code&gt;map&lt;/code&gt;.
Internally a call to the &lt;strong&gt;move-constructor&lt;/strong&gt; of the &lt;code&gt;pair&lt;/code&gt; will be done, or way worst a call to the &lt;strong&gt;copy-constructor&lt;/strong&gt; if one of the two types in the &lt;code&gt;pair&lt;/code&gt; cannot be moved.
Relying on the &lt;strong&gt;move-constructor&lt;/strong&gt; of a &lt;code&gt;pair&lt;/code&gt; to exist AND to be performant is too much of a wishful thinking. &lt;/p&gt;
&lt;h4&gt;emplace:&lt;/h4&gt;
&lt;p&gt;Thanksfully, C++11 added on many containers a new member function called &lt;a href="https://en.cppreference.com/w/cpp/container/map/emplace"&gt;emplace&lt;/a&gt;. Given a container of type &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;emplace&lt;/code&gt; will accept the arguments necessary for an in-situ construction of a new instance of &lt;code&gt;T&lt;/code&gt;. Meaning that we can easily improve our insertion in this way: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;it&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;emplace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;johannes&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;lucio&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Construct the pair of &amp;quot;johannes&amp;quot;, &amp;quot;lucio&amp;quot; straight into m.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I will go slightly against &lt;a href="https://abseil.io/tips/112"&gt;abseil's recommendation&lt;/a&gt; and say that &lt;code&gt;emplace&lt;/code&gt; should be prefered over &lt;code&gt;insert&lt;/code&gt; in &lt;strong&gt;C++11&lt;/strong&gt; for at least all the &lt;strong&gt;associative containers&lt;/strong&gt;. It will perform better (as explained previously) and it also feels more natural (most users think of a key and a value, not a std::pair)! &lt;/p&gt;
&lt;p&gt;Now &lt;code&gt;emplace&lt;/code&gt; on &lt;strong&gt;associative containers&lt;/strong&gt; has a vicious specification which &lt;a href="https://en.cppreference.com/w/cpp/container/map/emplace"&gt;cppreference gently warns you about&lt;/a&gt;. For some obscure reasons, even if the &lt;strong&gt;emplace operation&lt;/strong&gt; does not succeed since the key already exists, your arguments passed as a &lt;strong&gt;r-value&lt;/strong&gt; may have been moved anyway.
More vaguely, the standard mandates effects only on whether the insertion will happen or not and the return value:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Effects: Inserts a value_­type object t constructed with std::forward&amp;lt;Args&amp;gt;(args)... if and only if there is no element in the container with key equivalent to the key of t.
The bool component of the returned pair is true if and only if the insertion takes place, and the iterator component of the pair points to the element with key equivalent to the key of t.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This cryptic language-lawyer text does not explain in any way what happens to the arguments in the case of failure. For what we know, they could be sent over smoke signal up to Hong-Kong and inserted into some fortune cookies. Why would we care about that? Well, because that will restrain you to write such code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;unordered_map&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;unique_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;my_precious_int&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;make_unique&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;it&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;emplace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ricky&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;move&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;my_precious_int&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt; &lt;span class="c1"&gt;// We need to move unique pointers.&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// Alright the insertion failed, let&amp;#39;s do something else with my_precious_int.&lt;/span&gt;
    &lt;span class="n"&gt;do_something_else&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;my_precious_int&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Or can we?&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Here &lt;code&gt;my_precious_int&lt;/code&gt; is unusable right after the call to &lt;code&gt;emplace&lt;/code&gt;, it may have been moved-from forever and ever, &lt;strong&gt;EVEN&lt;/strong&gt; if the insertion result is &lt;code&gt;false&lt;/code&gt;.
Some confused souls will tell you that this is evident, we called &lt;code&gt;std::move&lt;/code&gt;, so it MUST be moved-from. Like the famous cake, &lt;code&gt;std::move&lt;/code&gt; is a lie! It does not move anything, it simply casts objects to &lt;strong&gt;a x-value&lt;/strong&gt; which makes them POTENTIALLY moveable-from (this world would have been better if &lt;code&gt;std::move&lt;/code&gt; was named &lt;code&gt;std::to_xvalue&lt;/code&gt;, &lt;code&gt;std::moveable&lt;/code&gt;, &lt;code&gt;std::to_be_moved&lt;/code&gt;...).&lt;/p&gt;
&lt;h4&gt;try_emplace:&lt;/h4&gt;
&lt;p&gt;This unleashed &lt;code&gt;emplace&lt;/code&gt; is a real pain when you are trying to store move-only types in any &lt;strong&gt;associative container&lt;/strong&gt;.
The standard committee was aware of the issue and fixed it in &lt;strong&gt;C++17&lt;/strong&gt; with another member function called &lt;a href="https://en.cppreference.com/w/cpp/container/map/try_emplace§"&gt;try_emplace&lt;/a&gt;.
Here are the expected effects:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Effects: If the map already contains an element whose key is equivalent to k, there is no effect.
Otherwise inserts an object of type value_type constructed with piecewise_construct, forward_as_tuple(std::move(k)), forward_as_tuple(std::forward&amp;lt;Args&amp;gt;(args)...).
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;It effectively prevents your arguments to be moved-from (as well as being packaged into fortune cookies) in the case of an insertion failure.
Why wasn't &lt;code&gt;emplace&lt;/code&gt; simply patched?
If you take a look at the definition of &lt;a href="https://en.cppreference.com/w/cpp/container/map/emplace§"&gt;emplace&lt;/a&gt;, you will understand that it accepts as a key argument any object with a &lt;strong&gt;type compatible&lt;/strong&gt; with your &lt;strong&gt;key type&lt;/strong&gt;.
Unlike the value argument, the key argument ALWAYS need to be somehow converted to the &lt;strong&gt;key type&lt;/strong&gt; to check for its existence in the map.
The potential conversion would defeat the "there is no effect" policy. 
&lt;code&gt;try_emplace&lt;/code&gt; is stricter and only takes a key of type &lt;strong&gt;key type&lt;/strong&gt;, which guarantees that no conversion sequence will be triggered.
At least &lt;code&gt;try_emplace&lt;/code&gt; can help us to safely rewrite the previous example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;unordered_map&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;unique_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;my_precious_int&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;make_unique&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;it&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;try_emplace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ricky&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;move&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;my_precious_int&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt; &lt;span class="c1"&gt;// We need to move unique pointers.&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// Alright the insertion failed, let&amp;#39;s do something else with my_precious_int.&lt;/span&gt;
    &lt;span class="n"&gt;do_something_else&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;my_precious_int&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// It is safe! &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Hurray! After three corrections in the standard, we can effectively mix associative containers with &lt;code&gt;unique_ptrs&lt;/code&gt; for a maximum of fun and profit!
Well... no. &lt;strong&gt;C++ being C++&lt;/strong&gt;, it cannot be that easy. There is one last boss to slain.&lt;/p&gt;
&lt;h3&gt;The last dilemma of a map of unique_ptrs:&lt;/h3&gt;
&lt;p&gt;&lt;img width=20% height=20% style="float: right;" src="https://jguegant.github.io/blogs/tech/images/dilemma.jpg" alt="A container"/&gt;&lt;/p&gt;
&lt;p&gt;Before I start on this topic, I would like to remind everyone a basic rule: you should try to avoid heap allocations.
You should always strive to get a &lt;code&gt;std::map&amp;lt;T1, T2&amp;gt;&lt;/code&gt; over a &lt;code&gt;std::map&amp;lt;T1, std::unique_ptr&amp;lt;T2&amp;gt;&amp;gt;&lt;/code&gt;.
Now that being said, you may have situations where you cannot do otherwise:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If you need runtime polymorphism. For instance, you may need to store services into a &lt;code&gt;std::map&amp;lt;std::string, std::unique_ptr&amp;lt;service&amp;gt;&amp;gt;&lt;/code&gt; where &lt;code&gt;service&lt;/code&gt; is an interface with multiples concrete implemetations. Although, there are always ways to hide the inheritance as explained by &lt;a href="https://www.youtube.com/watch?v=QGcVXgEVMJg"&gt;Sean Parent&lt;/a&gt;... &lt;/li&gt;
&lt;li&gt;If your weapon of choice is a map following closely the interface of &lt;code&gt;std::unordered_map&lt;/code&gt; or &lt;code&gt;std::map&lt;/code&gt; minus the stable addressing part of it.
This is often the case for all the hash map with excellent performance, like &lt;a href="https://github.com/skarupke/flat_hash_map/blob/master/flat_hash_map.hpp"&gt;skarupe's one&lt;/a&gt;.
Not having stable addressing means that querying the address of a value in the map &lt;code&gt;&amp;amp;map["jeremy"]&lt;/code&gt; might give you different results if you do any modifying operations (insert, erase...) on the map. In such case, having an extra indirection (heap allocation) will bring back stable addressing. &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Not only dealing with pointers (even smart ones) is often tedious, but it can also ruin the &lt;code&gt;try_emplace&lt;/code&gt; member function of your class.
You will have to choose between a costly object creation or the dreaded double key lookup I mentioned right at the beggining of this post. 
Pick your poison!&lt;/p&gt;
&lt;h4&gt;Uncessary object creation or double key lookup:&lt;/h4&gt;
&lt;p&gt;Let's keep the idea of a map of services: &lt;code&gt;std::map&amp;lt;std::string, std::unique_ptr&amp;lt;service&amp;gt;&amp;gt;&lt;/code&gt;, and you would like to register a service "file_locator" only if there was none registered earlier.
Hastily, you may write such code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;unique_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;service&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;// ...&lt;/span&gt;

&lt;span class="c1"&gt;// Create a file locator that explore a file system on a remote server.&lt;/span&gt;
&lt;span class="c1"&gt;// remote_file_locator implements the service interface.&lt;/span&gt;
&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;it&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;try_emplace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;file_locator&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;make_unique&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;remote_file_locator&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;8.8.8.8&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;/a_folder/&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Print which file_locator is already in there. &lt;/span&gt;
    &lt;span class="n"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Could not register a remote_file_locator, it has been overridden by: &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;it&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If the &lt;code&gt;remote_file_locator&lt;/code&gt; is successfully registered, everything is fine!
But in the other scenario where a &lt;code&gt;file_locator&lt;/code&gt; is already in the map, this code has a huge pessimisation.
Here your compiler will emit code that allocate enough memory for a &lt;code&gt;remote_file_allocator&lt;/code&gt;, then it will construct it, under any circumstances.
If allocating can be seen as slow in the C++ world, starting a connection to a server is pure hell when it comes to speed.
If you are not planning to use the instance of this really costly object, why would you create it in the first place?&lt;/p&gt;
&lt;p&gt;So shall we revert to the double lookup?&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;it&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;find&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;file_locator&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;it&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;file_locator&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;make_unique&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;remote_file_locator&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;8.8.8.8&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;/a_folder/&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Could not register a remote_file_locator, it has been overridden by: &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;it&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Hell no! I already explained why I discourage you to use such a pattern in the first part of this post.
You could argue that here we will only pay this double lookup overhead only once, when we try to create the "remote_file_locator".
Given more time and coffee, I should be able to come up with an architecture where you could do such insertions of unique_ptrs in a loop.
In any case, C++ is all about not paying in performance for uncessary things. &lt;/p&gt;
&lt;p&gt;But don't worry, C++ being C++, there surely are ways to get around this impediment.&lt;/p&gt;
&lt;h4&gt;Two clumsy solutions:&lt;/h4&gt;
&lt;p&gt;I, personally, could come up with two solutions. If you have a better one, you are welcome to express it in the comments.&lt;/p&gt;
&lt;p&gt;The first one is actually not so hacky. You can start by trying to emplace an empty &lt;code&gt;unique_ptr&lt;/code&gt;, if the insertion works you can always fix it afterwards with a real allocation:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// Try to emplace an empty `unique_ptr` first.&lt;/span&gt;
&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;it&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;try_emplace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;file_locator&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;nullptr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// The insertion happened, now we can safely create our remote_file_locator without wasting any performance. &lt;/span&gt;
    &lt;span class="n"&gt;it&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;make_unique&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;remote_file_locator&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;8.8.8.8&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;/a_folder/&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I somehow dislike this solution. It is not consistent with the usage of &lt;code&gt;try_emplace&lt;/code&gt; on more classic types, which do not require any extra step. 
It really smells like some kind of two-phases initialisation pattern which are usually frowned upon.
We are temporarily putting our map into a state where "file_locator" cannot be trusted. What if the actual creation of the &lt;code&gt;remote_file_locator&lt;/code&gt; throws an exception?
That would leave the map with a empty "file_locator", that's not great.&lt;/p&gt;
&lt;p&gt;My second solution consists in trying to delay the construction of the &lt;code&gt;remote_file_locator&lt;/code&gt;.
To do so, I wrote a very simple helper struct that I called &lt;code&gt;lazy_convert_construct&lt;/code&gt;.
This struct wraps any kind of lambda that acts like factory: the &lt;strong&gt;lambda factory&lt;/strong&gt; returns an instance of a given type, &lt;code&gt;"result_type"&lt;/code&gt;, when called.
If at any point the struct needs to be converted to &lt;code&gt;result_type&lt;/code&gt;, it will call the internal lambda to generate an instance of &lt;code&gt;result_type&lt;/code&gt;.
Any code should speaks for itself, so here is the &lt;code&gt;lazy_convert_construct&lt;/code&gt; beast in all its beauty:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Factory&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;lazy_convert_construct&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;result_type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;invoke_result_t&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Factory&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Use some traits to check what would be the return type of the lambda if called.&lt;/span&gt;

    &lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="nf"&gt;lazy_convert_construct&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Factory&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;factory&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
        &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;factory_&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;move&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;factory&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="c1"&gt;// Let&amp;#39;s store the factory for a latter usage.&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;//                                     ↓ Respect the same nowthrow properties as the lambda factory.&lt;/span&gt;
    &lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="nf"&gt;result_type&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="k"&gt;noexcept&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;is_nothrow_invocable_v&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Factory&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
    &lt;span class="c1"&gt;//        ^ enable       ^ the type this struct can be converted to &lt;/span&gt;
    &lt;span class="c1"&gt;//          conversion&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;factory_&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  &lt;span class="c1"&gt;// Delegate the conversion job to the lambda factory.&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;Factory&lt;/span&gt; &lt;span class="n"&gt;factory_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="c1"&gt;// Example of usage:&lt;/span&gt;
&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lazy_convert_construct&lt;/span&gt;&lt;span class="p"&gt;([]{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;});&lt;/span&gt;
&lt;span class="c1"&gt;//        ^ CTAD again                    ^ Factory lambda that returns an int.&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;//      ^ Here l is forced to be converted to an int and will therefore call the lambda to do so.&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Prints 42. &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Note that the lambda will not be called if there is no conversion needed, this makes it having a &lt;a href="https://en.wikipedia.org/wiki/Lazy_evaluation"&gt;lazy evaluation&lt;/a&gt;.
Note also: after turning all optimisations on, the &lt;code&gt;lazy_convert_construct&lt;/code&gt; entirely disappears and x will be simply initialised by 42 when needed. &lt;/p&gt;
&lt;p&gt;The next step is to combine this &lt;code&gt;lazy_convert_construct&lt;/code&gt; with &lt;code&gt;try_emplace&lt;/code&gt;, which works like a charm:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;it&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;try_emplace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;file_locator&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;lazy_convert_construct&lt;/span&gt;&lt;span class="p"&gt;([]{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;make_unique&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;remote_file_locator&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;8.8.8.8&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;/a_folder/&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="p"&gt;}));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;lazy_convert_construct&lt;/code&gt; is now able to create a &lt;code&gt;unique_ptr&amp;lt;remote_file_locator&amp;gt;&lt;/code&gt; on-demand. Even with &lt;code&gt;lazy_convert_construct&lt;/code&gt;, &lt;code&gt;try_emplace&lt;/code&gt; will respect its contract: it will not have any side effect on the &lt;code&gt;lazy_convert_construct&lt;/code&gt; object if the key &lt;code&gt;"file_locator"&lt;/code&gt; is already present. Meaning that no conversion will happen if the key already exists.
This rather elegant solution fixes one of the main drawback of the previous one: it never leaves the map in a state with a &lt;code&gt;file_locator&lt;/code&gt; being null.
It is also a one liner!&lt;/p&gt;
&lt;h4&gt;Benchmark results:&lt;/h4&gt;
&lt;p&gt;Some of you may still be a bit skeptical on the importance of optimising your queries in your associative containers.
So I wrote a very simple benchmark which explores multiple insertion scenarios on a &lt;code&gt;std::map&amp;lt;std::string, std::unique_ptr&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;.
You can fetch it &lt;a href="https://github.com/Jiwan/benchmarks_map_insertion"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Using clang 6.0 on my Linux laptop, I obtain the following results:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;2018-11-18 14:16:17
Running ./fast_try_emplace
Run on (8 X 3600 MHz CPU s)
CPU Caches:
  L1 Data 32K (x4)
  L1 Instruction 32K (x4)
  L2 Unified 256K (x4)
  L3 Unified 8192K (x1)
***WARNING*** CPU scaling is enabled, the benchmark real time measurements may be noisy and will incur extra overhead.
-----------------------------------------------------------------------------
Benchmark                                      Time           CPU Iterations
-----------------------------------------------------------------------------
insertion_double_lookup                      636 ns        638 ns    1085075
insertion_construct_before_try_emplace       503 ns        506 ns    1387818
insertion_lazy_convert_try_emplace           503 ns        506 ns    1380488

no_insertion_double_lookup                   107 ns        107 ns    6300180
no_insertion_construct_before_try_emplace   8642 ns       8641 ns      80478
no_insertion_lazy_convert_try_emplace         32 ns         32 ns   22393508
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Clearly, a sucessful insertion using the double lookup is more expensive than it should. The cost will change depending on the amount of &lt;strong&gt;key-value pairs&lt;/strong&gt; already in the map.
For a failed insertion scenario, my &lt;code&gt;lazy_convert_construct&lt;/code&gt; is also faster than the double lookup. I cannot explain why! Internally, &lt;code&gt;find&lt;/code&gt; and &lt;code&gt;try_emplace&lt;/code&gt; should have the same lookup mechanims.
And of course, creating a costly object and destroying right after is really bad choice. That explains why &lt;code&gt;no_insertion_construct_before_try_emplace&lt;/code&gt;'s record is so damn huge compared to the two others cases (I purposely made the type very costly to create for the no insertion cases).&lt;/p&gt;
&lt;p&gt;GCC offers similar results, without the mysterious advantage of the &lt;code&gt;try_emplace&lt;/code&gt; + &lt;code&gt;lazy_convert_construct&lt;/code&gt; over the double lookup in a no insertion scenario.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;2018-11-18 14:17:53
Running ./fast_try_emplace
Run on (8 X 3600 MHz CPU s)
CPU Caches:
  L1 Data 32K (x4)
  L1 Instruction 32K (x4)
  L2 Unified 256K (x4)
  L3 Unified 8192K (x1)
***WARNING*** CPU scaling is enabled, the benchmark real time measurements may be noisy and will incur extra overhead.
-----------------------------------------------------------------------------
Benchmark                                      Time           CPU Iterations
-----------------------------------------------------------------------------
insertion_double_lookup                      547 ns        543 ns    1310711
insertion_construct_before_try_emplace       493 ns        496 ns    1394343
insertion_lazy_convert_try_emplace           495 ns        500 ns    1000000

no_insertion_double_lookup                    44 ns         44 ns   15787599
no_insertion_construct_before_try_emplace   8659 ns       8658 ns      78869
no_insertion_lazy_convert_try_emplace         44 ns         44 ns   15895884
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now we can proudly claim that we solved all the insertion issues (at least those that I am aware of).
But somehow it still feels like something is off with the smart pointer types of the standard library.
Are we missing something here?&lt;/p&gt;
&lt;h4&gt;An in_place constructor:&lt;/h4&gt;
&lt;p&gt;Warning: here you will enter the somehow controversial and imaginary part of my post. I am not claiming that this is the direction &lt;strong&gt;C++&lt;/strong&gt; should take on these issues, but merely raising my questions on that topic. &lt;/p&gt;
&lt;p&gt;Indeed, &lt;code&gt;unique_ptr&lt;/code&gt; and its other smart pointers counsins (&lt;code&gt;shared_ptr&lt;/code&gt;...)  are rather special types.
On one hand you could see them as simple RAII wrappers that take care of a basic resource: a pointer. 
On the other hand, you could, &lt;strong&gt;very arguably&lt;/strong&gt; (&amp;lt;== note this bold statement), see them as some funky &lt;strong&gt;value wrappers&lt;/strong&gt; with a very special storage (one that implies pointer semantics). &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Value wrappers&lt;/strong&gt; are types that enhance the property of another type(s). The most recent ones in the standard are: &lt;a href="https://en.cppreference.com/w/cpp/utility/optional"&gt;std::optional&lt;/a&gt;, &lt;a href="https://en.cppreference.com/w/cpp/utility/variant"&gt;std::variant&lt;/a&gt; and &lt;a href="https://en.cppreference.com/w/cpp/utility/any"&gt;std::any&lt;/a&gt;. 
As expected, all of these new &lt;strong&gt;value wrappers&lt;/strong&gt; have constructors that accepts an instance of the type they are wrapping:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;args1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;args2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* do some with the args */&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="c1"&gt;// Move construct the newly created A into o.&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;optional&lt;/span&gt; &lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;}});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;While such constructors might be sufficient for most of the usages of your &lt;strong&gt;value wrappers&lt;/strong&gt;, sometimes you really want to avoid any move or copy constructors.
The standard committee was proactive and provided another set of constructors to build the wrapped value &lt;strong&gt;in-place&lt;/strong&gt;.
In order to disambiguate with the usual constructors, these new constructors take as a first argument a &lt;a href="https://www.fluentcpp.com/2018/04/27/tag-dispatching/"&gt;tag type&lt;/a&gt;: &lt;a href="https://en.cppreference.com/w/cpp/utility/in_place"&gt;std::in_place&lt;/a&gt; or &lt;a href="https://en.cppreference.com/w/cpp/utility/in_place"&gt;std::in_place_type&lt;/a&gt;. Here is how &lt;code&gt;std::in_place&lt;/code&gt; works with &lt;code&gt;std::optional&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;//            ↓ No CTAD            ↓ The arguments needed for constructing a new instance of A.&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;optional&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;in_place&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;});&lt;/span&gt;
&lt;span class="c1"&gt;//                   ^ dispatch to in place constructor.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;With such a constructor, we can safely assume that the wrapped instance of &lt;code&gt;A&lt;/code&gt; was built directly in its storage place.
Of course, you can also use this constructor if you are dealing with &lt;code&gt;map::try_emplace&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;optional&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;try_emplace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;bruno&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;in_place&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;});&lt;/span&gt;
&lt;span class="c1"&gt;//                           ^ Will construct the wrapped A deep down in the map.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;At this point, if you are following my anology between &lt;code&gt;std::unique_ptr&lt;/code&gt; and &lt;strong&gt;value wrappers&lt;/strong&gt;, you could start to question yourself on why we could not get a similar set of constructors for our smart pointers. Maybe something similar to this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;unique_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;service&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;allocate_in_place&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;remote_file_locator&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;}};&lt;/span&gt;
&lt;span class="c1"&gt;//                          ^ tag                   ^ concret instance   ^ following args.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I intentionally chose a different &lt;strong&gt;tag type&lt;/strong&gt; than &lt;code&gt;std::in_place&lt;/code&gt; for two reasons:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;This constructor is doing more than constructing in place, it does allocate. The user should be informed.  &lt;/li&gt;
&lt;li&gt;In a similar fashion to &lt;a href="https://en.cppreference.com/w/cpp/utility/in_place"&gt;std::in_place_type &lt;/a&gt;, we somehow need to encode the concret type we want to instantiate.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With such a constructor in the standard for &lt;code&gt;unique_ptr&lt;/code&gt;, our issue with &lt;code&gt;try_emplace&lt;/code&gt; would become trivial to solve. Just call it!&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;it&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;try_emplace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;file_locator&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;allocate_in_place&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;remote_file_locator&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;8.8.8.8&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;/a_folder/&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The constructor of &lt;code&gt;unique_ptr&lt;/code&gt; that accept the tag &lt;code&gt;allocate_in_place&lt;/code&gt; would be called only if only the key "file_locator" is not in there.
No overhead, simple syntax,  you could not ask for more!&lt;/p&gt;
&lt;p&gt;As a side effect,  my guess is that we could also fully deprecate the usage of &lt;code&gt;make_unique&lt;/code&gt; and &lt;code&gt;make_shared&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// Before:&lt;/span&gt;
&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;make_shared&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;something&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;michel&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;christian&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;// After&lt;/span&gt;
&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;allocate_in_place&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;something&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;michel&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;christian&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Obviously the syntax is far from being &lt;strong&gt;terse&lt;/strong&gt;. The invented feature also does not take in consideration the &lt;strong&gt;allocator arguments&lt;/strong&gt; you could receive in a smart pointer.
Me and a colleague promised ourselves to look a bit more into this topic. Whether we will formulate a proposal or just have some afterthoughts, be sure that I will let you informed on that in a further post! &lt;/p&gt;
&lt;h3&gt;Conclusion:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;If you are inserting a new pair into an &lt;strong&gt;associative container&lt;/strong&gt; consider using &lt;code&gt;try_emplace&lt;/code&gt; first.&lt;/li&gt;
&lt;li&gt;If you cannot use &lt;strong&gt;C++17&lt;/strong&gt;, prefer to use &lt;code&gt;emplace&lt;/code&gt; over &lt;code&gt;insert&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;If you are cannot use &lt;strong&gt;C++11&lt;/strong&gt;, I feel sorry for you!&lt;/li&gt;
&lt;li&gt;You can borrow my &lt;code&gt;lazy_convert_construct&lt;/code&gt; if you are dealing with smart pointers and &lt;code&gt;try_emplace&lt;/code&gt;, to get a blazzing fast insertion.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A special thanks to my colleague Yo Anes with whom I had a lot of fun discussing this specific topic.&lt;/p&gt;</content><category term="C++"></category><category term="C++17"></category><category term="std::map"></category><category term="std::unordered_map."></category></entry><entry><title>Trip report - CppCon 2018</title><link href="https://jguegant.github.io/blogs/tech/trip-report-cppcon-2018.html" rel="alternate"></link><published>2018-10-07T23:09:00+02:00</published><updated>2018-10-07T23:09:00+02:00</updated><author><name>Jean Guegant</name></author><id>tag:jguegant.github.io,2018-10-07:/blogs/tech/trip-report-cppcon-2018.html</id><summary type="html">&lt;p&gt;New year, new conference! 
This time, my employer, &lt;a href="https://discover.king.com/about/"&gt;King&lt;/a&gt;, helped me to organize a first pilgrimage to &lt;a href="https://cppcon.org/"&gt;CppCon&lt;/a&gt; for me and another colleague.
You cannot fathom how enthusiastic I was to finally making it there!
Although I might be a bit late on the "trip-report-race", I think that it is …&lt;/p&gt;</summary><content type="html">&lt;p&gt;New year, new conference! 
This time, my employer, &lt;a href="https://discover.king.com/about/"&gt;King&lt;/a&gt;, helped me to organize a first pilgrimage to &lt;a href="https://cppcon.org/"&gt;CppCon&lt;/a&gt; for me and another colleague.
You cannot fathom how enthusiastic I was to finally making it there!
Although I might be a bit late on the "trip-report-race", I think that it is still worth to relate my overall experience of the event and then move onto a list of recommended talks you should watch-out on Youtube. &lt;/p&gt;
&lt;h1&gt;About CppCon (2018):&lt;/h1&gt;
&lt;h2&gt;The event:&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;CppCon&lt;/strong&gt; is the most renowned conference for all the C++ afficionados. So far held anually in the cozy city center of Bellevue, Washington (or less precisely somewhere close-by to Seattle for those like me that are not into north-american geography), &lt;strong&gt;CppCon&lt;/strong&gt; let you explore the &lt;strong&gt;C++&lt;/strong&gt; world with various talks, keynotes and other activities provided by some accomplished members of the community. The event is usually happening at the end of September and lasts 5 days, or even more for those attending the training sessions. The program is really plentiful and you would need to watch presentations from 8.00am to 10.00pm, have an ubiquity capacity to be simultaneously in 6 rooms at the same time, and have infinite memory to be able to absorbe all the C++ knowledge flowing during these days.&lt;/p&gt;
&lt;p&gt;Do not get me wrong, while the conference is impressive when it comes to the amount of content, that does not imply that this content is out of the reach of the commoners. On one hand you have hairy topics like "Compile-time programming" being discussed, and on the other hand you have acces to gentle introductions to some features of the language. Dedicated or novice C++ users will appreciate as much the conference but for different reasons. A novice will bring back home a lot of new keywords/concepts to plunge into. Someone who follow C++ news, may not make as many discoveries at &lt;strong&gt;CppCon&lt;/strong&gt; than at &lt;a href="http://cppnow.org/"&gt;CppNow&lt;/a&gt;, but she/he will gain a lot of inspiration/motivation from other C++ fellows and will be exposed to other point of views on the language.&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img width=50% height=50% src="https://jguegant.github.io/blogs/tech/images/bellevue.jpg"/&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;Does this sound exciting to you, but you missed the opportunity to come this year? No worries, &lt;strong&gt;CppCon&lt;/strong&gt; has one of the best &lt;a href="https://www.youtube.com/user/CppCon/videos"&gt;Youtube channel&lt;/a&gt; where they upload all the talks. I have always been impressed by the quality of their videos and the frequency at which they can produce such material. Now, I can say that behind the scene (or actually in front...), they have an excellent video-shooting crew in each of the conference rooms. On a side note, all keynotes were introduced by a live rock-band, which you can see at the beggining of the videos. Whether you appreciated the music or not, it is hard to deny that CppCon organizers really put a lot of efforts in the entire event! &lt;/p&gt;
&lt;h1&gt;My experience over there:&lt;/h1&gt;
&lt;p&gt;Right before leaving Stockholm, I had the great idea to listen to my favorite C++ podcast &lt;a href="http://cppcast.com/"&gt;CppCast&lt;/a&gt;. The guest for that week was &lt;strong&gt;Bryce Adelstein Lelbach&lt;/strong&gt; who is one of the organiser of CppCon. Bryce had four advices for any new attendee of the conference, which matched my experience at &lt;a href="https://jguegant.github.io/blogs/tech/trip-report-meetingcpp-2017.html"&gt;Meeting C++&lt;/a&gt; last year and turn out to be valid for CppCon too:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Have no regrets! Indeed, as an attendee you will quickly discover that two or three appealing talks will be on the same time slot. Just randomly pick one of the talk or none if you need to rest a bit. If luck is not on your side that day and you missed a terrific talk, you will naturally hear about it from others and you will have plenty of time to binge-watch it on Youtube later on. Having that in mind, I was much more relax at this conference than I was at my very intense days at &lt;strong&gt;Meeting C++&lt;/strong&gt;. If you really dislike to choose you will anyway ends-up following someone, you just chit-chated with within the corridors, to the talk of his choice. Which brings us to the second advice you should follow...&lt;/li&gt;
&lt;li&gt;Engage with the community! If you are planning to go to CppCon to appreciate a better version of the talks than on YouTube, you are doing it wrong! By going over there, you actually loose the possibility to watch the talk at your own pace... What you gain instead, as an attendee, is the opportunity to mingle with people with very different backgrounds, exchange tips and tricks and feel part of community bigger than the few C++ colleagues you are working with. Programmers seldom have the reputation of being extroverts, but you will always find someone that can introduce to his connections and slowly build relationships. I met quite a few people from &lt;strong&gt;SwedenCpp&lt;/strong&gt; over there and it was really fun to see them in another context!&lt;/li&gt;
&lt;li&gt;Be confused! You should not be afraid to be out of your confort zone when it comes to the content of the talks. You may be mortified at the idea that a guru will suddenly drop a very complicated C++ concept on stage, and you will be there lonely, not knowing what on earth he/she/it is talking about. Truth is, very few people (if not none) can claim knowing everything about such a vaste language that is C++. Usually during a "productive" C++ conference, you will dress-up a list of keywords / ideas that you will explore later-on. This year, I promised myself to look further on the edge-cases of Class Template Argument Deduction (CTAD), prepare myself for C++20's &lt;strong&gt;contracts&lt;/strong&gt; and play with clang's tooling internals.&lt;/li&gt;
&lt;li&gt;Be bold! The concentration of "legendary C++ devs" per square meter is even higher than in &lt;strong&gt;Meeting C++&lt;/strong&gt;. While I did not shoot any selfie (not that I wanted to either) with any of these legends, I discussed briefly with few of them, and you can too! People at &lt;strong&gt;CppCon&lt;/strong&gt; are here to celebrate their favorite language, not to act as elitists, which make everyone very approachable. One of the talk I attended was on a &lt;a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0052r8.pdf"&gt;proposal&lt;/a&gt; (Woes of Scope Guards and Unique Resource - 5+ years in the making - By Peter Sommerland) I implemented at work. During the talk, Peter mentioned a relatively serious bug introduced in one of the revision. Right after that talk, I had the unique chance to have a face-to-face discussion with him. It turns out, my implementation did not suffer from that bug, but was instead hiding another one. I was so glad that I could access to that person so easily! &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Following these precepts, I experienced a very wonderful week made of C++ and human interactions, and I would highly recommend &lt;strong&gt;CppCon&lt;/strong&gt; to anyone having a slight interest in the language.&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img width=50% height=50% src="https://jguegant.github.io/blogs/tech/images/cppcon.jpg"/&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;I still have one and only one complain about the event: the time slot for the lightning talks.
For those that are not aware, the lightning talks are short presentations of roughly 5min, easier to submit, often light-minded but also damn interesting.
Due to the short format, people often go straight to the point which is really pleasant to watch.
For instance, this year there was an epic lightning talk battle on &lt;a href="https://arne-mertz.de/2018/05/trailing-return-types-east-const-and-code-style-consistency/"&gt;East Const vs West Const&lt;/a&gt; or a touching "Thank You" speech from &lt;strong&gt;Dr. Walter E. Brown&lt;/strong&gt;. 
If that sounds interesting to you, you will have to stay awake from 8.30pm to 10.00pm which is where my grudge comes from.
After absorbing some C++ since roughly 9.00am, and with a pretty strong jetlag (=~9h for central Europeans) you really need to channel all your inner motivation to attend any of these late activities.
The lightning talks being such joyfull part of &lt;strong&gt;CppCon&lt;/strong&gt;, I would argue that some of them could be moved to an earlier slot in the day...&lt;/p&gt;
&lt;p&gt;Enough of my pseudo-rant on an almost perfect event and let's continue with some more concrete reporting! &lt;/p&gt;
&lt;h1&gt;The chief's suggestions of the year:&lt;/h1&gt;
&lt;p&gt;Once again, here is a menu of most of the talks I particulary enjoyed. The legend follow the same rules:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;💀 : The difficulty of the talk (💀: Begginer friendly, 💀💀: Intermediate, 💀💀💀: High exposure to C++'s dark corners)&lt;/li&gt;
&lt;li&gt;★ : My interest for the talk (★: Good talk, ★★: Tasty talk, ★★★: Legendary talk)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I promise you not to spoil everything in the talks, but simply try to give an overview of what you can expect within them or some conclusions. Although most of the talks are most likely worth to be seen, I forced my-very-subjective-self to pick very few of them. I have seen people with very different "favorite talk" and you should not feel sad if your own talk is not part of this not-so-prestigious list.&lt;/p&gt;
&lt;h3&gt;[Keynote] Concepts: The Future of Generic Programming (the future is here) - Bjarne Stroustrup - 💀★★★:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Slides: &lt;a href="https://github.com/CppCon/CppCon2018/blob/master/Keynotes/concepts_the_future_of_generic_programming/concepts_the_future_of_generic_programming__bjarne_stroustrup__cppcon_2018.pdf"&gt;link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Video: &lt;a href="https://youtu.be/HddFGPTAmtU"&gt;link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The Bjarne himself, creator of C++ (for those really out of the loop), kick-started the conference with a keynote on a long-overdue C++ feature: &lt;a href="https://en.wikipedia.org/wiki/Concepts_(C%2B%2B)"&gt;Concepts&lt;/a&gt;.
Indeed, as early as 2003, Bjarne and some members of the committee have been pushing for Concepts as an extension to C++ templates to simplify the life of us poor template consumers.
Sadly, a first version, dimmed too complicated, of the feature was rejected for &lt;strong&gt;C++11&lt;/strong&gt;. Nine years later, Bjarne and his crew is back with a version "Concepts Lite" that will be integrated into &lt;strong&gt;C++20&lt;/strong&gt;.  &lt;/p&gt;
&lt;p&gt;Let's face it, C++ templates have always been a pain to use due to the absence of constraints on the template parameter types.
Take a look at this very simple piece of code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;print&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Your never-satisfied compiler will refuse to compile it with the following error message:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;&amp;lt;source&amp;gt;: In instantiation of &amp;#39;void foo(T&amp;amp;&amp;amp;) [with T = A&amp;amp;]&amp;#39;:&lt;/span&gt;
&lt;span class="err"&gt;&amp;lt;source&amp;gt;:10:8:   required from &amp;#39;void bar(T&amp;amp;&amp;amp;) [with T = A&amp;amp;]&amp;#39;&lt;/span&gt;
&lt;span class="err"&gt;&amp;lt;source&amp;gt;:17:10:   required from here&lt;/span&gt;
&lt;span class="err"&gt;&amp;lt;source&amp;gt;:5:7: error: &amp;#39;struct A&amp;#39; has no member named &amp;#39;print&amp;#39;&lt;/span&gt;
&lt;span class="err"&gt;     t.print();&lt;/span&gt;
&lt;span class="err"&gt;     ~~^~~~~&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This is an horrifying warning message as we often see nowadays.
Your compiler do warn you about the absence of a &lt;strong&gt;print&lt;/strong&gt; method in &lt;strong&gt;A&lt;/strong&gt; far down in &lt;strong&gt;foo&lt;/strong&gt;!
In this specific case, we only have two layers in the call stack which is very reasonable. 
But most often when using functions provided by the Standard Library, your type will violate some constraints reaaallly deep down.
As a newcommer you will often struggle with your compiler vomiting a bizarre message of 100 lines when using templates, which is not the best first experience (to say the least). 
Moreover, by looking at the signature of &lt;strong&gt;bar&lt;/strong&gt;, nothing tells you that the template parameter &lt;strong&gt;T&lt;/strong&gt; needs to have a &lt;strong&gt;print&lt;/strong&gt; member function. That's frustrating!&lt;/p&gt;
&lt;p&gt;With concepts you can define in elegant way the constraints that your parameters must respect. Have a look at we could do with Concepts in this case:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;concept&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;IsPrintable&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;requires&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// Define a reusable concept &amp;quot;IsPrintable&amp;quot;.&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;print&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// Any template parameter of T respecting &amp;quot;IsPrintable&amp;quot; must have a print function. &lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;IsPrintable&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="c1"&gt;// Explicitely tells that T must respect the concept.&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;print&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;IsPrintable&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="c1"&gt;// Same here!&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Which would give us the following much more accurate error message:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;&amp;lt;source&amp;gt;:19:10: error: cannot call function &amp;#39;void bar(T&amp;amp;&amp;amp;) [with T = A&amp;amp;]&amp;#39;&lt;/span&gt;
&lt;span class="err"&gt;     bar(a);&lt;/span&gt;
&lt;span class="err"&gt;          ^&lt;/span&gt;
&lt;span class="err"&gt;&amp;lt;source&amp;gt;:11:6: note:   constraints not satisfied&lt;/span&gt;
&lt;span class="err"&gt; void bar(T&amp;amp;&amp;amp; t) {&lt;/span&gt;
&lt;span class="err"&gt;      ^~~&lt;/span&gt;
&lt;span class="err"&gt;&amp;lt;source&amp;gt;:1:33: note: within &amp;#39;template&amp;lt;class T&amp;gt; concept const bool IsPrintable&amp;lt;T&amp;gt; [with T = A&amp;amp;]&amp;#39;&lt;/span&gt;
&lt;span class="err"&gt; template &amp;lt;class T&amp;gt; concept bool IsPrintable = requires (T a) {&lt;/span&gt;
&lt;span class="err"&gt;                                 ^~~~~~~~~~~&lt;/span&gt;
&lt;span class="err"&gt;&amp;lt;source&amp;gt;:1:33: note:     with &amp;#39;A&amp;amp; a&amp;#39;&lt;/span&gt;
&lt;span class="err"&gt;&amp;lt;source&amp;gt;:1:33: note: the required expression &amp;#39;a.print()&amp;#39; would be ill-formed&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Some sceptical gurus will tell you that this can be emulated with some witch-crafted &lt;a href="https://jguegant.github.io/blogs/tech/sfinae-introduction.html"&gt;SFINAEs&lt;/a&gt;. 
Concepts were not on my christmas wish-list for &lt;strong&gt;C++&lt;/strong&gt; this year, but I have to admit that Bjarne's talk hipped me a lot! &lt;/p&gt;
&lt;h3&gt;[Talk] How to Write Well-Behaved Value Wrappers - Simon Brand - 💀💀💀 ★★:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Slides: &lt;a href=""&gt;coming soon&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Video: &lt;a href=""&gt;coming soon&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Good speakers are like good wine, you are seldom disappointed.
Having attended Simon's talk on debugger internals last year and enjoyed it a lot, I took the chance to hear what he had to say on value wrappers.
You may not know what is a value wrapper, but I surely bet that you already manipulated some provided by the Standard Library: &lt;a href="https://en.cppreference.com/w/cpp/utility/pair"&gt;std::pair&lt;/a&gt;, &lt;a href="https://en.cppreference.com/w/cpp/utility/tuple"&gt;std::tuple&lt;/a&gt;, &lt;a href="https://en.cppreference.com/w/cpp/utility/optional"&gt;std::optional&lt;/a&gt;... &lt;/p&gt;
&lt;p&gt;It might be a breeze to work with most of these wrappers (certainely not you verbose &lt;a href="https://en.cppreference.com/w/cpp/utility/variant"&gt;std::variant&lt;/a&gt;), but the poor souls writting implementations of these must go to great lengths to make them behave as they should. Value wrappers, as their name imply, try to mimic as closely as possible the type of a given value. All the types have some basic properties: can it be explicitely constructed? Are the &lt;a href="https://en.wikipedia.org/wiki/Special_member_functions"&gt;special member functions&lt;/a&gt; noexcept? Can it be called in a constant expression? Can it be compared? And much more... A wrapper must react exactly in the same way when it comes to these properties. &lt;/p&gt;
&lt;p&gt;In this talk, Simon compares the old fashioned way to tackle these issues and present how it will look like as soon as the concepts and a bunch of other proposals arrive in C++20:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Explicit operator akin to the noexcept operator&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0848r0.html"&gt;P0748R0&lt;/a&gt; to use &lt;strong&gt;concepts-based require clauses&lt;/strong&gt; on these member functions to enable or disable them. A.K.A goodbye a lot of uncessarry conditional inheritance. &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0847r0.html"&gt;P0847R0&lt;/a&gt; which permits to deduce correctly the implicit &lt;strong&gt;this&lt;/strong&gt; parameter type of a member function. A.K.A goodbye all the methods overloading on const, volatile and ref qualifiers. &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0515r2.pdf"&gt;P0515R2&lt;/a&gt; that unify all the comparison operators into one. A.K.A goodbye all the operator overloads.&lt;/li&gt;
&lt;li&gt;... Some more that I surely forgot.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Regardless if you are planning to write such wrappers or not, I would suggest to watch the talk to refresh yourself on some tricky C++ mechanisms.&lt;/p&gt;
&lt;h3&gt;[Talk] Fancy Pointers for Fun and Profit - Bob Steagall - 💀💀 ★★:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Slides: &lt;a href="https://github.com/CppCon/CppCon2018/blob/master/Presentations/fancy_pointers_for_fun_and_profit/fancy_pointers_for_fun_and_profit__bob_steagall__cppcon_2018.pdf"&gt;link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Video: &lt;a href=""&gt;coming soon&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Bob Steagall&lt;/strong&gt; promoted his own talk on &lt;strong&gt;fancy pointers&lt;/strong&gt; in an early September &lt;strong&gt;CppCast&lt;/strong&gt; episode.
So here I was, ready to learn more about these mystical beasts!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Allocators&lt;/strong&gt; in C++ are rather infamous for their over-engineered interface, which is not useful 99.42% of the time. This even forced the committee to come-up, in &lt;strong&gt;C++17&lt;/strong&gt;, with a lighter interface called &lt;a href="https://youtu.be/v3dz-AKOVL8"&gt;PMR&lt;/a&gt;. But this time, the good old full-blown interface found a very clever usage in Bob's hands. Indeed, &lt;a href="https://en.cppreference.com/w/cpp/memory/allocator_traits"&gt;std::allocator_traits&lt;/a&gt; has a nice type property &lt;strong&gt;pointer&lt;/strong&gt;. Which means that the Standard offers a nice &lt;a href="https://quuxplusone.github.io/blog/2018/03/19/customization-points-for-functions/"&gt;customization point&lt;/a&gt; to switch normal pointers &lt;strong&gt;T*&lt;/strong&gt; for a given allocator to a type that acts like a pointer would. These wanna-be pointers are what you call &lt;strong&gt;fancy pointers&lt;/strong&gt;. Somehow, you can think of &lt;strong&gt;fancy pointers&lt;/strong&gt; as more generalized concept of &lt;a href="https://en.wikipedia.org/wiki/Smart_pointer"&gt;smart pointers&lt;/a&gt;.   &lt;/p&gt;
&lt;p&gt;Now let's say that you would like to serialise to / deserialise from binary a container-like object (vector, list...) with a bunch of &lt;a href="https://msdn.microsoft.com/en-us/library/mt767760.aspx?f=255&amp;amp;MSPPError=-2147217396"&gt;trivial objects&lt;/a&gt; inside and send it through a network. Providing that you are targeting one and only one architecture, which is often the case for servers, you may be able to use &lt;a href="https://en.cppreference.com/w/cpp/string/byte/memcpy"&gt;std::memcpy&lt;/a&gt; to transfer the representation of this container into a &lt;strong&gt;char*&lt;/strong&gt; buffer. Then, the whole buffer can be wired to another machine. At the endpoint, to deserialise the container from that buffer you can re-use &lt;strong&gt;std::memcpy&lt;/strong&gt; to copy back the binary representation into a container (&lt;a href="https://www.reddit.com/r/cpp/comments/5fk3wn/undefined_behavior_with_reinterpret_cast/"&gt;note that you cannot rely reinterpret_cast in C++ for that purpose&lt;/a&gt;...). This will work smoothly as long as none of the stored PODs have pointers as members referencing each others! Pointers are usually not valid as soon as you cross the boundary of a process or a machine. This huge drawback can be avoided by introducing &lt;strong&gt;fancy pointers&lt;/strong&gt; to your code-base. &lt;/p&gt;
&lt;p&gt;As an example on how to fix that issue, Bob brings &lt;strong&gt;offset_ptr&lt;/strong&gt; to the table, which permits to express some reference between two elements using their distance from each others:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;
&lt;span class="err"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;value_type&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;offset_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;value_type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="n"&gt;optional&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 

&lt;span class="n"&gt;Example&lt;/span&gt; &lt;span class="k"&gt;of&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;layout&lt;/span&gt; &lt;span class="k"&gt;of&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;container&lt;/span&gt; &lt;span class="k"&gt;of&lt;/span&gt; &lt;span class="n"&gt;objs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;

                               &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;
                &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="c1"&gt;-----------------------------+&lt;/span&gt;
                &lt;span class="o"&gt;|&lt;/span&gt;        &lt;span class="mi"&gt;1&lt;/span&gt;                    &lt;span class="o"&gt;|&lt;/span&gt;
                &lt;span class="o"&gt;|&lt;/span&gt;     &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="c1"&gt;-----+                 |&lt;/span&gt;
 &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="c1"&gt;--------------v-----------v--------------------------------+&lt;/span&gt;
 &lt;span class="o"&gt;|&lt;/span&gt;  &lt;span class="n"&gt;v&lt;/span&gt;  &lt;span class="o"&gt;|&lt;/span&gt;  &lt;span class="n"&gt;p&lt;/span&gt;  &lt;span class="o"&gt;|&lt;/span&gt;  &lt;span class="n"&gt;v&lt;/span&gt;  &lt;span class="o"&gt;|&lt;/span&gt;  &lt;span class="n"&gt;p&lt;/span&gt;  &lt;span class="o"&gt;|&lt;/span&gt;  &lt;span class="n"&gt;v&lt;/span&gt;  &lt;span class="o"&gt;|&lt;/span&gt;  &lt;span class="n"&gt;p&lt;/span&gt;  &lt;span class="o"&gt;|&lt;/span&gt;  &lt;span class="n"&gt;V&lt;/span&gt;  &lt;span class="o"&gt;|&lt;/span&gt;  &lt;span class="n"&gt;p&lt;/span&gt;  &lt;span class="o"&gt;|&lt;/span&gt;  &lt;span class="n"&gt;v&lt;/span&gt;  &lt;span class="o"&gt;|&lt;/span&gt;  &lt;span class="n"&gt;p&lt;/span&gt;  &lt;span class="o"&gt;|&lt;/span&gt;
 &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="c1"&gt;-----------------------------------------------------------+&lt;/span&gt;
          &lt;span class="o"&gt;|&lt;/span&gt;                             &lt;span class="o"&gt;^&lt;/span&gt;
          &lt;span class="o"&gt;|&lt;/span&gt;                             &lt;span class="o"&gt;|&lt;/span&gt;
          &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="c1"&gt;-----------------------------+&lt;/span&gt;
                       &lt;span class="mi"&gt;3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;With a bit of boilerplate, this &lt;strong&gt;offset_ptr&lt;/strong&gt; can be handled by a custom allocator that can be injected into a container, making different address mappings a non-issue.
I find this solution pretty elegant and is a good showcase on how extensible the Standard Library is. &lt;/p&gt;
&lt;h3&gt;[Talk] RVO is Harder than it Looks: the story of -Wreturn-std-move - Arthur O'Dwyer - 💀💀 ★:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Slides: &lt;a href="https://github.com/CppCon/CppCon2018/blob/master/Presentations/return_value_optimization_harder_than_it_looks/return_value_optimization_harder_than_it_looks__arthur_odwyer__cppcon_2018.pdf"&gt;link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Video: &lt;a href=""&gt;coming soon&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It is commonly admitted that returning by value seldom has a performance impact in C++. Two mechanisms &lt;a href="https://en.wikipedia.org/wiki/Copy_elision#Return_value_optimization"&gt;(N)RVO&lt;/a&gt; and &lt;a href="http://thbecker.net/articles/rvalue_references/section_02.html"&gt;move semantics&lt;/a&gt; will most likely kick in to avoid unecessary copies:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="c1"&gt;// ... some members&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;// ...&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// The return value is directly constructed in a&amp;#39;s stack location (RVO), can fall back onto the move-constructor otherwise. &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As time goes by, the C++ standard has stronger and stronger guarantees that copy ellision (RVO) will happen in these situations.
At the same time, forcefully moving the return value can a pretty huge pessimisation and is taught as an anti-pattern:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;// ...&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;move&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Will hinder the compiler to choose RVO instead of move constructor.&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In the worst case scenario, if the object has no move-constructor, the compiler might resort to use the copy constructor, which could have been avoided with RVO.&lt;/p&gt;
&lt;p&gt;Now in the &lt;strong&gt;C++ land&lt;/strong&gt; nothing really holds true if you look closer at some corner cases. And the "no-move-on-return-values" rule mentioned right above can be debated for that reason. Arthur was valiant enough to inquire into this topic and found few cases where a call to &lt;strong&gt;std::move&lt;/strong&gt; will BE an optimization. Notably, if you return a value with a type convertible to the function's return type thanks to an &lt;a href="https://en.cppreference.com/w/cpp/language/cast_operator"&gt;explicit conversion operator&lt;/a&gt;, you should apply &lt;strong&gt;std::move&lt;/strong&gt;. Arthur introduced a new warning in clang &lt;a href="https://reviews.llvm.org/D43322"&gt;-Wreturn-std-move&lt;/a&gt; to avoid this pitfall. I will gadly turn that warning on as soon as I can.&lt;/p&gt;
&lt;p&gt;I liked the talk for delving into such precise topics ; although, Arthur rushed on quite a few slides and even skipped a whole bunch of them, meaning that there was more to say on this theme. &lt;/p&gt;
&lt;h3&gt;[Talk] State Machines Battlefield - Naive vs STL vs Boost - Kris Jusiak - 💀💀 ★:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Slides: &lt;a href="https://github.com/CppCon/CppCon2018/blob/master/Presentations/state_machines_battlefield_naive_vs_stl_vs_boost/state_machines_battlefield_naive_vs_stl_vs_boost__kris_jusiak__cppcon_2018.pdf"&gt;link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Video: &lt;a href="https://www.youtube.com/watch?v=yZVby-PuXM0"&gt;link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Kris Jusiak&lt;/strong&gt; is the proud author of two library aspiring to be into &lt;a href="https://www.boost.org/"&gt;Boost&lt;/a&gt;: &lt;a href="http://boost-experimental.github.io/di/"&gt;Boost.DI&lt;/a&gt; and &lt;a href="https://github.com/boost-experimental/sml"&gt;Boost.SML&lt;/a&gt;. This talk was partly based on the later one. More precisely &lt;strong&gt;Kris&lt;/strong&gt; compared how different implementations of a state machine would fare in term of performance and ease to maintain.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Kris&lt;/strong&gt; started with a good ol' implementation designed around a giant switch case roughly similar to this code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;connection&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// ...&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;event&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;switch&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;state_&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nl"&gt;connecting&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;event_type&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;established&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                    &lt;span class="n"&gt;state_&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;connected&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
                    &lt;span class="n"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;connected&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
                &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nl"&gt;connected&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="c1"&gt;// ...&lt;/span&gt;
                &lt;span class="n"&gt;do_connected_things&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
                &lt;span class="c1"&gt;// ...&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="c1"&gt;// ...&lt;/span&gt;
            &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="n"&gt;runtime_exception&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;bad state&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="c1"&gt;// ...&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;variable_for_connected_state&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;another_variable_for_connected_state&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;variable_for_disconnected_state&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;// ...&lt;/span&gt;
    &lt;span class="n"&gt;state&lt;/span&gt; &lt;span class="n"&gt;state_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Surely, this implementation will perform rather decently, but at the cost of being extremely hard to maintain if the amount of states increase. Sadly, a lot of code-bases for games or networking have plenty of these ugly state machines sprinkled around. &lt;strong&gt;C++&lt;/strong&gt; is all about &lt;strong&gt;zero-cost abstractions&lt;/strong&gt;, which means that if you want to avoid some serious posttraumatic stress disorders after working on such projects, you may want to look at other choices than switch.&lt;/p&gt;
&lt;p&gt;Therefore, &lt;strong&gt;Kris&lt;/strong&gt; jumped onto other implementations. One of the them is using &lt;a href="https://en.cppreference.com/w/cpp/utility/variant"&gt;std::variant&lt;/a&gt; which reminded me a lot a blog post from &lt;a href="https://khuttun.github.io/2017/02/04/implementing-state-machines-with-std-variant.html"&gt;Kalle Huttunen&lt;/a&gt;. &lt;strong&gt;std::variant&lt;/strong&gt; will permit you to isolate the variables necessary for your different states and will enforce a stricter handling of your state with &lt;a href="https://en.cppreference.com/w/cpp/utility/variant/visit"&gt;std::visit&lt;/a&gt;. In my opinion this solution is huge improvement compared to using a switch and does not require the introduction of an external library into your project. As I will explain later, &lt;strong&gt;std::variant&lt;/strong&gt; may or may not have a slight performance impact.&lt;/p&gt;
&lt;p&gt;After dwelling with two oldish and rather slow Boost libraries that can help to design state machines, Kris presented us his work. I have to admit that the &lt;a href="https://en.wikipedia.org/wiki/Domain-specific_language"&gt;DSL&lt;/a&gt; provided by his library looks very pleasant to use: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// Coming straight from Kris&amp;#39;s slides:&lt;/span&gt;
&lt;span class="n"&gt;sml&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;sm&lt;/span&gt; &lt;span class="n"&gt;connection&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]{&lt;/span&gt;
    &lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;sml&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;transition_table&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Disconnected&amp;quot;&lt;/span&gt;&lt;span class="n"&gt;_s&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;connect&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;establish&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Connecting&amp;quot;&lt;/span&gt;&lt;span class="n"&gt;_s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;Connecting&amp;quot;&lt;/span&gt;&lt;span class="n"&gt;_s&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;established&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Connected&amp;quot;&lt;/span&gt;&lt;span class="n"&gt;_s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;Connected&amp;quot;&lt;/span&gt;&lt;span class="n"&gt;_s&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;ping&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="n"&gt;is_valid&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;reset_timeout&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;Connected&amp;quot;&lt;/span&gt;&lt;span class="n"&gt;_s&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;timeout&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;establish&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Connecting&amp;quot;&lt;/span&gt;&lt;span class="n"&gt;_s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;Connected&amp;quot;&lt;/span&gt;&lt;span class="n"&gt;_s&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;disconnect&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;close&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Disconnected&amp;quot;&lt;/span&gt;&lt;span class="n"&gt;_s&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;Boost.DI&lt;/strong&gt; is performing very well according to Kris and is on par with the switch solution according to his benchmark.
&lt;strong&gt;Boost.DI&lt;/strong&gt; offers different dispatch strategies to get the current state:  &lt;strong&gt;recursive branching&lt;/strong&gt;, &lt;a href="https://mpark.github.io/programming/2015/07/07/variant-visitation/"&gt;jump table&lt;/a&gt;, &lt;a href="https://en.cppreference.com/w/cpp/language/fold"&gt;fold expressions&lt;/a&gt;... It turns out that the &lt;strong&gt;recursive branching&lt;/strong&gt; is amongst the fastest, yelding results as close as the giant switch strategy. I am not so surprised by these results, since we observed a similar pattern at work with our custom implementation of &lt;strong&gt;std::visit&lt;/strong&gt;. As far as I know, &lt;strong&gt;clang&lt;/strong&gt; and &lt;strong&gt;gcc&lt;/strong&gt; visit their &lt;strong&gt;std::variant&lt;/strong&gt; using a &lt;strong&gt;jump table&lt;/strong&gt;, which may explain the slight performance drop compared to a giant switch. These are good news though, it means that there is room to improve the Quality of Implementation (QoI) of &lt;strong&gt;std::visit&lt;/strong&gt; in our favorite libraries.  &lt;/p&gt;
&lt;h3&gt;[Talk] Compile-time programming and reflection in C++20 and beyond - Louis Dionne - 💀💀💀 ★★★:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Slides: &lt;a href=""&gt;coming soon&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Video: &lt;a href="https://www.youtube.com/watch?v=CRDNPwXDVp0"&gt;link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Three skulls, three stars, nothing unusual when it comes to my judgement on &lt;strong&gt;Louis Dionne's&lt;/strong&gt; talks. I am very fond of (template) meta-programming, and I have always been in awe of Louis's work on &lt;a href="https://www.boost.org/doc/libs/1_61_0/libs/hana/doc/html/index.html"&gt;Boost.Hana&lt;/a&gt; and more recently &lt;a href="https://github.com/ldionne/dyno"&gt;dyno&lt;/a&gt;. This year, he was on stage to give us an overview on what we could expect in the upcomming standards concerning &lt;a href="https://en.cppreference.com/w/cpp/language/constexpr"&gt;constexpr&lt;/a&gt;, and how this would unlock a better interface for reflection.&lt;/p&gt;
&lt;p&gt;We are slowly but surely reaching the point where we will be able to "allocate" at compile-time and convert most of our code-bases to &lt;strong&gt;constexpr&lt;/strong&gt; within a blink. Louis explained what are the necessary changes we need to apply to &lt;a href="https://en.cppreference.com/w/cpp/language/constexpr"&gt;constexpr&lt;/a&gt; to be able to use it in expressions where we do allocate:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Allowing constexpr non-trivial destructors, allowing heap allocation and placement new that you will find in &lt;a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0784r0.md"&gt;P0784R0&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Having the new trait &lt;strong&gt;std::is_constant_evaluated&lt;/strong&gt; from &lt;a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0595r1.html"&gt;P0595R0&lt;/a&gt; that queries whether the compiler is currently evaluating the function in a constexpr context or not. Surprisingly, you will NOT use that trait within a &lt;strong&gt;if constexpr&lt;/strong&gt; statement ; this would always be evaluated as constexpr and return &lt;strong&gt;true&lt;/strong&gt;, a simple &lt;strong&gt;if&lt;/strong&gt; does the job. This trait is an absolute necessity if we want to share a single interface for both a &lt;strong&gt;constexpr&lt;/strong&gt; and runtime implementation of a feature (a std::vector...). Behind the scene, &lt;strong&gt;constexpr&lt;/strong&gt; code usually has very different demands to perform corretly than standard runtime code.  &lt;/li&gt;
&lt;li&gt;Support &lt;strong&gt;try-catch&lt;/strong&gt; statements within a &lt;strong&gt;constexpr&lt;/strong&gt; expression which we would get from &lt;a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1002r0.pdf"&gt;P1002R0&lt;/a&gt;. Note that this does imply that the compiler&lt;/li&gt;
&lt;li&gt;Some other minor changes that must appear in some other hairy white papers ...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Taking all these changes in consideration, we should be able to slap &lt;strong&gt;constexpr&lt;/strong&gt; on many containers and algorithms from the STL (vector, string...). That would make the usage of &lt;strong&gt;constexpr&lt;/strong&gt; very trivial to any decent &lt;strong&gt;C++&lt;/strong&gt; developer.&lt;/p&gt;
&lt;p&gt;It will also be a great paradigm shift for the planned reflection within the language. The standard committee used to formulate a reflection proposal based on &lt;strong&gt;template meta-programming&lt;/strong&gt;, which dreadfully reminds you some kind of &lt;a href="https://www.boost.org/doc/libs/1_68_0/libs/mpl/doc/index.html"&gt;Boost.MPL&lt;/a&gt;. 
While templates are powerfull, the syntax to manipulate types appears alienesque to most of the human coders. 
&lt;strong&gt;Constexpr-based metaprogramming&lt;/strong&gt; looks a lot more natural and having proper containers was the last missing part of the puzzle to use that syntax for reflection. 
If you are in doubt, have a look at this very short example from Louis: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;my_struct&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="c1"&gt;// Get the type of the first member of my_struct using the old template-based syntax:&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;my_struct_meta&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;reflexpr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;my_struct&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;members&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;reflect&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;get_data_members_t&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;my_struct&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Some weird template list-like type.&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;x_meta&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;reflect&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;get_element_t&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;members&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Some ideaous index accessor.&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;x_type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;reflect&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;get_reflected_type_t&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;x_meta&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// Get the type of the first member of my_struct with the new fancy constexpr-based syntax:&lt;/span&gt;
&lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;reflect&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Record&lt;/span&gt; &lt;span class="n"&gt;my_struct_meta&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;reflexp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;my_struct&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt; &lt;span class="n"&gt;members&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;my_struct_meta&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_data_members&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// Uses the good ol&amp;#39; vector and class template argument deduction guides from C++17.&lt;/span&gt;
&lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;reflect&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;RecordMember&lt;/span&gt; &lt;span class="n"&gt;x_meta&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;members&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="c1"&gt;// Just use the operator[] as usual... &lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;unreflexpr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x_meta&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_reflected_type&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt; &lt;span class="c1"&gt;// Get that actual type of x.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If you want to have a better understanding on the proposed syntax, have a look at &lt;a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0953r0.html"&gt;P0962R0&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;[Keynote] Thoughts on a More Powerful and Simpler C++ (5 of N) - Herb Sutter - 💀💀 ★★★:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Slides: &lt;a href=""&gt;coming soon&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Video: &lt;a href="https://www.youtube.com/watch?v=80BZxujhY38"&gt;link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The last two years, at CppCon, Herb brought us his vision on a future &lt;strong&gt;C++&lt;/strong&gt; full of promises.
Both of these talks were accompanied with some concrete actions (white-papers, guidelines, proof-of-concepts..) that Herb was working on with the rest of the fellowship of the C++s. This year, Herb shared with us some more results on his goals.
It might not sound like a thrilling talk... but that would be under-appreciating the two main ideas Herb was initially pushing for: lifetimes and meta-classes.&lt;/p&gt;
&lt;p&gt;Lifetimes are some implicit or explicit rules that directly concern the ownership of an object.
If such lifetime rules are adjusted correctly, your code should be bulletproof when it comes to a huge range of bugs related to memory: user after free, dandling pointers...
Some languages like &lt;strong&gt;Rust&lt;/strong&gt; even make it a core concept of the language. Arguably, Herb's lifetimes will be slightly more relaxed (no annotations on everything) and more natural to use, at the price of not covering some extreme cases. 
Let's have a look at what these so-called lifetimes may protect you from:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Oups I am returning a reference to a local variable that will die right after that function execution.&lt;/span&gt;
    &lt;span class="c1"&gt;// Some compilers may warn you about it, some may not! &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;reference_wrapper&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;reference_wrapper&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Same issue. No compiler warns you about it! &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;After applying the rules elaborated by Herb and his crew, the lifetime of &lt;strong&gt;a&lt;/strong&gt; would be dimmed as ending at the end of foo and the compiler would yield a strong warning or a plain error.
Here &lt;a href="https://en.cppreference.com/w/cpp/utility/functional/reference_wrapper"&gt;std::reference&lt;/a&gt; is considered as a pointer/reference type and will be highly scrutinised by the compiler.
If you combine the lifetimes and the concepts, your compiler or linter may be able to discover the pointer types automagically!&lt;/p&gt;
&lt;p&gt;Another trivial bug yet often spawning nastily in your code is the dreaded "use-after-move" situation. Here again, lifetimes would avoid an easy shoot in the feet situation:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;my_class&lt;/span&gt; &lt;span class="n"&gt;my_obj&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;my_class&lt;/span&gt; &lt;span class="n"&gt;another_obj&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;move&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;my_obj&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;my_obj&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;bla&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// lifetime warning: using a moved-from obj is seldom a good idea.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;All these smart lifetime rules are often based on recommendations that you may find in &lt;a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines"&gt;C++ Core Guidelines&lt;/a&gt;.
Having them enforced within your projects is amazing. I am eager to try the clang implementation of it. Later in the day &lt;strong&gt;Matthias Gehre&lt;/strong&gt; and &lt;strong&gt;Gabor Horvath&lt;/strong&gt; did show us the internals of clang that will support this new feature.&lt;/p&gt;
&lt;p&gt;After mesmering the crowd with the lifetimes, Herb gave us some updates on the &lt;a href="https://www.youtube.com/watch?v=4AfRAVcThyA&amp;amp;t=4016s"&gt;meta-classes&lt;/a&gt;, which were mainly some changes in the syntax.
While I really appreciate the efforts put into &lt;strong&gt;meta-classes&lt;/strong&gt;, I still have doubts that I will enjoy such a feature before I am retiring (roughly in 50 years from now). The lifetimes were much more concrete and fathomable when it comes to my daily C++ life.  &lt;/p&gt;
&lt;h3&gt;[Talk] Better C++ using Machine Learning on Large Projects - Nicolas Fleury and Mathieu Nayrolles - 💀 ★:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Slides: &lt;a href="https://github.com/CppCon/CppCon2018/blob/master/Presentations/better_cpp_using_machine_learning_on_large_projects/better_cpp_using_machine_learning_on_large_projects__nicolas_fleury_mathieu_nayrolles__cppcon_2018.pdf"&gt;link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Video: &lt;a href=""&gt;coming soon&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can certainely rely on C++ to improve your AI projects, but can you use an AI or machine learning to improve your C++ project?
The two "cousin-frenchies" &lt;strong&gt;Nicolas&lt;/strong&gt; and &lt;strong&gt;Mathieu&lt;/strong&gt; had the smart idea to detect bugs in pull-requests using some kind of machine learning that analyse previously reported issues in their code-base.&lt;/p&gt;
&lt;p&gt;The presentation did not contain much of actual C++ code, but was more focused on the process they invented to automatically fetch, analyse and post feedback on any submitted code.
I am not an expert on these topics and would not dare to emit any comment on what they presented us.
It seems that after training, the classifying algorithm they put in place was able to predict with a success rate of 70% whether a piece of code would have a negative impact or not.
Their next step would be to add some automatic code correction facilities by applying machine learning on the fixed cases.
Triple A games tend to reuse a lot of variations of the same code across multiple titles, WITHOUT actually sharing it (new games are just cloned from old ones). With this process in place, the projects are spreading the awareness of some issues very easily. It seems like a huge time saver.&lt;/p&gt;
&lt;p&gt;In any case, it was a breeze to attend a slightly less C++ oriented talk.
There was a lot of questions regarding the human aspect of that technology.
Is 70% of success rate high enough not to piss-off the users experimenting with the bot?
My experience is that a lot of false positive in a linter, will invariably make people turn it off at the earliest opportunity...
Would you be able to spot the bad programmers in your team with such a tool? Thanksfully, the labor rights in Canada (Montréal) should protect the employees on that topic...
And many other interesting facts that you can discover in the video.&lt;/p&gt;
&lt;h3&gt;[Talk] Class Template Argument Deduction for Everyone - Stephan T. Lavavej - 💀💀 ★★:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Slides: &lt;a href="https://github.com/CppCon/CppCon2018/blob/master/Presentations/class_template_argument_deduction_for_everyone/class_template_argument_deduction_for_everyone__stephan_t_lavavej__cppcon_2018.pdf"&gt;link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Video: &lt;a href=""&gt;coming soon&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="https://en.cppreference.com/w/cpp/language/class_template_argument_deduction"&gt;Class Template Argument Deduction&lt;/a&gt;, also known as CTAD, is new tiny feature added into the C++17.
While not being an amazing game changer, CTAD can been seen as some very tasty syntaxic sugar that avoid you to specific the template argument of a class template when instantiating it.
In other simpler words: it can avoid you to call &lt;strong&gt;make_xxx&lt;/strong&gt; function when there is enough information for the compiler to deduce the template paramters of a class template.
Here is what the CTAD lipstick looks like on &lt;a href="https://en.cppreference.com/w/cpp/utility/pair"&gt;std::pair&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// Before C++17:&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;pair&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;p1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;test&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;p2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;make_pair&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;test&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// After C++17, with CTAD:&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;pair&lt;/span&gt; &lt;span class="n"&gt;p3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;test&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;// No needs to specify the template argument &amp;quot;int&amp;quot; and &amp;quot;const char*&amp;quot;.&lt;/span&gt;
&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;p4&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;pair&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;test&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Another way to construct following the always auto rule.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In many instances, you do not have to update your class template to benefit from CTAD.
But when you do, one must understand how to help the compiler using some deduction guides.
&lt;strong&gt;STL&lt;/strong&gt;'s (known as Stephan T. Lavavej) dedicated and still dedicate his life to maintain the &lt;strong&gt;STL&lt;/strong&gt; (also known as Standard Template Library) for MSVC.
&lt;strong&gt;Stephan&lt;/strong&gt; apparently had a first hand experience on the deduction guides when adding CTAD to the standard containers in the STL and wanted to explain the gist of it.&lt;/p&gt;
&lt;p&gt;Deduction guides are "pseudo-constructors" declared out of the targeted class, that are evaluated right before going to the steps of template parameter deduction, substitution and all the subsequent mess.
When instantiating a given class, all the deduction guides follow the overload resolution and template argument deduction rules that you would expect if applied on normal functions.
The return type of the chosen deduction guide, will be the one used by the following steps.
Now this sounds very wordy, but it is actually fairly trivial to write:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; 
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;          &lt;span class="c1"&gt;// A trivial class template.    &lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;   &lt;span class="c1"&gt;// Do something with t...&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Declare a deduction guide: given a type T, I will help to deduce a foo with a first parameter being a reference to this type T. &lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Bar will be foo&amp;lt;int&amp;amp;&amp;gt; thanks to the CTAD and this deduction guide.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I chose this example as it has two interesting tidbits. First you will notice that I apply a transformation on &lt;strong&gt;T&lt;/strong&gt; in the return type: the template parameter becomes a &lt;strong&gt;T*&lt;/strong&gt;.
It turns out that you can do a lot more in this place: you can invoke &lt;s&gt;satan&lt;/s&gt; some traits or inject a SFINAE expression (Oh my...! I really have to push that idea further).
The second unexpected part is that my guide does not have the same signature as my constructor. Indeed, one takes T as an r-value reference, the other one by value.
That's really fortunate, unlike the &lt;strong&gt;make_xxx&lt;/strong&gt; functions which would take universal references and &lt;a href="https://en.cppreference.com/w/cpp/types/decay"&gt;decay&lt;/a&gt; the arguments, the deductions guides can rely on the automatic decaying of template parameters taken by value. &lt;strong&gt;Stephan&lt;/strong&gt; has a lot more of nitty-gritty details on how &lt;strong&gt;deduction guides&lt;/strong&gt; behave and it would take a full a post to explain some of them, just watch his talk instead!&lt;/p&gt;
&lt;h3&gt;[Talk] The Bits Between the Bits: How We Get to main() - Matt Godbolt - 💀💀 ★★★:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Slides: &lt;a href=""&gt;coming soon&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Video: &lt;a href=""&gt;coming soon&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Matt Godbolt&lt;/strong&gt;, author of the amazing website &lt;a href="https://godbolt.org/"&gt;godbolt.org&lt;/a&gt;, has a very pedagogic mindset and is a naturally gifted speaker (if you ever wanted to understand the &lt;a href="https://meltdownattack.com/"&gt;Meltdown Attack&lt;/a&gt;, you should make a detour on his &lt;a href="https://www.youtube.com/watch?v=IPhvL3A-e6E&amp;amp;t=692s"&gt;YouTube video&lt;/a&gt; and come back to this blog post afterwards).
This time &lt;strong&gt;Matt&lt;/strong&gt; wanted us to have a closer look at the hidden steps from the linking stage of your build until the beggining of the execution of your main entry point.
More precisely, how your linker select the symbols that will appear into your application and which are the mechanisms that allow the creation of global variables right before entering &lt;strong&gt;main&lt;/strong&gt;. &lt;/p&gt;
&lt;p&gt;Being didactic as usual, &lt;strong&gt;Matt&lt;/strong&gt; did some live debugging sessions, using GDB, objdump, readelf and such, to make us conceive how things work under the hood.
It covered the sections you can find within an application (.data, .text, ...), the &lt;a href="https://en.wikipedia.org/wiki/One_Definition_Rule"&gt;One Definition Rule&lt;/a&gt; (ODR), the linker's gathering of informations, the mysterious &lt;strong&gt;__static_initialization_and_destruction_0&lt;/strong&gt; and its associates... His approach of solving one problem at a time using simple tools make it very easy to comprehend fully what is going on in there. &lt;/p&gt;
&lt;p&gt;I made two discoveries during that one hour debugging session:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LD, the GNU linker (and very likely clang's one too) uses a &lt;a href="https://sourceware.org/binutils/docs/ld/Scripts.html"&gt;scripting language&lt;/a&gt; to define the rules for each section of your binary. I wish to never have to dabble in this language for work purpose. &lt;/li&gt;
&lt;li&gt;&lt;a href="http://man7.org/linux/man-pages/man8/ld.so.8.html"&gt;ld.so&lt;/a&gt;, the GNU dynamic linker reacts on an environment variable called &lt;strong&gt;LD_DEBUG&lt;/strong&gt;. By setting this variable to =all (or something more precise), the dynamic linker will output all operations and some extra info when loading a dynamic library. It is very convenient if you want to know which libraries get loaded by your process, which symbols it will use, etc... Here is what the output would look like if your process is somehow fetching &lt;a href="http://man7.org/linux/man-pages/man3/getenv.3.html"&gt;getenv&lt;/a&gt;:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;     15257: binding file wc [0] to /lib/x86_64-linux-gnu/libc.so.6 [0]: normal symbol `getenv&amp;#39; [GLIBC_2.2.5]
     15257: symbol=abort;  lookup in file=wc [0]
     15257: symbol=abort;  lookup in file=/lib/x86_64-linux-gnu/libc.so.6 [0]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Here we know the &lt;strong&gt;getenv&lt;/strong&gt; resides within the libc.so library which is the C runtime library.&lt;/p&gt;
&lt;h3&gt;[Other]:&lt;/h3&gt;
&lt;p&gt;Sadly, I would need to (std::)allocate myself a lot of more time to be able to cover all the goodies you can get from this &lt;strong&gt;CppCon&lt;/strong&gt;.
I have watched many different talks and had great echoes from some others. Here is what I would consider worth to google for:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Spectre: Secrets, Side-Channels, Sandboxes, and Security - by Chandler Carruth&lt;/li&gt;
&lt;li&gt;The Nightmare of Initialization in C++ - by Nicolai Josuttis&lt;/li&gt;
&lt;li&gt;The Salami Method for Cross Platform Development - by Adi Shavit&lt;/li&gt;
&lt;li&gt;Compile Time Regular Expressions - by Hana Dusíková&lt;/li&gt;
&lt;li&gt;And many more...&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Conclusion:&lt;/h1&gt;
&lt;p&gt;The week I spent fully immersed in C++ was really special! A bunch of passionated and dedicated persons can build really great events.
Hopefully, I will be able to join in denver next year or the year after, maybe as a &lt;strong&gt;speaker&lt;/strong&gt; this time (I should not stay a simple lurker forever ;))!
If not, be sure to find me at some other C++ conferences in Europe (Meeting C++, C++ On Sea...) or some local meetup groups, this community is trully amazing.&lt;/p&gt;</content><category term="C++"></category><category term="C++"></category><category term="event"></category><category term="cppcon"></category></entry><entry><title>Meta Crush Saga: a C++17 compile-time game</title><link href="https://jguegant.github.io/blogs/tech/meta-crush-saga.html" rel="alternate"></link><published>2018-05-19T23:30:00+02:00</published><updated>2018-05-19T23:30:00+02:00</updated><author><name>Jean Guegant</name></author><id>tag:jguegant.github.io,2018-05-19:/blogs/tech/meta-crush-saga.html</id><summary type="html">&lt;h2&gt;Trivia:&lt;/h2&gt;
&lt;p&gt;As a quest to obtain the highly coveted title of &lt;strong&gt;Lead Senior C++ Over-Engineer&lt;/strong&gt;, I decided last year to rewrite the game I work on during daytime (Candy Crush Saga) using the quintessence of modern C++ (C++17). And... thus was born &lt;a href="https://github.com/Jiwan/meta_crush_saga"&gt;Meta Crush Saga&lt;/a&gt;: a &lt;strong&gt;compile-time game&lt;/strong&gt;. I …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;Trivia:&lt;/h2&gt;
&lt;p&gt;As a quest to obtain the highly coveted title of &lt;strong&gt;Lead Senior C++ Over-Engineer&lt;/strong&gt;, I decided last year to rewrite the game I work on during daytime (Candy Crush Saga) using the quintessence of modern C++ (C++17). And... thus was born &lt;a href="https://github.com/Jiwan/meta_crush_saga"&gt;Meta Crush Saga&lt;/a&gt;: a &lt;strong&gt;compile-time game&lt;/strong&gt;. I was highly inspired by &lt;a href="https://blog.mattbierner.com/stupid-template-tricks-snake/"&gt;Matt Bernier's Nibbler game&lt;/a&gt; that used pure template meta-programming to recreate our the famous snake game we could play on our Nokia 3310 back in the days.&lt;/p&gt;
&lt;p&gt;"What the &lt;s&gt;hell&lt;/s&gt; heck is a &lt;strong&gt;compile-time game&lt;/strong&gt;?", "How does it looks like?", "What &lt;strong&gt;C++17&lt;/strong&gt; features did you use in this project?", "What was your learnings?" might come to your mind. To answer these questions you can either read the rest of this post or accept your inner laziness and watch the video version of this post, which is a talk I made during a &lt;a href="https://www.meetup.com/swedencpp/events/246069743/"&gt;Meetup event&lt;/a&gt; in Stockholm:&lt;/p&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/XV1lXtB3sqg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;Disclaimer: for the sake of your sanity and the fact that &lt;em&gt;errare humanum est&lt;/em&gt;, this article might contain some alternative facts.&lt;/p&gt;
&lt;h2&gt;A compile-time game you said?&lt;/h2&gt;
&lt;p&gt;&lt;img width=20% height=20% src="https://jguegant.github.io/blogs/tech/images/what-does-this-mean.png"/&gt;&lt;/p&gt;
&lt;p&gt;I believe that it's easier to understand what I mean by the "concept" of a &lt;strong&gt;compile-time game&lt;/strong&gt; if you compare the life cycle of such a game with the life cycle of a normal game. So here it is!&lt;/p&gt;
&lt;h3&gt;Life cycle of a normal game:&lt;/h3&gt;
&lt;p&gt;As a normal game developer with a normal life working at a normal job with a normal sanity level you would usually start by writing your &lt;strong&gt;game logic&lt;/strong&gt; using your favorite language (C++ of course!), then fire your &lt;strong&gt;compiler&lt;/strong&gt; to transform this, far too often spaghetti-like, logic into an &lt;strong&gt;executable&lt;/strong&gt;. As soon as you double-click on your &lt;strong&gt;executable&lt;/strong&gt; (or use the console), a &lt;strong&gt;process&lt;/strong&gt; will be spawned by your operating system. This &lt;strong&gt;process&lt;/strong&gt; will execute your &lt;strong&gt;game logic&lt;/strong&gt; which 99.42% of time consists of a &lt;strong&gt;game loop&lt;/strong&gt;. A &lt;strong&gt;game loop&lt;/strong&gt; will &lt;strong&gt;update&lt;/strong&gt; the state of your game according to some rules and the &lt;strong&gt;user inputs&lt;/strong&gt;, &lt;strong&gt;render&lt;/strong&gt; the newly computed state of your game in some flashy pixels, again, again and again.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Life cycle of a normal game" src="https://jguegant.github.io/blogs/tech/images/life-cycle-normal-game.png"&gt;&lt;/p&gt;
&lt;h3&gt;Life cycle of a compile-time game:&lt;/h3&gt;
&lt;p&gt;As an over-engineer cooking the next big compile-time game, you will still have use of your favorite language (still C++ of course!) to write your &lt;strong&gt;game logic&lt;/strong&gt;. You will still have a &lt;strong&gt;compilation phase&lt;/strong&gt; but... then... here comes the plot twist: you will &lt;strong&gt;execute&lt;/strong&gt; your &lt;strong&gt;game logic&lt;/strong&gt; within this compilation step. One could call it a compilutation. This is where C++ truly comes in handy ; it has a some features like &lt;a href="https://en.wikipedia.org/wiki/Template_metaprogramming"&gt;Template Meta Programming (TMP)&lt;/a&gt; or &lt;a href="http://en.cppreference.com/w/cpp/language/constexpr"&gt;constexpr&lt;/a&gt; to actually have &lt;strong&gt;computations&lt;/strong&gt; happening during the &lt;strong&gt;compilation phase&lt;/strong&gt;. We will dive later on the features you can use to do so. As we are executing the &lt;strong&gt;logic&lt;/strong&gt; of the game during this phase, we must also inject the &lt;strong&gt;user inputs&lt;/strong&gt; at that point in time. Obviously, our compiler will still output an &lt;strong&gt;executable&lt;/strong&gt;. What could it be used for? Well, the executable will not contain any &lt;strong&gt;game loop&lt;/strong&gt; anymore, but it will have a very simple mission: output the newly &lt;strong&gt;computed state&lt;/strong&gt;. Let's name this &lt;strong&gt;executable&lt;/strong&gt; a &lt;strong&gt;renderer&lt;/strong&gt; and its &lt;strong&gt;output&lt;/strong&gt; the &lt;strong&gt;rendering&lt;/strong&gt;. Our &lt;strong&gt;rendering&lt;/strong&gt; won't contain any fancy particule effect nor ambiant occlusion shadows, it will be in ASCII. An ASCII &lt;strong&gt;rendering&lt;/strong&gt; of your newly computed &lt;strong&gt;state&lt;/strong&gt; has the nice property that you can easily show it to your player, but you also copy it into a text file. Why a text file? Obviously because you can combine it with your &lt;strong&gt;code&lt;/strong&gt; in some way, redo all the previous steps and therefore have a &lt;strong&gt;loop&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;As you may understand now, a &lt;strong&gt;compile-time&lt;/strong&gt; game is made of a &lt;strong&gt;game-loop&lt;/strong&gt; where each &lt;strong&gt;frame&lt;/strong&gt; of your game is a &lt;strong&gt;compilation step&lt;/strong&gt;. Each &lt;strong&gt;compilation step&lt;/strong&gt; is computing a new &lt;strong&gt;state&lt;/strong&gt; of your game, that you can present to your player and also inject to the following &lt;strong&gt;frame&lt;/strong&gt; / &lt;strong&gt;compilation step&lt;/strong&gt;. &lt;/p&gt;
&lt;p&gt;I let you contemplate this magnificient diagram for as much time as it takes you to understand what I just wrote above:
&lt;img alt="Life cycle of a compile-time game" src="https://jguegant.github.io/blogs/tech/images/life-cycle-compile-time-game.png"&gt;&lt;/p&gt;
&lt;p&gt;Before we move on the implementation details of such a loop, I am sure that you have one question you would like to shoot at me...&lt;/p&gt;
&lt;h3&gt;"Why would you even do that?"&lt;/h3&gt;
&lt;p&gt;&lt;img width=25% height=25% src="https://jguegant.github.io/blogs/tech/images/why-would-you-even-do-that.png"/&gt;&lt;/p&gt;
&lt;p&gt;Do you really think I would let you break my C++ meta-programming idyll with such a fundamental question? Never!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;First and foremost, a &lt;strong&gt;compile-time game&lt;/strong&gt; will have amazing runtime performances since most of the computations are done during the &lt;strong&gt;compilation phase&lt;/strong&gt;. Runtime performance is a key to the success of your AAA game in ASCII art! &lt;/li&gt;
&lt;li&gt;You lessen the probability that a wild crustacean appears in your github repository and ask you to rewrite your game in &lt;strong&gt;Rust&lt;/strong&gt;. His well-prepared speech on security will fall appart as soon as you explain that a dangling pointer cannot exist at compile-time. Smug &lt;strong&gt;Haskell&lt;/strong&gt; programmers might even approve the &lt;strong&gt;type-safety&lt;/strong&gt; of your code.&lt;/li&gt;
&lt;li&gt;You will gain respect from the &lt;strong&gt;Javascript&lt;/strong&gt; hipster kingdom, where any over-complicated framework with a strong NIH syndrom can reign as long as it has a catchy name.&lt;/li&gt;
&lt;li&gt;One of my friend used to say that any line of code from a Perl program provides you de-facto a very strong password. I surely bet that he never tried generating credentials from &lt;strong&gt;compile-time C++&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So what? Aren't you satisfied with my answers? Then, maybe your question should have been: "Why could you even do that?".&lt;/p&gt;
&lt;p&gt;As a matter of fact, I really wanted to play with the features introduced by &lt;strong&gt;C++17&lt;/strong&gt;. Quite a few of them focus on improving the expressiveness of the language as well as the meta-programming facilities (mainly constexpr). Instead of writing small code samples, I thought that it would be more fun to turn all of this into a game. Pet projects are a nice way to learn concepts that you may not use before quite some time at work. Being able to run the core logic of your game at compile-time proves once a again that templates and constepxr are &lt;a href="https://en.wikipedia.org/wiki/Turing_completeness"&gt;turing complete&lt;/a&gt; subsets of the C++ language.&lt;/p&gt;
&lt;h2&gt;Meta Crush Saga: an overview&lt;/h2&gt;
&lt;h3&gt;A Match-3 game:&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Meta Crush Saga&lt;/strong&gt; is a &lt;a href="https://en.wikipedia.org/wiki/Tile-matching_video_game"&gt;tiled-matching game&lt;/a&gt; similar to &lt;strong&gt;Bejeweled&lt;/strong&gt; or &lt;strong&gt;Candy Crush Saga&lt;/strong&gt;. The core of the rules consists in matching three or more tiles of the same pattern to increase your scores. Here is sneak peek of a &lt;strong&gt;game state&lt;/strong&gt; I "dumped" (dumping ASCII is pretty damn easy): &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="sa"&gt;R&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="dl"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&lt;/span&gt;
&lt;span class="s"&gt;    Meta crush saga      &lt;/span&gt;
&lt;span class="s"&gt;------------------------  &lt;/span&gt;
&lt;span class="s"&gt;|                        | &lt;/span&gt;
&lt;span class="s"&gt;| R  B  G  B  B  Y  G  R | &lt;/span&gt;
&lt;span class="s"&gt;|                        | &lt;/span&gt;
&lt;span class="s"&gt;|                        | &lt;/span&gt;
&lt;span class="s"&gt;| Y  Y  G  R  B  G  B  R | &lt;/span&gt;
&lt;span class="s"&gt;|                        | &lt;/span&gt;
&lt;span class="s"&gt;|                        | &lt;/span&gt;
&lt;span class="s"&gt;| R  B  Y  R  G  R  Y  G | &lt;/span&gt;
&lt;span class="s"&gt;|                        | &lt;/span&gt;
&lt;span class="s"&gt;|                        | &lt;/span&gt;
&lt;span class="s"&gt;| R  Y  B  Y (R) Y  G  Y | &lt;/span&gt;
&lt;span class="s"&gt;|                        | &lt;/span&gt;
&lt;span class="s"&gt;|                        | &lt;/span&gt;
&lt;span class="s"&gt;| B  G  Y  R  Y  G  G  R | &lt;/span&gt;
&lt;span class="s"&gt;|                        | &lt;/span&gt;
&lt;span class="s"&gt;|                        | &lt;/span&gt;
&lt;span class="s"&gt;| R  Y  B  G  Y  B  B  G | &lt;/span&gt;
&lt;span class="s"&gt;|                        | &lt;/span&gt;
&lt;span class="s"&gt;------------------------  &lt;/span&gt;
&lt;span class="s"&gt;&amp;gt; score: 9009&lt;/span&gt;
&lt;span class="s"&gt;&amp;gt; moves: 27&lt;/span&gt;
&lt;span class="dl"&gt;)&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The game-play of this specific Match-3 is not so interesting in itself, but what about the architecture running all of this? To understand it, I will try to explain each part of the life cycle of this &lt;strong&gt;compile-time&lt;/strong&gt; game in term of code.&lt;/p&gt;
&lt;h3&gt;Injecting the game state:&lt;/h3&gt;
&lt;p&gt;&lt;img width=50% height=50% src="https://jguegant.github.io/blogs/tech/images/injecting-game-state.png"/&gt;&lt;/p&gt;
&lt;p&gt;As a C++ afficionados or a nitpicker, you may have noticed that my previous dumped game state started with the following pattern: &lt;strong&gt;R"(&lt;/strong&gt;. This is indeed a &lt;a href="http://en.cppreference.com/w/cpp/language/string_literal"&gt;C++11 raw string literal&lt;/a&gt;, meaning that I do not have to escape special characters like &lt;strong&gt;line feed&lt;/strong&gt;. This raw string literal is stored in a file called &lt;a href="https://github.com/Jiwan/meta_crush_saga/blob/master/current_state.txt"&gt;current_state.txt&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;How do we inject this current game state into a compile state? Let's just include it into the loop inputs!&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// loop_inputs.hpp&lt;/span&gt;

&lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="n"&gt;KeyboardInput&lt;/span&gt; &lt;span class="n"&gt;keyboard_input&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;KeyboardInput&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;KEYBOARD_INPUT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Get the current keyboard input as a macro&lt;/span&gt;

&lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;get_game_state_string&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]()&lt;/span&gt; &lt;span class="k"&gt;constexpr&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;game_state_string&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;constexpr_string&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="c1"&gt;// Include the raw string literal into a variable&lt;/span&gt;
        &lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;quot;current_state.txt&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
    &lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;game_state_string&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Whether it is a &lt;em&gt;.txt&lt;/em&gt; file or a &lt;em&gt;.h&lt;/em&gt; file, the &lt;strong&gt;include&lt;/strong&gt; directive from C preprocessor will work exactly the same: it will copy the content of the file at its location. Here I am copying the ascii-game-state-raw-string-literal into a variable named &lt;strong&gt;game_state_string&lt;/strong&gt;. &lt;/p&gt;
&lt;p&gt;Note that this header file &lt;a href="https://github.com/Jiwan/meta_crush_saga/blob/master/loop_inputs.hpp"&gt;loop_inputs.hpp&lt;/a&gt; also exposes the keyboard inputs for the current frame / compilation. Unlike the game state, the keyboard state is fairly small and can be easily received as a preprocessor definition.&lt;/p&gt;
&lt;h3&gt;Compile time computation of the new state:&lt;/h3&gt;
&lt;p&gt;&lt;img width=50% height=50% src="https://jguegant.github.io/blogs/tech/images/compile-time-computation-new-state.png"/&gt;&lt;/p&gt;
&lt;p&gt;Now that we have gathered enough data, we can compute a new state. And finally, we reach the point where we have to write a &lt;a href="https://github.com/Jiwan/meta_crush_saga/blob/master/main.cpp"&gt;main.cpp file&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// main.cpp&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;quot;loop_inputs.hpp&amp;quot; // Get all the data necessary for our computation.&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="c1"&gt;// Start: compile-time computation.&lt;/span&gt;

&lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;current_state&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parse_game_state&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;get_game_state_string&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Parse the game state into a convenient object.&lt;/span&gt;

&lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;new_state&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;game_engine&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current_state&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// Feed the engine with the parsed state,&lt;/span&gt;
    &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;keyboard_input&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;                          &lt;span class="c1"&gt;// Update the engine to obtain a new state.&lt;/span&gt;


&lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;print_game_state&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_state&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Convert the new state into a std::array&amp;lt;char&amp;gt; representation.&lt;/span&gt;

&lt;span class="c1"&gt;// End: compile-time computation.&lt;/span&gt;

&lt;span class="c1"&gt;// Runtime: just render the state.&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nl"&gt;c&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Strangely, this C++ code does not look too convoluted for what it does. Most of this code is run during the compilation phase and yet follows traditional OOP and procedural paradigms. Only the rendering, the last line, is an impediment to a pure compile-time computation. By sprinkling a bit of &lt;strong&gt;constexpr&lt;/strong&gt; where it should, you can have pretty elegant meta-programming in C++17 as we will see later-on. I find it fascinating the freedom C++ gives us when it comes to mix runtime and compile-time execution.&lt;/p&gt;
&lt;p&gt;You will also notice that this code only execute one frame, there is no &lt;strong&gt;game-loop&lt;/strong&gt; in here. Let's solve that issue!&lt;/p&gt;
&lt;h3&gt;Gluing things together:&lt;/h3&gt;
&lt;p&gt;&lt;img width=50% height=50% src="https://jguegant.github.io/blogs/tech/images/gluing-things-together.png"/&gt;&lt;/p&gt;
&lt;p&gt;If you are revulsed by my &lt;strong&gt;C++&lt;/strong&gt; tricks, I wish you do not mind to contemplate my &lt;strong&gt;Bash&lt;/strong&gt; skills. Indeed, my &lt;strong&gt;game loop&lt;/strong&gt; is nothing more than a &lt;a href="https://github.com/Jiwan/meta_crush_saga/blob/master/meta_crush_saga.sh"&gt;bash script&lt;/a&gt; executing repeatidly some compilations.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# It is a loop! No wait, it is a game loop!!!&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; :
    &lt;span class="c1"&gt;# Start a compilation step using G++&lt;/span&gt;
    g++ -o renderer main.cpp -DKEYBOARD_INPUT&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$keypressed&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;

    &lt;span class="nv"&gt;keypressed&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;get_key_pressed&lt;span class="o"&gt;()&lt;/span&gt;

    &lt;span class="c1"&gt;# Clean the screen.&lt;/span&gt;
    clear

    &lt;span class="c1"&gt;# Obtain the rendering&lt;/span&gt;
    &lt;span class="nv"&gt;current_state&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;./renderer&lt;span class="k"&gt;)&lt;/span&gt;
    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$current_state&lt;/span&gt; &lt;span class="c1"&gt;# Show the rendering to the player&lt;/span&gt;

    &lt;span class="c1"&gt;# Place the rendering into a current_state.txt file and wrap it into a raw string literal.&lt;/span&gt;
    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;R\&amp;quot;(&amp;quot;&lt;/span&gt; &amp;gt; current_state.txt
    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$current_state&lt;/span&gt; &amp;gt;&amp;gt; current_state.txt
    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;)\&amp;quot;&amp;quot;&lt;/span&gt; &amp;gt;&amp;gt; current_state.txt
&lt;span class="k"&gt;done&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I actually struggled a bit to get the keyboard inputs from the console. I initially wanted to receive the inputs in parallel of the compilation. After lots trial and error, I got something working-ish using the &lt;code&gt;read&lt;/code&gt; &lt;strong&gt;Bash&lt;/strong&gt; command. I would never dare to duel a &lt;strong&gt;Bash&lt;/strong&gt; wizard, that language is way too maleficent!&lt;/p&gt;
&lt;p&gt;Now let's agree, I had to resort to use another language to handle my game loop. Although, technically, nothing would prevent me to write that part of the code in C++. It also does not cancel the fact that 90% of the logic of my game is done within this &lt;strong&gt;g++&lt;/strong&gt; compilation command, which is pretty awesome!&lt;/p&gt;
&lt;h3&gt;A bit of gameplay to soften your eyes:&lt;/h3&gt;
&lt;p&gt;Now that you have suffered your way into my explanations on the game's architecture, here comes a bit of eye candy:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Meta Crush Saga in action" src="https://jguegant.github.io/blogs/tech/images/meta-crush-saga.gif"&gt;&lt;/p&gt;
&lt;p&gt;This pixelated gif is a record of me playing &lt;strong&gt;Meta Crush Saga&lt;/strong&gt;. As you can see, the game runs smoothly enough to make it playable in real-time. It is clearly not attractive enough to be able to stream it on Twitch and for me to become the new Pewdiepie, but hey... it works!
One of the funny aspect of having a &lt;strong&gt;game state&lt;/strong&gt; stored as a &lt;em&gt;.txt&lt;/em&gt; is the ability to cheat or test edge-cases really easily.&lt;/p&gt;
&lt;p&gt;Now that I sketched the architecture, we will dive a bit more in the C++17 features used within that project. I will not focus on the game logic, as it is very specific to a Match-3, but will instead discuss subjects of C++ that be could applied in other projects too.&lt;/p&gt;
&lt;h2&gt;My C++17 learnings:&lt;/h2&gt;
&lt;p&gt;&lt;img width=25% height=25% style="float: left;" src="https://jguegant.github.io/blogs/tech/images/spoiled-kids.png"/&gt;&lt;/p&gt;
&lt;p&gt;Unlike C++14 which mainly contained minor fixes, the new C++17 standard has a lot to offer. There were hopes that some long-overdue features would land this time (modules, coroutines, concepts...) and... well... they did not ; which disappointed quite a few of us. But after the mourning, we discovered a myriad of small unexpected gems that made their way through.&lt;/p&gt;
&lt;p&gt;I would dare to say that all the meta-programming kids were spoiled this year! Few minor tweaks and additions in language now permit you to write code very similar weither it is running during compilation or afterwards during runtime.&lt;/p&gt;
&lt;div style="clear: both;"&gt;&lt;/div&gt;

&lt;h3&gt;Constepxr all the things:&lt;/h3&gt;
&lt;p&gt;As Ben Deane and Jason Turner foretold in their &lt;a href="https://www.youtube.com/watch?v=PJwd4JLYJJY"&gt;C++14 talk&lt;/a&gt;, 
C++ is quickly improving value-computations at compile-time using the almighty &lt;a href="http://en.cppreference.com/w/cpp/language/constexpr"&gt;constexpr&lt;/a&gt; keyword. By placing this keyword in the appropriate places you can hint to your compiler that an expression is constant and &lt;strong&gt;could&lt;/strong&gt; be directly evaluated at compile-time. In &lt;strong&gt;C++11&lt;/strong&gt; you could already write such code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;factorial&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// Combining a function with constexpr make it potentially evaluable at compile-time.&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;factorial&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;factorial&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Call to a constexpr function.&lt;/span&gt;
&lt;span class="c1"&gt;// Can be replace by a good compiler by:&lt;/span&gt;
&lt;span class="c1"&gt;// int i = 120;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;While powerful, &lt;strong&gt;constexpr&lt;/strong&gt; had quite a lot of restrictions on its usage and made it cumbersome to write expressive code in this way.
&lt;strong&gt;C++14&lt;/strong&gt; relaxed a lot &lt;strong&gt;constexpr&lt;/strong&gt; and felt much more natural to use. Our previous factorial function could be rewritten this way:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;factorial&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;factorial&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Indeed, &lt;strong&gt;C++14&lt;/strong&gt; lifted the rule stipulating that a &lt;strong&gt;constexpr function&lt;/strong&gt; must only consist of one return statement, which forced us to use the &lt;a href="https://en.wikipedia.org/wiki/%3F:"&gt;ternary operator&lt;/a&gt; as a basic building block. Now &lt;strong&gt;C++17&lt;/strong&gt; brought even more placements for the &lt;strong&gt;constexpr&lt;/strong&gt; keyword that we can explore!&lt;/p&gt;
&lt;h4&gt;Compile-time branching:&lt;/h4&gt;
&lt;p&gt;Did you ever end-up in a situation where you wish that you could have different behavior according to the template parameter you are manipulating? Let's say that you wanted a generic &lt;code&gt;serialize&lt;/code&gt; function that would call &lt;code&gt;.serialize()&lt;/code&gt; if your object provides one, otherwise fall back on calling &lt;code&gt;to_string&lt;/code&gt; on it. As explained in more details in this &lt;a href="https://jguegant.github.io/blogs/tech/sfinae-introduction.html"&gt;post about SFINAE&lt;/a&gt; you would very likely write such a lovely alien code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;enable_if_t&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;has_serialize_v&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; 
&lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;enable_if_t&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;!&lt;/span&gt;&lt;span class="n"&gt;has_serialize_v&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; 
&lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;to_string&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In your dreams you may be able to rewrite that awkward &lt;strong&gt;SFINAE trick&lt;/strong&gt; into such a magestic piece of code in &lt;strong&gt;C++14&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// has_serialize is a constexpr function that test the of serialize on a object.&lt;/span&gt;
&lt;span class="c1"&gt;// See my post on SFINAE to understand how to write such a function. &lt;/span&gt;
&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;has_serialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="cm"&gt;/*t*/&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// We know that constexpr can be placed before functions.&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;has_serialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;to_string&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Sadly, as soon as you wake-up and start writing &lt;strong&gt;C++14&lt;/strong&gt; for real, your compiler will vomit you a displeasant message regarding the call &lt;code&gt;serialize(42);&lt;/code&gt;. It will explain that the object &lt;code&gt;obj&lt;/code&gt; of type &lt;code&gt;int&lt;/code&gt; does not have a &lt;code&gt;serialize()&lt;/code&gt; member function. As much as you hate it, your compiler is right! Given the current code, it will always try to compile both of the branches &lt;code&gt;return obj.serialize();&lt;/code&gt; and 
&lt;code&gt;return std::to_string(obj);&lt;/code&gt;. For an &lt;code&gt;int&lt;/code&gt;, the branch &lt;code&gt;return obj.serialize();&lt;/code&gt; might well be some dead-code since &lt;code&gt;has_serialize(obj)&lt;/code&gt; will always return &lt;code&gt;false&lt;/code&gt;, but your compiler will still need to compile-it.&lt;/p&gt;
&lt;p&gt;As you may expect, &lt;strong&gt;C++17&lt;/strong&gt; save us from such an embarassing situation by introducing the possibility to add &lt;strong&gt;constexpr&lt;/strong&gt; after an if statement to "force" a compile-time branching and discard the unused statements:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// has_serialize...&lt;/span&gt;
&lt;span class="c1"&gt;// ...&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;has_serialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// Now we can place constexpr on the &amp;#39;if&amp;#39; directly.&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// This branch will be discarded and therefore not compiled if obj is an int.&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;to_string&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;branch&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img width=25% height=25% src="https://jguegant.github.io/blogs/tech/images/constexpr-all-the-things.png"/&gt;&lt;/p&gt;
&lt;p&gt;This is clearly a huge improvement compared to the &lt;strong&gt;SFINAE trick&lt;/strong&gt; we had to employ until now. After that, you will start to get the same addiction as Ben and Jason which consists in &lt;strong&gt;constexpr&lt;/strong&gt; everything, everywhere at anytime. Alas, there is still one place where the &lt;strong&gt;constexpr&lt;/strong&gt; keyword would well fit in but cannot be done yet: &lt;strong&gt;constexpr parameters&lt;/strong&gt;.&lt;/p&gt;
&lt;h4&gt;Constexpr parameters:&lt;/h4&gt;
&lt;p&gt;If you are assiduous, you may have noticed a strange pattern in one my previous code sample. I am talking about the loop inputs:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// loop_inputs.hpp&lt;/span&gt;

&lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;get_game_state_string&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]()&lt;/span&gt; &lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="c1"&gt;// Why?&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;game_state_string&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;constexpr_string&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="c1"&gt;// Include the raw string literal into a variable&lt;/span&gt;
        &lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;quot;current_state.txt&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
    &lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;game_state_string&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Why is the variable &lt;strong&gt;game_state_string&lt;/strong&gt; encapsulated into a constexpr lambda? Why not making it a &lt;strong&gt;constexpr global variable&lt;/strong&gt;?&lt;/p&gt;
&lt;p&gt;Well, I wanted to pass this variable and its content deep down to some functions. For instance, my &lt;strong&gt;parse_board&lt;/strong&gt; needed to be fed with it and used it in some constant expressions:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;parse_board_size&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;game_state_string&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="nf"&gt;parse_board&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;game_state_string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;GemType&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parse_board_size&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;game_state_string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;board&lt;/span&gt;&lt;span class="p"&gt;{};&lt;/span&gt;
    &lt;span class="c1"&gt;//                                       ^ ‘game_state_string’ is not a constant expression&lt;/span&gt;
    &lt;span class="c1"&gt;// ...  &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;parse_board&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="n"&gt;something&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If you are doing it this way, your grumpy compiler will complain that the parameter &lt;strong&gt;game_state_string&lt;/strong&gt; is not a constant expression. When I am building my array of Gems, I need to compute its fixed capacity directly (you cannot use vectors at compile-time as it requires to allocate) and pass it as a value-template-argument to &lt;strong&gt;std::array&lt;/strong&gt;. The expression &lt;strong&gt;parse_board_size(game_state_string)&lt;/strong&gt; therefore needs to be a constant expression. While &lt;strong&gt;parse_board_size&lt;/strong&gt; is clearly marked as &lt;strong&gt;constexpr&lt;/strong&gt;, &lt;strong&gt;game_state_string&lt;/strong&gt; is not AND cannot be! Two rules are annoying us in this case:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Arguments of a constexpr function are not constexpr!&lt;/li&gt;
&lt;li&gt;And you cannot add constexpr in front of them!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It boils down to the fact that &lt;strong&gt;constexpr functions&lt;/strong&gt; MUST be usable for both runtime or compile-time computations. Allowing &lt;strong&gt;constexpr parameters&lt;/strong&gt; would discard the possibility to use them at runtime.&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img width=25% height=25% src="https://jguegant.github.io/blogs/tech/images/facepalm.jpg"/&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;Thanksfully, there is a way to mitigate that issue. Instead of accepting the value as a normal function parameter, you can encapsulate that value into a type and pass that type as a template parameter:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;GameStringType&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;parse_board&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GameStringType&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;CellType&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parse_board_size&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GameStringType&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;board&lt;/span&gt;&lt;span class="p"&gt;{};&lt;/span&gt;
    &lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;GameString&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;...something...&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="n"&gt;parse_board&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GameString&lt;/span&gt;&lt;span class="p"&gt;{});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In this code sample, I am creating a struct type &lt;strong&gt;GameString&lt;/strong&gt; which has a static constexpr member function &lt;strong&gt;value()&lt;/strong&gt; that returns the string literal I want to pass to &lt;strong&gt;parse_board&lt;/strong&gt;. In &lt;strong&gt;parse_board&lt;/strong&gt; I receive this type through the template parameter &lt;strong&gt;GameStringType&lt;/strong&gt; thanks to template argument deduction rules. Having &lt;strong&gt;GameStringType&lt;/strong&gt;, I can simply call the static member function &lt;strong&gt;value()&lt;/strong&gt; whenever I want to get the string literal, even in locations where constant expressions are necessary since &lt;strong&gt;value()&lt;/strong&gt; is constexpr. &lt;/p&gt;
&lt;p&gt;We succeeded to encapsulate our literal to somehow pass it to &lt;strong&gt;parse_board&lt;/strong&gt; in a constexpr way. Now, it gets very annoying to have to define a new type everytime you want to send a new literal to &lt;strong&gt;parse_board&lt;/strong&gt;: "...something1...", "...something2...". To solve that issue in &lt;strong&gt;C++11&lt;/strong&gt;, you can rely on some ugly macros and few indirection using an anonymous union and a lambda. Mikael Park has a nice explanation on this topic in &lt;a href="https://mpark.github.io/programming/2017/05/26/constexpr-function-parameters/"&gt;one of his post&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;We can do even better in &lt;strong&gt;C++17&lt;/strong&gt;. If you list our current requirements to pass our string literal, we need:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A generated function&lt;/li&gt;
&lt;li&gt;Which is constexpr&lt;/li&gt;
&lt;li&gt;With a unique or anonymous name&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This requirements should ring a bell to you. What we need is a &lt;strong&gt;constexpr lambda&lt;/strong&gt;! And &lt;strong&gt;C++17&lt;/strong&gt; rightfully added the possibility to use the &lt;strong&gt;constexpr&lt;/strong&gt; keyword on a lambda. We could rewrite the code sample in such a way:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;LambdaType&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;parse_board&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LambdaType&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;get_game_state_string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;CellType&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parse_board_size&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;get_game_state_string&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;board&lt;/span&gt;&lt;span class="p"&gt;{};&lt;/span&gt;
    &lt;span class="c1"&gt;//                                       ^ Allowed to call a constexpr lambda in this context.&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;parse_board&lt;/span&gt;&lt;span class="p"&gt;([]()&lt;/span&gt; &lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="n"&gt;something&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;});&lt;/span&gt;
&lt;span class="c1"&gt;//                ^ Make our lambda constexpr.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Believe me, this feels already much neater than the previous &lt;strong&gt;C++11&lt;/strong&gt; hackery using macros. I discovered this awesome trick thanks to &lt;strong&gt;Björn Fahller&lt;/strong&gt;, a member of the C++ meetup group I participate in. You can read more about this trick on his &lt;a href="http://playfulprogramming.blogspot.se/2016/08/strings-as-types-with-c17-constexpr.html"&gt;blog&lt;/a&gt;. Note also that the &lt;strong&gt;constexpr&lt;/strong&gt; keyword is actually not necessary in this case: all the &lt;strong&gt;lambdas&lt;/strong&gt; with the capacity to be &lt;strong&gt;constexpr&lt;/strong&gt; will be by default. Having an explicit &lt;strong&gt;constexpr&lt;/strong&gt; in the signature just makes it easier to catch mistakes.&lt;/p&gt;
&lt;p&gt;Now you should understand why I was forced to use a &lt;strong&gt;constexpr&lt;/strong&gt; lambda to pass down the string representing my game state. Have a look at this lambda and one question should arise again. What is this &lt;strong&gt;constexpr_string&lt;/strong&gt; type I also use to wrap the string literal?&lt;/p&gt;
&lt;h5&gt;&lt;strong&gt;constexpr_string&lt;/strong&gt; and &lt;strong&gt;constexpr_string_view&lt;/strong&gt;:&lt;/h5&gt;
&lt;p&gt;When you are dealing with strings, you do not want to deal with them the C way. All these pesky algorithms iterating in a raw manner and checking null ending should be forbidden! The alternative offered by &lt;strong&gt;C++&lt;/strong&gt; is the almighty &lt;strong&gt;std::string&lt;/strong&gt; and &lt;strong&gt;STL algorithms&lt;/strong&gt;. Sadly, &lt;strong&gt;std::string&lt;/strong&gt; may have to allocate on the heap (even with Small String Optimization) to store their content. One or two standards from now we may benefit from &lt;strong&gt;constexpr new/delete&lt;/strong&gt; or being able to pass &lt;strong&gt;constexpr allocators&lt;/strong&gt; to &lt;strong&gt;std::string&lt;/strong&gt;, but for now we have to find another solution.&lt;/p&gt;
&lt;p&gt;My approach was to write a &lt;strong&gt;constexpr_string&lt;/strong&gt; class which has a fixed capacity. This capacity is passed as a value template parameter. Here is a short overview of my class:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="c1"&gt;// N is the capacity of my string.&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;constexpr_string&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;data_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Reserve N chars to store anything.  &lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;size_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="c1"&gt;// The actual size of the string.&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="n"&gt;constexpr_string&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)[&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;data_&lt;/span&gt;&lt;span class="p"&gt;{},&lt;/span&gt; &lt;span class="n"&gt;size_&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// copy a into data_   }&lt;/span&gt;
    &lt;span class="c1"&gt;// ...&lt;/span&gt;
    &lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="n"&gt;iterator&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;data_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="p"&gt;}&lt;/span&gt;       &lt;span class="c1"&gt;// Points at the beggining of the storage.&lt;/span&gt;
    &lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="n"&gt;iterator&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;data_&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;size_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// Points at the end of the stored string.&lt;/span&gt;
    &lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;My &lt;a href="https://github.com/Jiwan/meta_crush_saga/blob/master/constexpr_string.hpp"&gt;constexpr_string&lt;/a&gt; class tries to mimic as closely as possible the interface of &lt;strong&gt;std::string&lt;/strong&gt; (for the operations that I needed): you can query the &lt;strong&gt;begin and end iterators&lt;/strong&gt;, retrive the &lt;strong&gt;size&lt;/strong&gt;, get access to &lt;strong&gt;data&lt;/strong&gt;, &lt;strong&gt;erase&lt;/strong&gt; part of it, get a substring using &lt;strong&gt;substr&lt;/strong&gt;, etc. It makes it very straightforward to transform a piece of code from &lt;strong&gt;std::string&lt;/strong&gt; to &lt;strong&gt;constexpr_string&lt;/strong&gt;. You may wonder what happens when you want to do use operations that would normally requires an allocation in &lt;strong&gt;std::string&lt;/strong&gt;. In such cases, I was forced to transform them into &lt;strong&gt;immutable operations&lt;/strong&gt; that would create new instance of &lt;strong&gt;constexpr_string&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Let's have a look at the &lt;strong&gt;append&lt;/strong&gt; operation:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="c1"&gt;// N is the capacity of my string.&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;constexpr_string&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// ...&lt;/span&gt;
    &lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;M&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="c1"&gt;// M the capacity of the other string.&lt;/span&gt;
    &lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;constexpr_string&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;M&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;

        &lt;span class="n"&gt;constexpr_string&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;M&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
        &lt;span class="c1"&gt;//                 ^ Enough capacity for both. ^ Copy the first string into the output.&lt;/span&gt;

        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
            &lt;span class="o"&gt;^&lt;/span&gt; &lt;span class="n"&gt;Copy&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;second&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;into&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img width=25% height=25% style="float:right;" src="https://jguegant.github.io/blogs/tech/images/einstein.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;No needs to have a Fields Medal to assume that if we have a string of size &lt;strong&gt;N&lt;/strong&gt; and a string or size &lt;strong&gt;M&lt;/strong&gt;, a string of size &lt;strong&gt;N + M&lt;/strong&gt; should be enough to store the concatenation. You may waste a bit of "compile-time storage" since both of your strings may not use their full capacity, but that is a fairly small price to pay for a lot of convenience. I, obviously, also wrote the counterpart of &lt;strong&gt;std::string_view&lt;/strong&gt; which I named &lt;a href="https://github.com/Jiwan/meta_crush_saga/blob/master/constexpr_string_view.hpp"&gt;constexpr_string_view&lt;/a&gt;.&lt;/p&gt;
&lt;div style="clear: both;"&gt;&lt;/div&gt;

&lt;p&gt;Having these two classes, I was ready to write elegant code to parse my &lt;strong&gt;game state&lt;/strong&gt;. Think about something like that:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;game_state&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;constexpr_string&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="n"&gt;something&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// Let&amp;#39;s find the first blue gem occurence within my string:&lt;/span&gt;
&lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;blue_gem&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;find_if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;game_state&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;game_state&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; 
    &lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt;  &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="err"&gt;‘&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="err"&gt;’&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;It was fairly simple to iterate over the gems on my board - speaking of which, did you notice another &lt;strong&gt;C++17&lt;/strong&gt; gem in that code sample?&lt;/p&gt;
&lt;p&gt;Yes! I did not have to explicitely specify the capacity of my &lt;strong&gt;constexpr_string&lt;/strong&gt; when constructing it. In the past, you had to explicitely specify the arguments of a &lt;strong&gt;class template&lt;/strong&gt; when using it. To avoid this pain, we would provide &lt;em&gt;make_xxx&lt;/em&gt; functions since parameters of &lt;strong&gt;function templates&lt;/strong&gt; could be deduced. Have a look on how &lt;a href="http://en.cppreference.com/w/cpp/language/class_template_argument_deduction"&gt;class template argument deduction&lt;/a&gt; is changing our life for the better:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;constexpr_string&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;constexpr_string&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)[&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
    &lt;span class="c1"&gt;// ..&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="c1"&gt;// **** Pre C++17 ****&lt;/span&gt;
&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="n"&gt;constexpr_string&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;make_constexpr_string&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)[&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Provide a function template to deduce N           ^ right here&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;constexpr_string&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="c1"&gt;//                      ^ Forward the parameter to the class template.&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;test2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;make_constexpr_string&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;blablabla&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;//                  ^ use our function template to for the deduction.&lt;/span&gt;
&lt;span class="n"&gt;constexpr_string&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;blabla&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;//               ^ or feed the argument directly and pray that it was the good one.&lt;/span&gt;


&lt;span class="c1"&gt;// **** With C++17 ****&lt;/span&gt;
&lt;span class="n"&gt;constexpr_string&lt;/span&gt; &lt;span class="nf"&gt;test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;blabla&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;//           ^ Really smmoth to use, the argument is deduced.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In some tricky situations, you may still need to help your compiler to deduce correctly your arguments. If you encouter such an issue, have a look at &lt;a href="http://en.cppreference.com/w/cpp/language/class_template_argument_deduction#User-defined_deduction_guides"&gt;user-defined deduction guides&lt;/a&gt;.&lt;/p&gt;
&lt;h4&gt;Free food from the STL:&lt;/h4&gt;
&lt;p&gt;Alright, you can always rewrite things by yourself. But did the committee members kindly cooked something for us in the standard library?&lt;/p&gt;
&lt;h5&gt;New utility types:&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;C++17&lt;/strong&gt; introduced &lt;a href="http://en.cppreference.com/w/cpp/utility/variant"&gt;std::variant&lt;/a&gt; and &lt;a href="http://en.cppreference.com/w/cpp/utility/optional"&gt;std::optional&lt;/a&gt; to the common vocabulary types, with &lt;strong&gt;constexpr&lt;/strong&gt; in mind. While the former one is really interesting since it permits you to express type-safe unions, the implementation provided in the &lt;strong&gt;libstdc++&lt;/strong&gt; library with &lt;strong&gt;GCC 7.2&lt;/strong&gt; had issues when used in constant expressions. Therefore, I gave up the idea to introduce &lt;strong&gt;std::variant&lt;/strong&gt; in my code and solely utilised &lt;strong&gt;std::optional&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Given a type &lt;strong&gt;T&lt;/strong&gt;, &lt;strong&gt;std::optional&lt;/strong&gt; allows you to create a new type &lt;strong&gt;std::optional&lt;T&gt;&lt;/strong&gt; which may either hold a value of type &lt;strong&gt;T&lt;/strong&gt; or nothing. It is pretty similar to &lt;a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/nullable-types/"&gt;nullable value types&lt;/a&gt; in &lt;strong&gt;C#&lt;/strong&gt;.
Let's consider a &lt;strong&gt;find_in_board&lt;/strong&gt; function that return the position of the first item in the board that validate a predicate. You may not have such an item in the board at all. To handle such a situation, the position type must be optional:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Predicate&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;optional&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;pair&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;find_in_board&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GameBoard&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Predicate&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="nl"&gt;item&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// Return by value if we find such an item.&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;nullopt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Return the empty state otherwise.&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;find_in_board&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="k"&gt;auto&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;});&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  &lt;span class="c1"&gt;// Test if the optional is empty or not.&lt;/span&gt;
    &lt;span class="n"&gt;do_something&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Can safely use the optional by &amp;#39;deferencing&amp;#39; with &amp;#39;*&amp;#39;.&lt;/span&gt;
    &lt;span class="cm"&gt;/* ... */&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Previously, you would have recourse to either &lt;strong&gt;pointer semantics&lt;/strong&gt; or add an "empty state" directly into your position type or return a boolean and take an &lt;strong&gt;out parameter&lt;/strong&gt;. Let's face it, it was pretty clumsy!&lt;/p&gt;
&lt;p&gt;Some already existing types also received a &lt;strong&gt;constexpr&lt;/strong&gt; lifting: &lt;a href="http://en.cppreference.com/w/cpp/utility/tuple"&gt;tuple&lt;/a&gt; and &lt;a href="http://en.cppreference.com/w/cpp/utility/pair"&gt;pair&lt;/a&gt;. I will not explain their usage as a lot have been already written on these two, but I will share you one of my disapointment. The committee added to the standard a &lt;strong&gt;syntactic sugar&lt;/strong&gt; to extract the values hold by a &lt;strong&gt;tuple&lt;/strong&gt; or &lt;strong&gt;pair&lt;/strong&gt;. Called &lt;a href="http://en.cppreference.com/w/cpp/language/structured_binding"&gt;structured binding&lt;/a&gt;, this new kind of declaration uses brackets to define in which variables you would like to store the exploded &lt;strong&gt;tuple&lt;/strong&gt; or &lt;strong&gt;pair&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;pair&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1337&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="c1"&gt;// x = 42 and y = 1337.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Really clever! It is just a pity that the committee members [could not, would not, did not have the time, forgot, enjoyed not] to make it &lt;strong&gt;constexpr&lt;/strong&gt; friendly. I would have expected something along the way:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// OR&lt;/span&gt;
&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We now have fancy containers and utilities, how can we manipulate them easily?&lt;/p&gt;
&lt;h5&gt;Algorithms:&lt;/h5&gt;
&lt;p&gt;Upgrading a container to a handle &lt;strong&gt;constexpr&lt;/strong&gt; is a rather tedious work. Comparatively, bringing &lt;strong&gt;constexpr&lt;/strong&gt; to &lt;strong&gt;non-modifying algorithms&lt;/strong&gt; seems rather straightforward. But strangely enough, &lt;strong&gt;C++17&lt;/strong&gt; did not see any progress in that domain, it is actually coming in &lt;strong&gt;C++20&lt;/strong&gt;. For instance, the supreme &lt;a href="http://en.cppreference.com/w/cpp/algorithm/find"&gt;std::find&lt;/a&gt; algorithms did not receive its &lt;strong&gt;constexpr&lt;/strong&gt; signature.&lt;/p&gt;
&lt;p&gt;Worry not (or "Qu'à cela ne tienne" in French)! As explained by Ben and Jason, you can easily turn an algorithm in &lt;strong&gt;constexpr&lt;/strong&gt; by simply copying a current implementation (checkout for copyrights though) ; cppreference being a good fit. Ladies and gentlemen, I present you a &lt;strong&gt;constexpr std::find&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;InputIt&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="n"&gt;InputIt&lt;/span&gt; &lt;span class="n"&gt;find&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;InputIt&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;InputIt&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;// ^ TADAMMMM!!! I added constexpr here.&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(;&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// Thanks to: http://en.cppreference.com/w/cpp/algorithm/find&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I already hear optimisation affionados screaming on their chair! Yes, just adding &lt;strong&gt;constexpr&lt;/strong&gt; in front of a code sample gently provided by &lt;strong&gt;cppreference&lt;/strong&gt; may not give you the perfect &lt;strong&gt;runtime performances&lt;/strong&gt;. But if we really had to polish this algorithm it would be for &lt;strong&gt;compile-time performances&lt;/strong&gt;. Keeping things simple usually give the best results when it comes to speed of &lt;strong&gt;compilation&lt;/strong&gt; from what I observed.&lt;/p&gt;
&lt;h3&gt;Performance &amp;amp; bugs:&lt;/h3&gt;
&lt;p&gt;Every triple A games must put efforts in these topics, right?&lt;/p&gt;
&lt;h4&gt;Performance:&lt;/h4&gt;
&lt;p&gt;When I achieved a first half-workingish version of &lt;strong&gt;Meta Crush Saga&lt;/strong&gt; things ran rather smoothly. It actually reached a bit more than &lt;strong&gt;3 FPS&lt;/strong&gt; (Frame Per Second) on my old laptop with an i5 clocked at 1.80GHz (frequency do matter in this case). As in any project, I quickly found my previously written code unsavoury and started to rewrite the parsing of my game state using &lt;strong&gt;constexpr_string&lt;/strong&gt; and standard algorithms. Although it made my code much more maintenable it also had a severe impact on the performance ; &lt;strong&gt;0.5 FPS&lt;/strong&gt; was the new ceiling. &lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img width=35% height=35% src="https://jguegant.github.io/blogs/tech/images/performance-rating.png"/&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;Unlike the old C++ adage, "zero-head abstractions" did not apply to &lt;strong&gt;compile-time computations&lt;/strong&gt;. Which really makes sense if you see your compiler as an interpreter of some "compile-time code". There is still room to improve for the various compilers, but also for us writers of such code. Here is a non-exhaustive list of few observations and tips, maybe specific to GCC, that I figured out:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;C arrays&lt;/strong&gt; performed significantly better than &lt;strong&gt;std::array&lt;/strong&gt;. &lt;strong&gt;std::array&lt;/strong&gt; is a bit of modern C++ cosmetic over a &lt;strong&gt;C-style array&lt;/strong&gt; and one must pay a certain price to use it in such circumstances. &lt;/li&gt;
&lt;li&gt;It felt like &lt;strong&gt;recursive functions&lt;/strong&gt; had the advantage (speed-wise) over writing &lt;strong&gt;functions with loops&lt;/strong&gt;. It could well be that writing recursive algorithms forces you to tackle your problems in another way, which behaves better. To put in my two penny worth, I believe that the cost of compile-time calls might be smaller than executing a complicated function body especially that compilers (and their implementors) have been exposed to decades of abusive recursions we used for our own template-metaprogramming ends. &lt;/li&gt;
&lt;li&gt;Copying data around is also quite expensive, notably if you are dealing with value types. If I wanted to futher optimise my game, I would mainly focus on that problem.&lt;/li&gt;
&lt;li&gt;I only &lt;s&gt;ab&lt;/s&gt;used one of my CPU core to do the job. Having only one compilation unit restricted me to spawn only one instance of GCC at a time. I am not quite sure if you could parallelise my compilutation.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Bugs:&lt;/h4&gt;
&lt;p&gt;&lt;img width=20% height=20% style="float: left;" src="https://jguegant.github.io/blogs/tech/images/no-bugs.png"/&gt;
More than once, my compiler regurgitated terrible compilation errors, my code logic being flawed. But how could I find where the bug was located? Without &lt;strong&gt;debugger&lt;/strong&gt; and &lt;strong&gt;printf&lt;/strong&gt;, things get complicated. If your metaphoric programming beard is not up to your knees (both my metaphoric and physical one did not reach the expectations), you may not have the motivation to use &lt;a href="https://github.com/mikael-s-persson/templight"&gt;templight&lt;/a&gt; nor to debug your compiler.&lt;/p&gt;
&lt;p&gt;Your first friend will be &lt;a href="http://en.cppreference.com/w/cpp/language/static_assert"&gt;static_assert&lt;/a&gt;, which gives you the possibility to test the value of a compile-time boolean. Your second friend will be a macro to turn on and off &lt;strong&gt;constexpr&lt;/strong&gt; wherever possible:
&lt;div style="clear: both;"&gt;&lt;/div&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;#define CONSTEXPR constexpr  &lt;/span&gt;&lt;span class="c1"&gt;// compile-time No debug possible&lt;/span&gt;

&lt;span class="c1"&gt;// OR&lt;/span&gt;

&lt;span class="cp"&gt;#define CONSTEXPR           &lt;/span&gt;&lt;span class="c1"&gt;// Debug at runtime&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;By using this macro, you can force the logic to execute at runtime and therefore attach a debugger to it.&lt;/p&gt;
&lt;h2&gt;Meta Crush Saga II - Looking for a pure compile-time experience:&lt;/h2&gt;
&lt;p&gt;Clearly, &lt;strong&gt;Meta Crush Saga&lt;/strong&gt; will not win &lt;a href="https://en.wikipedia.org/wiki/The_Game_Awards"&gt;The Game Awards&lt;/a&gt; this year. It has some great potential, but the experience is not fully &lt;strong&gt;compile-time&lt;/strong&gt; YET, which may be a showstopper for hardcore gamers... I cannot get rid-of the bash script, unless someone add &lt;strong&gt;keyboard inputs&lt;/strong&gt; and impure logic during the compilation-phase (pure madness!). But I believe, that one day, I could entirely bypass the &lt;strong&gt;renderer&lt;/strong&gt; executable and print my &lt;strong&gt;game state&lt;/strong&gt; at &lt;strong&gt;compile-time&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Life cycle of a fully compile-time game" src="https://jguegant.github.io/blogs/tech/images/life-cycle-fully-compile-time-game.png"&gt;&lt;/p&gt;
&lt;p&gt;A crazy fellow pseudo-named &lt;strong&gt;saarraz&lt;/strong&gt;, &lt;a href="https://github.com/saarraz/static-print"&gt;extended GCC&lt;/a&gt; to add a &lt;strong&gt;static_print&lt;/strong&gt; statement to the language. This statement would take a few constant expressions or string literals and output them during the compilation. I would be glad if such tool would be added to the standard, or at least extend &lt;strong&gt;static_assert&lt;/strong&gt; to accept constant expressions.&lt;/p&gt;
&lt;p&gt;Meanwhile, there might be a &lt;strong&gt;C++17&lt;/strong&gt; way to obtain that result. Compilers already ouput two things, &lt;strong&gt;errors&lt;/strong&gt; and &lt;strong&gt;warnings&lt;/strong&gt;! If we could somehow control or bend a &lt;strong&gt;warning&lt;/strong&gt; to our needs, we may already have a decent output. I tried few solutions, notably the &lt;a href="http://en.cppreference.com/w/cpp/language/attributes"&gt;deprecated attribute&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;words&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;useless&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;deprecated&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt; &lt;span class="c1"&gt;// Will trigger a warning.&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;words&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;output_as_warning&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;useless&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;words&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;call&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;output_as_warning&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="err"&gt;’&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="err"&gt;’&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;‘&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="err"&gt;’&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;‘&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="err"&gt;’&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

&lt;span class="c1"&gt;// warning: &amp;#39;void useless&amp;lt;words&amp;gt;::call() [with char ...words = {&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;}]&amp;#39; is deprecated &lt;/span&gt;
&lt;span class="c1"&gt;// [-Wdeprecated-declarations]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;While the output is clearly there and parsable, it is unfortunately not playable! If by sheer luck, you are part of the secret-community-of-c++-programmers-that-can-output-things-during-compilation, I would be glad to recruit you in my team to create the perfect &lt;strong&gt;Meta Crush Saga II&lt;/strong&gt;!&lt;/p&gt;
&lt;h2&gt;Conclusion:&lt;/h2&gt;
&lt;p&gt;I am done selling you my &lt;s&gt;scam&lt;/s&gt; game. Hopefully you found this post ludic and learned things along the reading. If you find any mistake or think of any potential improvement, please to do not hesitate to reach me.&lt;/p&gt;
&lt;p&gt;I would like to thanks the &lt;strong&gt;SwedenCpp team&lt;/strong&gt; for letting me having my talk on this project during one of their event. And I particularly would like to express my gratitude to &lt;a href="https://www.linkedin.com/in/alexandre-gordeev/"&gt;Alexandre Gourdeev&lt;/a&gt; who helped me improve &lt;strong&gt;Meta Crush Saga&lt;/strong&gt; in quite a few significant aspects.&lt;/p&gt;</content><category term="C++"></category><category term="C++17"></category><category term="TMP"></category><category term="meta programming"></category><category term="constexpr"></category></entry><entry><title>Trip report - Meeting C++ 2017</title><link href="https://jguegant.github.io/blogs/tech/trip-report-meetingcpp-2017.html" rel="alternate"></link><published>2017-11-16T23:09:00+01:00</published><updated>2017-11-16T23:09:00+01:00</updated><author><name>Jean Guegant</name></author><id>tag:jguegant.github.io,2017-11-16:/blogs/tech/trip-report-meetingcpp-2017.html</id><summary type="html">&lt;p&gt;Finally, after years of watching youtube videos on that topic, I made it to my first &lt;strong&gt;C++&lt;/strong&gt; international conference!
Thanks to my current employer &lt;a href="https://discover.king.com/about/"&gt;King&lt;/a&gt;, I went last week to &lt;a href="http://meetingcpp.com/"&gt;Meeting C++&lt;/a&gt; in &lt;strong&gt;Berlin&lt;/strong&gt;, which is, as far as I know, the biggest &lt;strong&gt;C++&lt;/strong&gt; event in Europe. I really enjoyed …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Finally, after years of watching youtube videos on that topic, I made it to my first &lt;strong&gt;C++&lt;/strong&gt; international conference!
Thanks to my current employer &lt;a href="https://discover.king.com/about/"&gt;King&lt;/a&gt;, I went last week to &lt;a href="http://meetingcpp.com/"&gt;Meeting C++&lt;/a&gt; in &lt;strong&gt;Berlin&lt;/strong&gt;, which is, as far as I know, the biggest &lt;strong&gt;C++&lt;/strong&gt; event in Europe. I really enjoyed my time there with few hundred other fellow &lt;strong&gt;C++&lt;/strong&gt; enthusiasts. In this post, I will try to relate how I experienced the event and dress a list of the must-watch talks.&lt;/p&gt;
&lt;h1&gt;About meeting C++:&lt;/h1&gt;
&lt;h2&gt;The concept:&lt;/h2&gt;
&lt;p&gt;&lt;img style="float: right;" width=200 height=250 src="https://jguegant.github.io/blogs/tech/images/badge.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;Held in the magnificient &lt;a href="http://meetingcpp.com/2017/Location.html"&gt;Andels Hotel&lt;/a&gt; in &lt;strong&gt;Berlin&lt;/strong&gt;, &lt;strong&gt;Meeting C++&lt;/strong&gt; offers the possibility to attend keynotes, talks and lightning talks (respectively lasting 2 hours, 50min and 5min) about our favourite language &lt;strong&gt;C++&lt;/strong&gt; for 3 days (one extra day added for the 6th edition of the event). &lt;strong&gt;C++&lt;/strong&gt; being multi-paradigm and a general-purpose programming language, the variety of the topics being discussed is pretty wide. It ranges from subject on "(Template) Meta-programming" to a deep dive on "How a C++ debugger work", from begginner friendly talks to hairy discussions on the yet-to-be-standardised white paper on &lt;strong&gt;std::expected&amp;lt;T, E&gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;As some talks happen simulteanously in different rooms, you cannot physically attend all the talks. Instead, you would usually prepare your own schedule by trying to guess the content of the talks from their summary. It is always a dilemna to choose between a topic that you like with the risk to have nothing new to learn, and a brand-new topic for you, where sleepness may kick-in midway to the presentation. If you are curious and daring, the lightning talks on the last day permit you to randomly discover antyhing about C++ in succint presentations. In any case, you can always catch-up the missed talks by checking the &lt;a href="https://www.youtube.com/user/MeetingCPP"&gt;Youtube channel&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Generally, I was not disapointed by the quality of the slides and the speakers. I picked up quite a few new concepts, prepared myself for the future of &lt;strong&gt;C++&lt;/strong&gt; (C++20) and refreshed myself on some fields I did not touch for a while.&lt;/p&gt;
&lt;h2&gt;More than just talks:&lt;/h2&gt;
&lt;p&gt;Where &lt;strong&gt;Meeting C++&lt;/strong&gt; really shines is in its capacity to gather roughly 600 passionated developers from various backgrounds (university, gaming industry, finance, Sillicon Valley's giants...) in one building and &lt;strong&gt;share&lt;/strong&gt;. Just share anything about C++, about reverse-engineering, about your job, about your country, about the german food in your plate! The C++ community represented at this event is very active, open-minded and willing to help. The catering between the sessions and the dinner parties permit you to meet anyone easily. The even team also oganises some really fun events&lt;/p&gt;
&lt;p&gt;In a room full of "world-class developers", it is easy to be intimidated, but you should not hesitate to reach them. They will not nitpick your words nor snob you. For some people, it is a dream to meet an Hollywood Star in the street, for me it was really delightful to have casual conversations with these "legendary" coders from the web.&lt;/p&gt;
&lt;h1&gt;The chief's suggestions of the day:&lt;/h1&gt;
&lt;p&gt;Here is a menu of most of the talks I attended. The legend is pretty simple:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;💀 : The difficulty of the talk (💀: Begginer friendly, 💀💀: Intermediate, 💀💀💀: High exposure to C++'s dark corners)&lt;/li&gt;
&lt;li&gt;★ : My interest for the talk (★: Good talk, ★★: Tasty talk, ★★★: Legendary talk)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I will not spoil all the talks, but simply try to give an overview of what you can expect within them. Note that all the talks are generally of high quality and my appreciation very subjective. I have seen people with very different "favorite talk".&lt;/p&gt;
&lt;h3&gt;[Keynote] Better Code: Human interface - By Sean Parent - 💀 ★★&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Slides: &lt;a href="https://github.com/sean-parent/sean-parent.github.io/blob/master/presentations/2017-11-09-human-interface/2017-11-09-human-interface.pdf"&gt;link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Video: &lt;a href=""&gt;coming-soon&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Sean Parent is a Principal Scientist at Adobe Systems and has been working on the famous software &lt;strong&gt;Photoshop&lt;/strong&gt; for more than 15 years. Sean Parent is a regular and prominent speaker at C++ conferences, one of his recently most famous talk being &lt;a href="https://www.youtube.com/watch?v=QGcVXgEVMJg"&gt;Better Code: Runtime Polyphormism&lt;/a&gt; from the same series of talks (Better Code) as the one he gave during &lt;strong&gt;Meeting C++&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Thorough his keynote, Sean was conveing the message that in order to have ergonomic human interfaces, you must design your code to reflects its usage through UI. By following such a principle, one can easily come-up with good namings, semantics and grouping of your UI components.&lt;/p&gt;
&lt;p&gt;For instance, Sean was explaining that most of the menu actions in &lt;strong&gt;Photoshop&lt;/strong&gt; somehow mapped some object, their methods, properties and most importantly their &lt;strong&gt;relations&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The menu action &lt;strong&gt;Create New Layer&lt;/strong&gt; will somehow call the constructor of a class called something like &lt;strong&gt;Layer&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Likewise the action &lt;strong&gt;Delete A Layer&lt;/strong&gt; would call its destructor.&lt;/li&gt;
&lt;li&gt;A selection in &lt;strong&gt;Photoshop&lt;/strong&gt; will most likely translate in a container of objects.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As a counter-example he explained that the old version of &lt;strong&gt;Gmail&lt;/strong&gt; used to have a confusing flow when it comes to the most trivial usage of a mail service: creating a mail. A &lt;strong&gt;link&lt;/strong&gt;, which implies &lt;strong&gt;navigation&lt;/strong&gt;, was used instead of &lt;strong&gt;button&lt;/strong&gt; for the "compose message" action.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Gmail failed compose button" src="https://jguegant.github.io/blogs/tech/images/gmail-failure.png"&gt;&lt;/p&gt;
&lt;p&gt;Sean put a strong emphasis that relationships are the most difficult part of an architecture to represent. He came up with few examples on how &lt;a href="http://en.cppreference.com/w/cpp/algorithm/stable_partition"&gt;std::stable_partition&lt;/a&gt; can be used to solve in an elegant way the gathering and display of items &lt;/p&gt;
&lt;p&gt;Overall a very nice talk, but on a very abstract topic, since not much has been explored on that subject yet! This is worth paying attention in game-programming where a good UI is a key-part of the success of a game.&lt;/p&gt;
&lt;h2&gt;[Talk] Threads and Locks must Go - Rainer Grimm - 💀💀 ★&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Slides: &lt;a href=""&gt;coming-soon&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Video: &lt;a href="https://www.youtube.com/watch?v=fkqVRzy4JhA"&gt;link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In this talk &lt;strong&gt;Rainer Grimm&lt;/strong&gt;, a German author of multiple &lt;a href="https://www.goodreads.com/author/show/7496329.Rainer_Grimm"&gt;C++ books&lt;/a&gt;, brought under the spotlight the concurrency features introduced by the new C++ standard &lt;strong&gt;C++17&lt;/strong&gt; and the coming one &lt;strong&gt;C++20&lt;/strong&gt;. Here is a short summary of my favourite features:&lt;/p&gt;
&lt;h3&gt;For C++17 (and concurrency TS):&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The new parallel algorithms in &lt;a href="http://en.cppreference.com/w/cpp/algorithm"&gt;&amp;lt;algorithm&gt;&lt;/a&gt; and the associated execution policies &lt;a href="http://en.cppreference.com/w/cpp/algorithm/execution_policy_tag_t"&gt;seq, par and par_unseq&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{...};&lt;/span&gt; &lt;span class="c1"&gt;// A bit vector... &lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;sort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;execution&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;par&lt;/span&gt;&lt;span class="p"&gt;{},&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;span class="c1"&gt;// Due to &amp;quot;par&amp;quot;, this **might** execute the sort in parallel using a thread pool of some sort.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;The new &lt;a href="http://en.cppreference.com/w/cpp/experimental/future"&gt;std::future&lt;/a&gt; interface which permits to add continuations to the shared state using the &lt;a href="http://en.cppreference.com/w/cpp/experimental/future/then"&gt;then member function&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;future&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;then&lt;/span&gt;&lt;span class="p"&gt;([](&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;future&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Will be called when f is done.&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// Will therefore not block.&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Hopefully for C++20:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The stackless &lt;a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4680.pdf"&gt;coroutines&lt;/a&gt; as implemented by MSVC and clang. This introduce two keywords &lt;strong&gt;co_await&lt;/strong&gt; and &lt;strong&gt;co_yield&lt;/strong&gt;. Considering the previous example using std::future, it could be rewritten in the following way:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;future&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;co_await&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// The continuation is &amp;quot;generated&amp;quot; by the compiler using the keyword co_await.&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Everything after co_await is implicitely part of the continuation.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;A new &lt;a href="http://en.cppreference.com/w/cpp/language/transactional_memory"&gt;synchronized keyword&lt;/a&gt; applying the transactional memory concept on a group of statements.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Global vars&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// Foo can be called by multiple thread simuteanously.&lt;/span&gt;
    &lt;span class="c1"&gt;// Reads-writes on x and y are now thread-safe and synchronized.&lt;/span&gt;
    &lt;span class="n"&gt;synchronized&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
        &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As explained by &lt;strong&gt;Rainer Grimm&lt;/strong&gt;, we will have the possibility to easily bring concurrency to our C++ codebases without ressorting to the low-level, and tricky to get right, features like thread and locks. While I appreciated the talk, it lacked a bit of novelty as I was already aware of most of the features.&lt;/p&gt;
&lt;h2&gt;[Talk] Strong types for strong interfaces - Johnathan Boccora -  💀 ★★★&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Related blog post: &lt;a href="https://www.fluentcpp.com/2016/12/08/strong-types-for-strong-interfaces/"&gt;link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Video: &lt;a href="https://www.youtube.com/watch?v=WVleZqzTw2k&amp;amp;t=1536s"&gt;link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A &lt;strong&gt;must watch&lt;/strong&gt;! Even when facing some technical issues,  &lt;strong&gt;Johnathan&lt;/strong&gt; is very good speaker and I was quickly captivated by the topic of &lt;strong&gt;strong types&lt;/strong&gt;. Jonathan is also a talented writer with his famous blog &lt;a href="https://www.fluentcpp.com/"&gt;fluentcpp&lt;/a&gt; (I would really suggest to have a look at it once in a while).&lt;/p&gt;
&lt;p&gt;As C++ developers, we heavily rely on the language's type system to express our intentions to other developers, to optimise our code and avoid shooting ourselves into our feet. Yet, we always reuse some &lt;strong&gt;types&lt;/strong&gt; to express very different properties of our system. For instance to describe a person, you would use an &lt;strong&gt;int&lt;/strong&gt; for her/his age and his/her weight. Did it ever come to you that the unit &lt;strong&gt;year&lt;/strong&gt; (for age) should be a very different type than &lt;strong&gt;kg&lt;/strong&gt; (for weight)? The concept of &lt;strong&gt;strong type&lt;/strong&gt; would solve this problem by introducing new int-compatible types:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt; &lt;span class="c1"&gt;// We need to have these empty tag types to create entirely new types and not just weakly-typed aliases.&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;kg&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;strong_type&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;KgTag&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;years&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;strong_type&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;YearsTag&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;unsafe_create_person&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;create_person&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;years&lt;/span&gt; &lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;kg&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Explicit interface.&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;age&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1337&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;unsafe_create_person&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Oops I inversed the arguments but no compiler error.&lt;/span&gt;

&lt;span class="n"&gt;create_person&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;years&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;kg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;)));&lt;/span&gt; &lt;span class="c1"&gt;// Much less error-prone.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As a bonus, &lt;strong&gt;strong types&lt;/strong&gt; can actually affect positively the performances of your codebase as the compiler can agressively optimise without violating &lt;a href="http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html"&gt;strict-aliasing rules&lt;/a&gt;, since the types are now strictly unrelated.&lt;/p&gt;
&lt;p&gt;This concept is not new and is already used in &lt;a href="http://en.cppreference.com/w/cpp/chrono"&gt;std::chrono&lt;/a&gt; or &lt;a href="http://www.boost.org/doc/libs/1_65_1/doc/html/boost_units.html"&gt;Boost.Unit&lt;/a&gt;, but it was really refreshing to have an explanation with simple words and good examples! I am now very keen to use this in my personal projects and at work too.&lt;/p&gt;
&lt;h2&gt;[Talk] How C++ Debuggers Work - Simon Brand (4/5) - 💀💀 ★★&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Related blog post: &lt;a href="https://blog.tartanllama.xyz/writing-a-linux-debugger-setup/"&gt;link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Video: &lt;a href="https://www.youtube.com/watch?v=Q3Rm95Mk03c"&gt;link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Simon Brand&lt;/strong&gt;, also known as &lt;a href="https://blog.tartanllama.xyz/"&gt;TartanLlama&lt;/a&gt; (a really fancy fictious name for a Scott), presented us how a mixture of calls to &lt;a href="http://man7.org/linux/man-pages/man2/ptrace.2.html"&gt;ptrace&lt;/a&gt;, injection of the &lt;a href="https://en.wikipedia.org/wiki/INT_(x86_instruction)"&gt;int3 opcode&lt;/a&gt;, parsing of the &lt;a href="https://en.wikipedia.org/wiki/DWARF"&gt;DWARF format&lt;/a&gt; and perseverance is the base to create a debugger on a &lt;strong&gt;x86&lt;/strong&gt;(_64) architecture with a &lt;strong&gt;Unix&lt;/strong&gt; platform (or &lt;strong&gt;Linux&lt;/strong&gt; platform only if you OS specific calls like &lt;a href="http://man7.org/linux/man-pages/man2/process_vm_readv.2.html"&gt;process_vm_readv, process_vm_writev&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Unlike some of the other talks, it would be hard to give succinct code examples, but I trully appreciated his presentation! When it comes to low-level APIs for debbuging and reverse-engineering, I have a better understanding of the Windows platform. I think that &lt;strong&gt;Simon&lt;/strong&gt; did an excellent job to help me transfer my knowledge to the Unix world.&lt;/p&gt;
&lt;p&gt;If one day I have to tackle the creation of a debugger on Unix, I would certainely come back to this talk or follow his series of &lt;a href="https://blog.tartanllama.xyz/writing-a-linux-debugger-setup/"&gt;blog posts&lt;/a&gt; on the same subject. I also think that as programmer, it is always beneficial to have some knowledge on the underlying mechanims of the tools you use (gdb, or lldb in that case). I would, therefore suggest to watch that talk to any C++ enthusiast willing to progress in their art of programming.&lt;/p&gt;
&lt;h3&gt;[Talk] The Three Little Dots and the Big Bad Lambdas - Joel Falcou - 💀💀💀 ★★★&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Slides: &lt;a href=""&gt;coming-soon&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Video: &lt;a href="https://www.youtube.com/watch?v=WU5v4FT7CMM"&gt;link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I am always excited by watching a talk from &lt;a href="https://twitter.com/joel_f?lang=en"&gt;Joel Falcou&lt;/a&gt;: he is a venerable (template) metra-programmer wizzard with a very didactic approach to explain things (and also we share the same nationality \O/). Once again, I was not disapointed by his session.&lt;/p&gt;
&lt;p&gt;With a lot of humour, Joel introduced a new facet to &lt;strong&gt;meta-programming&lt;/strong&gt; in C++. We used to have &lt;a href="https://en.wikipedia.org/wiki/Template_metaprogramming"&gt;template meta-programming&lt;/a&gt; to manipulate types at compile-time (and with difficulties values), then came &lt;a href="http://en.cppreference.com/w/cpp/language/constexpr"&gt;constexpr&lt;/a&gt; to ease value computation, and recently a &lt;strong&gt;Louis Dionne&lt;/strong&gt; came-up with a powerful combo of these two cadrants with &lt;a href="http://www.boost.org/doc/libs/1_61_0/libs/hana/doc/html/index.html#tutorial-introduction-quadrants"&gt;Boost.Hana&lt;/a&gt;. &lt;strong&gt;Joel&lt;/strong&gt; statement was that &lt;a href="http://en.cppreference.com/w/cpp/language/lambda"&gt;lambdas expressions&lt;/a&gt; combined with &lt;a href="http://en.cppreference.com/w/cpp/language/auto"&gt;auto&lt;/a&gt; and &lt;a href="http://en.cppreference.com/w/cpp/language/parameter_pack"&gt;parameter packs&lt;/a&gt; are powerful enough to replace some cases where we would have resort to use &lt;strong&gt;template meta-programming&lt;/strong&gt; or the uglier infamous &lt;strong&gt;macros&lt;/strong&gt;! &lt;strong&gt;Joel&lt;/strong&gt; came to that conclusion after being inspired by the language &lt;a href="http://okmij.org/ftp/ML/MetaOCaml.html"&gt;MetaOCaml&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Let's say that you want to fill a vector with push-back instruction generated at compile-time:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;tuple&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;array&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;utility&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;F&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;apply_imp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;F&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;index_sequence&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;I&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;I&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;...);&lt;/span&gt; &lt;span class="c1"&gt;// C++17 fold expression.&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;F&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;apply&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;F&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;apply_imp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;make_index_sequence&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;{});&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;bob&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;bind&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="k"&gt;auto&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;](&lt;/span&gt;&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;push_back&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bob&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="k"&gt;auto&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="p"&gt;});&lt;/span&gt;

&lt;span class="n"&gt;apply&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;// Will generate at compile time:&lt;/span&gt;
&lt;span class="c1"&gt;// bob.push_back(0);&lt;/span&gt;
&lt;span class="c1"&gt;// bob.push_back(3);&lt;/span&gt;
&lt;span class="c1"&gt;// bob.push_back(6);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This example is fairly trivial and there would be a high chance that you would reach the same assembly output using a simple &lt;strong&gt;for loop&lt;/strong&gt;. But it is very interesting to notice that &lt;strong&gt;lambdas&lt;/strong&gt; are reusable type-safe &lt;strong&gt;units of code&lt;/strong&gt; that you transport, combine and "instantiate" at any time. Performance-wise, &lt;strong&gt;lambdas&lt;/strong&gt; are pretty incredible according to Joel's measurement on his linear-algebra project. &lt;strong&gt;C++17&lt;/strong&gt; &lt;strong&gt;constexpr lambdas&lt;/strong&gt; could also help on that topic. One drawback might be the debugging complexity when navigating in nested lambdas. I still need to wrap my head around this new concept and I am eager to rewatch Joel's talk to explore it more!&lt;/p&gt;
&lt;h2&gt;[Keynote] Its complicated! - Kate Gregory - 💀 ★★★&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Slides: &lt;a href=""&gt;coming-soon&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Video: &lt;a href="https://www.youtube.com/watch?v=tTexD26jIN4"&gt;link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;While excellent, &lt;a href="http://www.gregcons.com/kateblog/"&gt;Kate&lt;/a&gt;'s keynote would be very hard to summarise correctly within few paragraphs. It makes you reflect on the difficulties to introduce &lt;strong&gt;C++&lt;/strong&gt; to newcomers. You would hope that there is a subset of the language that could be easily assimilate by anyone, &lt;strong&gt;Kate&lt;/strong&gt; argues that the reality is sadly more &lt;strong&gt;complicated&lt;/strong&gt; than that. Just have a look at how long are the &lt;a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#fcall-parameter-passing"&gt;C++ core guidelines&lt;/a&gt; on passing parameters to function calls. One day or another, a begginer must learn on how to pass parameters with good semantics and in an optimised fashio. Well, good luck to her/him! On the other hand, it does not mean that the language could have been designed in a simpler way. What we should strive for instead might be better naming of these concepts: the acronym &lt;a href="http://en.cppreference.com/w/cpp/language/raii"&gt;RAII (Resource Acquisition Is Initialization)&lt;/a&gt; is obviously not as straightforward as &lt;a href="https://en.wikipedia.org/wiki/Copy-on-write"&gt;COW (Copy-on-write)&lt;/a&gt;. Whether you are a "newbie" or the best "lead over-engineer" of your company, this talk is really worth a look!&lt;/p&gt;
&lt;h2&gt;[Talk] There Is A New Future - Felix Petriconi - 💀💀 ★★&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Slides: &lt;a href=""&gt;coming-soon&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Video: &lt;a href="https://www.youtube.com/watch?v=vDmQlIeY4z0"&gt;link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="https://petriconi.net/?author=1"&gt;Felix Petriconi&lt;/a&gt; and &lt;strong&gt;Sean Parent&lt;/strong&gt; have been working on a the &lt;a href="http://stlab.cc/libraries/concurrency/"&gt;stlab&lt;/a&gt; library for quite some time. &lt;strong&gt;stlab&lt;/strong&gt; takes the best of the various &lt;strong&gt;future&lt;/strong&gt; implementations &lt;a href="http://en.cppreference.com/w/cpp/thread/future"&gt;std::future (C++11)&lt;/a&gt;, &lt;a href="http://en.cppreference.com/w/cpp/thread/future"&gt;std::future (C++14)&lt;/a&gt; or &lt;a href="http://www.boost.org/doc/libs/1_65_0/doc/html/thread/synchronization.html#thread.synchronization.futures"&gt;boost::future&lt;/a&gt;, and adds a bit of it owns features on top of it. For instance, &lt;strong&gt;stlabs&lt;/strong&gt; supports passing explicit executors to control where &lt;a href="http://stlab.cc/libraries/concurrency/future/async.html"&gt;async&lt;/a&gt; will execute the tasks, and where the continuation associated with &lt;a href="http://stlab.cc/libraries/concurrency/future/future/then.html"&gt;then&lt;/a&gt; will be executed too. &lt;strong&gt;Executors&lt;/strong&gt; are akin to &lt;strong&gt;event-loops&lt;/strong&gt; (or message-pumps in the .Net world) that will process the tasks.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// This task will be executed on ``an_executor``&lt;/span&gt;
&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;stlab&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;async&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;an_executor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;});&lt;/span&gt;

&lt;span class="c1"&gt;// The continuation on another executor.&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;then&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;another_executor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;While &lt;strong&gt;executors&lt;/strong&gt; are present in &lt;a href="http://www.boost.org/doc/libs/1_65_1/doc/html/thread.html"&gt;Boost.Thread&lt;/a&gt;, &lt;strong&gt;stlabs's&lt;/strong&gt; &lt;a href="http://stlab.cc/libraries/concurrency/channel/channel.html"&gt;channels&lt;/a&gt; are unique to this &lt;strong&gt;future&lt;/strong&gt; library. &lt;strong&gt;Channels&lt;/strong&gt; are one of the Go language's favorite &lt;a href="https://gobyexample.com/channels"&gt;toy&lt;/a&gt;. It is a neat way to create communication between a &lt;strong&gt;sender&lt;/strong&gt; and a &lt;strong&gt;receiver&lt;/strong&gt; on different &lt;strong&gt;executors&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;sender&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;receiver&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;channel&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;receive_executor&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Create the link.&lt;/span&gt;

&lt;span class="n"&gt;receiver&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;// Define what should happen at the reception.&lt;/span&gt;

&lt;span class="c1"&gt;// Establish the connections.&lt;/span&gt;
&lt;span class="n"&gt;receiver&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;set_ready&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

&lt;span class="n"&gt;sender&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Sent 42 through the channel.&lt;/span&gt;
&lt;span class="c1"&gt;// Receiver will print 42 when executing the task.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I really like some of the features in &lt;strong&gt;stlabs&lt;/strong&gt;, hopefully this could be incorporated into the &lt;strong&gt;C++&lt;/strong&gt; standard (the executors are down in the pipe of the standardisation process).&lt;/p&gt;
&lt;h3&gt;[Talk] Introduction to proposed std::expected&lt;T, E&gt; - Niall Douglas - 💀💀💀 ★&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Slides: &lt;a href=""&gt;coming-soon&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Video: &lt;a href="https://www.youtube.com/watch?v=JfMBLx7qE0I"&gt;link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Are you the kind of person that would rather have errors on the return values rather than using &lt;strong&gt;exceptions&lt;/strong&gt;. &lt;a href="https://twitter.com/ned14?lang=en"&gt;Niall&lt;/a&gt; has a solution for you: &lt;a href="https://github.com/viboes/std-make/blob/master/doc/proposal/expected/p0323r3.pdf"&gt;std::expected&amp;lt;T, E&gt;&lt;/a&gt;. You can see &lt;strong&gt;std::expected&amp;lt;T, E&gt;&lt;/strong&gt; either as a &lt;a href="http://en.cppreference.com/w/cpp/utility/optional"&gt;std::optional&amp;lt;T&gt;&lt;/a&gt; with a empty state containing an error for being empty, or as a &lt;a href="http://en.cppreference.com/w/cpp/utility/variant"&gt;std::variant&amp;lt;T, E&gt;&lt;/a&gt; where you agree that the first alternative is the return value and the second alternative is the potential error. Example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;expected&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;make_unexpected&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;x &amp;lt; 0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// Prints &amp;quot; x &amp;lt; 0&amp;quot;.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;std::expected&lt;/strong&gt; starts to be cumbersome to use when combining or propogating returned results. To palliate this problem, &lt;strong&gt;std::expected&lt;/strong&gt; exposes a &lt;a href="https://en.wikipedia.org/wiki/Monad_(functional_programming)"&gt;Monad interface&lt;/a&gt;, with the bind member function coming directly to your mind. If you are a Haskell user, &lt;strong&gt;std::expected&lt;/strong&gt; should remind you of the &lt;a href="https://en.wikibooks.org/wiki/Haskell/Understanding_monads/Maybe"&gt;Maybe Monad&lt;/a&gt;. Using &lt;strong&gt;bind&lt;/strong&gt; is still verbose and hopefully we obtain a dedicated keyword &lt;strong&gt;try&lt;/strong&gt; to ease our pain.&lt;/p&gt;
&lt;h2&gt;[Talk] The most valuable values - Juan Pedro Bolívar Puente - 💀💀 ★★&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Slides: &lt;a href=""&gt;coming-soon&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Video: &lt;a href=""&gt;coming-soon&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;During his presentation, &lt;a href="https://sinusoid.es/do"&gt;Juan&lt;/a&gt; actively promoted &lt;a href="https://isocpp.org/wiki/faq/value-vs-ref-semantics#val-vs-ref-semantics"&gt;value semantic over reference semantic&lt;/a&gt; and did so with some analogies from our physical world (from our dear philosopher Platos) and code examples. The talk quickly moved onto immutability and functionnal programming applied to user interfaces. There is a trend in the web sphere to follow a software architectural pattern called &lt;a href="https://facebook.github.io/flux/"&gt;flux&lt;/a&gt; with a main implementation the &lt;a href="https://redux.js.org/"&gt;redux&lt;/a&gt; framework. Arguably, &lt;strong&gt;flux&lt;/strong&gt; is a glorified good old &lt;a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller"&gt;MVC (Model View Controller) architecture&lt;/a&gt; with a strong emphasis on the immutability of the &lt;strong&gt;model&lt;/strong&gt; and strict &lt;strong&gt;flow&lt;/strong&gt; on the interactions between the components of &lt;strong&gt;MVC&lt;/strong&gt;. &lt;strong&gt;Model&lt;/strong&gt;, &lt;strong&gt;View&lt;/strong&gt; and &lt;strong&gt;Controller&lt;/strong&gt; also get respectively renamed to &lt;strong&gt;Store&lt;/strong&gt;, &lt;strong&gt;View&lt;/strong&gt; and &lt;strong&gt;Dispatcher&lt;/strong&gt;. An action submitted to the &lt;strong&gt;Dispatcher&lt;/strong&gt; will update the &lt;strong&gt;Store&lt;/strong&gt; with a new &lt;strong&gt;Store&lt;/strong&gt; in a determinstic way, which will imply a redraw of the &lt;strong&gt;View&lt;/strong&gt;. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Juan&lt;/strong&gt; succeeded to mimic &lt;strong&gt;redux&lt;/strong&gt; in the &lt;strong&gt;C++&lt;/strong&gt; world using his library &lt;a href="https://sinusoid.es/immer/"&gt;immer&lt;/a&gt;. To demonstrate the capabilities of his library, &lt;strong&gt;Juan&lt;/strong&gt; recreated an emacs-like &lt;a href="https://github.com/arximboldi/ewig"&gt;editor&lt;/a&gt;. The beauty of having an immutable &lt;strong&gt;Store&lt;/strong&gt; is truly expressed in the &lt;strong&gt;time-traveling machine&lt;/strong&gt; that you can create from it: by saving all the states of the &lt;strong&gt;Store&lt;/strong&gt;, you can easily come back to a previous state of your application (similar to undo / redo). You should absolutely watch the video to understand how easy it seems to implement this. On top of that you will have the chance to watch what might be the most audacious ending of a &lt;strong&gt;C++&lt;/strong&gt; talk I have ever seen.&lt;/p&gt;
&lt;h2&gt;[Talk] Reactive Equations - André Bergner - 💀💀💀 ★★★&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Github project: &lt;a href="https://github.com/andre-bergner/zignal/tree/master/reactive_equations"&gt;link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Video: &lt;a href="https://www.youtube.com/watch?v=QYNRoeWJuAw"&gt;link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As a meta-programmer aficionado, this was the most "devilish" talk, and therefore highly thrilling, I attended during the event. It was not the first time I heard from &lt;strong&gt;André Bergner&lt;/strong&gt;, he attended the cppcon in 2015 and I remembered that he &lt;a href="https://www.youtube.com/watch?v=zVLLdGlbCSw"&gt;presented&lt;/a&gt; a nice way to have &lt;a href="https://en.wikipedia.org/wiki/Currying"&gt;currying&lt;/a&gt; on your function. This time, &lt;strong&gt;André&lt;/strong&gt; focused on reactive equations. If this sounds foreign to you, you might be more familiar with &lt;a href="https://en.wikipedia.org/wiki/Data_binding"&gt;data binding&lt;/a&gt; in &lt;a href="http://doc.qt.io/qt-5/qtqml-javascript-expressions.html#javascript-in-property-bindings"&gt;Qt QML&lt;/a&gt; using Javascript expression. &lt;strong&gt;André&lt;/strong&gt;'s reactive equations are similar but with simpler expressions:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// ***** Using a pseudo-language, let&amp;#39;s define the equations *****&lt;/span&gt;
&lt;span class="nl"&gt;x&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;float&lt;/span&gt;
&lt;span class="nl"&gt;y&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;float&lt;/span&gt;
&lt;span class="nl"&gt;z&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;float&lt;/span&gt;

&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt; &lt;span class="c1"&gt;// When x is updated, y will be automatically updated.&lt;/span&gt;
&lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="c1"&gt;// When y or x is updated, z will be automatically updated.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You may notice that I didn't write any &lt;strong&gt;C++&lt;/strong&gt; code. By default &lt;strong&gt;C++&lt;/strong&gt; would not permit to have expressions that update themselves by "magic" if one variable changes. You could write the update logic manually, but with a lot of long equations, this becomes very error prone. Instead &lt;strong&gt;André&lt;/strong&gt; created a &lt;a href="https://en.wikipedia.org/wiki/Domain-specific_language"&gt;DSL (Domain Specific Language)&lt;/a&gt;, which is equivalent to create a language within &lt;strong&gt;C++&lt;/strong&gt; itself. To define his DSL, &lt;strong&gt;André&lt;/strong&gt; used &lt;a href="https://en.wikipedia.org/wiki/Expression_templates"&gt;expression templates&lt;/a&gt;. &lt;strong&gt;Expression templates&lt;/strong&gt; are tricky creatures, which roughly consist in encapsulating &lt;strong&gt;C++&lt;/strong&gt; expressions into a type at compile-time. This type will retain all the operators / functions (let's call them operations) that you applied in your expression. These operations can be queried at compile-time to generate other expression that you will execute at runtime. In &lt;strong&gt;André&lt;/strong&gt;'s case, the encapsulated operations from his reactive equations would be used to automagically generate the update logic. To facilitate his task, &lt;strong&gt;André&lt;/strong&gt; heavily relied on &lt;a href="http://www.boost.org/doc/libs/1_65_1/doc/html/proto.html"&gt;Boost.Proto&lt;/a&gt;. If you are versed in the art of meta-programming, this will certainely be entertaining to you!&lt;/p&gt;
&lt;h2&gt;[Talk] Free your functions - Klaus Iglberger - 💀 ★★★&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Slides: &lt;a href="https://github.com/CppCon/CppCon2017/raw/master/Presentations/Free%20Your%20Functions/Free%20Your%20Functions%20-%20Klaus%20Iglberger%20-%20CppCon%202017.pdf"&gt;link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Video: &lt;a href="https://www.youtube.com/watch?v=nWJHhtmWYcY"&gt;link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This was a glorious hymn to our beloved free functions by &lt;a href="https://www.linkedin.com/in/klaus-iglberger-2133694/"&gt;Klaus Iglberger&lt;/a&gt;. Programmers often resort to use &lt;strong&gt;member functions&lt;/strong&gt; and inheritance to provide polyphormism in &lt;strong&gt;C++&lt;/strong&gt;, often overlooking that &lt;strong&gt;free functions&lt;/strong&gt; and &lt;strong&gt;overloading&lt;/strong&gt; would be a smarter choice.&lt;/p&gt;
&lt;p&gt;Let's take a situation where you would need to implement a &lt;strong&gt;serialise&lt;/strong&gt; function for a bunch of unrelated types. Would rather use the implementation &lt;strong&gt;1&lt;/strong&gt;?&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;serialisable&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;serialisable&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;serialise&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nl"&gt;A&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;serialisable&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;serialise&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;override&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* return something... */&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nl"&gt;B&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;serialisable&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;serialise&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;override&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* return something... */&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Or the solution &lt;strong&gt;2&lt;/strong&gt;?&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;

&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;serialise&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* return something... */&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;serialise&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* return something... */&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As &lt;strong&gt;Kate&lt;/strong&gt; explained, it is complicated! If you are looking for &lt;strong&gt;runtime polyphormism&lt;/strong&gt;, then you will certainely use the solution &lt;strong&gt;1&lt;/strong&gt;. If not, the solution &lt;strong&gt;2&lt;/strong&gt; is actually preferable. It has a lot of advantages that &lt;strong&gt;Klaus&lt;/strong&gt; explained for one full hour. My favorite one being that you can extend your polyphormism to types that you do not own. Let's say that you want to serialise &lt;strong&gt;std::vector&lt;/strong&gt;, you can simply write an overload for it:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;serialise&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* return something... */&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In practice, nothing prevent you from mixing a both solutions to your needs. One counter-argument being that &lt;strong&gt;free functions&lt;/strong&gt; have an ugly syntax: &lt;code&gt;v.serialise();&lt;/code&gt; feels more natural than &lt;code&gt;serialize(v);&lt;/code&gt;. That issue could have been solve with the &lt;a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0251r0.pdf"&gt;unified call syntax&lt;/a&gt; proposal by &lt;strong&gt;Bjarne Stroustrup&lt;/strong&gt; and &lt;strong&gt;Herb Sutter&lt;/strong&gt;. Sadly, it was rejected by the &lt;strong&gt;C++&lt;/strong&gt; committee.&lt;/p&gt;
&lt;h2&gt;[Talk] Reader-Write Lock versus Mutex - Understanding a Lost Bet - Jeffrey Mendelsohn - 💀💀💀 ★★&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Slides: &lt;a href=""&gt;coming-soon&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Video: &lt;a href="https://www.youtube.com/watch?v=GzLsHTgZ-XI"&gt;link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="https://www.linkedin.com/in/jeffrey-mendelsohn-ph-d-8417454"&gt;Jeffrey Mendelson&lt;/a&gt; from &lt;strong&gt;Bloomberg&lt;/strong&gt; had a bet with a colleague on whether a &lt;a href="https://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock"&gt;readers-writer lock&lt;/a&gt; would be faster than a &lt;a href="https://en.wikipedia.org/wiki/Lock_(computer_science)"&gt;mutex&lt;/a&gt; to protect the access on a &lt;strong&gt;resource&lt;/strong&gt; that could be written by a single writer, but could have multiple readers simultaneously. The &lt;strong&gt;readers-writer lock&lt;/strong&gt; would follow exactly that behaviour (multiple readers, single writer). The &lt;strong&gt;mutex&lt;/strong&gt; would keep the exclusivity to one writer or one reader only! &lt;strong&gt;Jeffrey&lt;/strong&gt; lost the bet, but that did not hindered him from exploring the reasons behind his lost. It was challenging for me to grasp all the implications on this topic, but here is what I understood:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Jeffrey&lt;/strong&gt;'s &lt;strong&gt;reader-writer lock&lt;/strong&gt; was made of &lt;a href="http://en.cppreference.com/w/cpp/atomic/atomic"&gt;atomic variables&lt;/a&gt; to keep track of the amount of readers and writers. If the &lt;strong&gt;resource&lt;/strong&gt; was currently written onto, the &lt;strong&gt;readers&lt;/strong&gt; and other &lt;strong&gt;writers&lt;/strong&gt; would wait onto a semaphor to be waken-up later on.&lt;/li&gt;
&lt;li&gt;If the amount of time spent by the &lt;strong&gt;readers&lt;/strong&gt; or the &lt;strong&gt;writers&lt;/strong&gt; on the resource is fairly long, the &lt;strong&gt;readers-writer lock&lt;/strong&gt; will actually perform better than the &lt;strong&gt;mutex&lt;/strong&gt; as multiple &lt;strong&gt;reader&lt;/strong&gt; can process simultanesouly.&lt;/li&gt;
&lt;li&gt;On the other hand, if the &lt;strong&gt;writing&lt;/strong&gt; and &lt;strong&gt;reading operations&lt;/strong&gt; are very fast, the &lt;strong&gt;atomic operations&lt;/strong&gt; on the counters will start to be costly comparatively. &lt;strong&gt;Atomics&lt;/strong&gt; tend to have nonnegligible effects on the cache lines of your CPU(s). In this case, loosing the ability to have multiple &lt;strong&gt;readers&lt;/strong&gt; is actually not as dramatic as you would think in comparison of stressing your cache.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Jeffrey&lt;/strong&gt; came up with an hybrid solution that combines both a &lt;strong&gt;readers-writer lock&lt;/strong&gt; and a fallback to a &lt;strong&gt;mutex&lt;/strong&gt; that outperformed the previous solutions.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Once the video of this talk is uploaded, I must have a complete rewatch of it. It always amusing that our intuitions can be entirely wrong when it comes to concurrency and programming.  &lt;/p&gt;
&lt;h2&gt;[Other] The not-so-secret lightning talks&lt;/h2&gt;
&lt;p&gt;Videos: &lt;a href="https://www.youtube.com/watch?v=ARosL9xrozk"&gt;link&lt;/a&gt;, &lt;a href="https://www.youtube.com/watch?v=UNSkp6KpMNk"&gt;link&lt;/a&gt;, &lt;a href="https://www.youtube.com/watch?v=2KGkcGtGVM4"&gt;link&lt;/a&gt;, &lt;a href="https://www.youtube.com/watch?v=rj_BSmixRYg"&gt;link&lt;/a&gt;, &lt;a href="https://www.youtube.com/watch?v=Kq8lOymvRcE"&gt;link&lt;/a&gt;, &lt;a href="https://www.youtube.com/watch?v=7GIZN03-_6w"&gt;link&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Before the last Keynote, we had the pleasure to listen to some not-so-unexpected lightning talks. I will not spoil too much of it!&lt;/p&gt;
&lt;p&gt;I just want to express my gratitude to &lt;strong&gt;Guy Davidson&lt;/strong&gt; and &lt;strong&gt;Sean Parent&lt;/strong&gt; for bringing &lt;strong&gt;diversity in the C++ community&lt;/strong&gt; under the spotlight. It was more than welcome and I am glad of these initiatives. &lt;/p&gt;
&lt;h1&gt;Conclusion:&lt;/h1&gt;
&lt;p&gt;Once again, I was amazed by the &lt;strong&gt;C++&lt;/strong&gt; community and how a group of dedicated persons can build such nice event. I am already eager to fly to one of the big conference next year: &lt;strong&gt;Meeting C++&lt;/strong&gt; or &lt;strong&gt;cppcon&lt;/strong&gt;. I would also encourage anyone with a bit of passion for this language or programming in general to give a try to conferences or local groups, you will discover more than you would expect!&lt;/p&gt;</content><category term="C++"></category><category term="C++"></category><category term="event"></category><category term="meetingcpp"></category></entry><entry><title>An introduction to C++'s variadic templates: a thread-safe multi-type map</title><link href="https://jguegant.github.io/blogs/tech/thread-safe-multi-type-map.html" rel="alternate"></link><published>2016-02-01T14:00:00+01:00</published><updated>2016-02-01T14:00:00+01:00</updated><author><name>Jean Guegant</name></author><id>tag:jguegant.github.io,2016-02-01:/blogs/tech/thread-safe-multi-type-map.html</id><summary type="html">&lt;h3&gt;Trivia:&lt;/h3&gt;
&lt;p&gt;One of our favorite motto in our C++ team at work is: you shall use &lt;strong&gt;dependency injections&lt;/strong&gt; instead of &lt;strong&gt;singletons&lt;/strong&gt;! It actually comes with our unit-testing strategy. If the various components of your architecture are too tightly coupled, it becomes a tremendous effort to deeply test small critical chunks …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Trivia:&lt;/h3&gt;
&lt;p&gt;One of our favorite motto in our C++ team at work is: you shall use &lt;strong&gt;dependency injections&lt;/strong&gt; instead of &lt;strong&gt;singletons&lt;/strong&gt;! It actually comes with our unit-testing strategy. If the various components of your architecture are too tightly coupled, it becomes a tremendous effort to deeply test small critical chunks of your code. &lt;strong&gt;Singletons&lt;/strong&gt; are that kind of beast that revives itself without your permission and comes from hell to haunt your lovely unit-tests. Our main project being multi-threaded (hence highly bug-prone) and vital for the company, "&lt;strong&gt;singleton&lt;/strong&gt;" became a forbidden word. Yet, our team recently started going down the dark path. Thanks to C++11 and its variadic templates, I carefully crafted a &lt;strong&gt;thread-safe multi-type map container&lt;/strong&gt; that simplified our configuration reloading system and saved us from the dark side of the coder force. If you always wondered what are &lt;strong&gt;variadic templates&lt;/strong&gt;, how &lt;strong&gt;C++11's tuples&lt;/strong&gt; can be implemented, I am going to present these concepts in this post using my container as a cobaye.&lt;/p&gt;
&lt;p&gt;Note: for the sake of your sanity and the fact that &lt;em&gt;errare humanum est&lt;/em&gt;, this article might not be 100% accurate!&lt;/p&gt;
&lt;h3&gt;Why would I use a thread-safe multi-type map?&lt;/h3&gt;
&lt;p&gt;Let me explain our odyssey: we are working on a highly modular and multi-threaded application. One of its core feature is the ability to reload various configuration files or assets used by some components spread accross many threads and a giant hierarchy of objects. The reloading process is automic using Linux's &lt;a href="http://man7.org/linux/man-pages/man7/inotify.7.html"&gt;inotify&lt;/a&gt; monitoring filesystem events. One thread is dedicated to the reception of filesystem events and must react accordingly by parsing any changes and pushing them to other threads. At first, we used, to pass-by any newly parsed asset, some thread-safe &lt;strong&gt;queues&lt;/strong&gt; or something analog to &lt;a href="https://tour.golang.org/concurrency/2"&gt;go channels&lt;/a&gt;. Since we did not want to use &lt;strong&gt;singletons&lt;/strong&gt;, we had to pass references to our queues all along our object hierarchy. Sadly, our &lt;strong&gt;queue&lt;/strong&gt; implementation is &lt;strong&gt;one to one&lt;/strong&gt; and supports only &lt;strong&gt;one type&lt;/strong&gt;, none of our config/asset types share the same &lt;strong&gt;base-type&lt;/strong&gt;. For each asset type and each component using this asset, we had to create a new &lt;strong&gt;queue&lt;/strong&gt; and pass-it all along our hierarchy. That is certainely not convenient! What we really wanted was a hybrid class between a &lt;a href="http://en.cppreference.com/w/cpp/container/map"&gt;std::map&lt;/a&gt; and a &lt;a href="http://en.cppreference.com/w/cpp/utility/tuple"&gt;std::tuple&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;We could have used a &lt;strong&gt;std::map&lt;/strong&gt; with &lt;a href="http://www.boost.org/doc/libs/1_60_0/doc/html/variant.html"&gt;Boost.Variant&lt;/a&gt; to store our items, using a type like the following &lt;strong&gt;"std::map&amp;lt; std::string, std::shared_ptr&amp;lt; Boost.Variant &amp;lt; ConfigType1, ConfigType2&amp;gt;&amp;gt;&amp;gt;"&lt;/strong&gt;. &lt;strong&gt;Boost.Variant&lt;/strong&gt; permits to encapsulate a &lt;strong&gt;heterogeneous set of types&lt;/strong&gt; without &lt;strong&gt;common base-type or base-class&lt;/strong&gt;, which solves one of our point. Another solution would be to encapsulate manually all our configuration classes in the same familly of classes, that is pretty cumbersome. But anyway, &lt;strong&gt;std::map&lt;/strong&gt; does not guaranty any safety if you are writing and reading at the same time on a map slot. Secondly, &lt;strong&gt;std::shared_ptr&lt;/strong&gt; does guaranty a thread-safe destruction of the pointee object (i.e: the reference counter is thread-safe) but nothing for the &lt;strong&gt;std::shared_ptr&lt;/strong&gt; object itself. It means that copying a &lt;strong&gt;std::shared_ptr&lt;/strong&gt; that could potentially be modified from another thread, might lead to an undefined behaviour. Even if we were to encapsulate all these unsafe accesses with mutexes, we are still lacking a nice mechanism to get update notifications for our objects. We do not want to constantly poll the latest version and propagate it through our code. And finally, if that solution were elegant enough, why would I currently write this blog post?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C++11&lt;/strong&gt; brings another collection type called &lt;strong&gt;std::tuple&lt;/strong&gt;. It permits to store a set of elements of &lt;strong&gt;heterogeneous types&lt;/strong&gt;. Take a look at this short example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;myTuple&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;make_tuple&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Foo&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1337&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;myTuple&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Access element by index: &amp;quot;Foo&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;myTuple&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Access element by index: 1337&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;myTuple&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Access element by index: 42&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;myTuple&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Access element by type: &amp;quot;Foo&amp;quot;&lt;/span&gt;

&lt;span class="c1"&gt;// compilation error: static_assert failed &amp;quot;tuple_element index out of range&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;myTuple&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// compilation error: static_assert failed &amp;quot;type can only occur once in type list&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;myTuple&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;Tuples&lt;/strong&gt; are that kind of &lt;strong&gt;C++11&lt;/strong&gt; jewelry that should decide your old-fashioned boss to upgrade your team's compiler (and his ugly tie). Not only I could store a &lt;strong&gt;const char* &lt;/strong&gt; and two &lt;strong&gt;ints&lt;/strong&gt; without any compiling error, but I could also access them using compile-time mechanisms. In some way, you can see tuples as a compile-time map using indexes or types as keys to reach its elements. You cannot use an index out of bands, it will be catched at compile-time anyway! Sadly, using a type as a key to retrieve an element is only possible if the type is unique in the &lt;strong&gt;tuple&lt;/strong&gt;. At my work, we do have few config objects sharing the same class. Anyway, tuples weren't fitting our needs regarding thread safety and update events. Let's see what we could create using tasty &lt;strong&gt;tuples&lt;/strong&gt; as an inspiration.&lt;/p&gt;
&lt;p&gt;Note that some &lt;strong&gt;tuples&lt;/strong&gt; implementations were already available before &lt;strong&gt;C++11&lt;/strong&gt;, notably in &lt;a href="http://www.boost.org/doc/libs/1_60_0/libs/tuple/doc/tuple_users_guide.html"&gt;boost&lt;/a&gt;. &lt;strong&gt;C++11&lt;/strong&gt; variadic templates are just very handy, as you will see, to construct such a class.&lt;/p&gt;
&lt;h3&gt;A teaser for my repository class:&lt;/h3&gt;
&lt;p&gt;To keep your attention for the rest of this post, here is my &lt;strong&gt;thread-safe multi-type map&lt;/strong&gt; in action:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;memory&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;quot;repository.hpp&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="c1"&gt;// Incomplete types used as compile-time keys.&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Key1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Key2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// Create a type for our repository.&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;MyRepository&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Repository&lt;/span&gt;
    &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;
        &lt;span class="n"&gt;Slot&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// One slot for std::string.&lt;/span&gt;
        &lt;span class="n"&gt;Slot&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Key1&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Two slots for int.&lt;/span&gt;
        &lt;span class="n"&gt;Slot&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Key2&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="c1"&gt;// Must be differentiate using &amp;quot;type keys&amp;quot; (Key1, Key2).&lt;/span&gt;
    &lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;MyRepository&lt;/span&gt; &lt;span class="n"&gt;myRepository&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;myRepository&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;emplace&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;test&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Construct the shared_ptr within the repository.&lt;/span&gt;
    &lt;span class="n"&gt;myRepository&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;emplace&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Key1&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1337&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;myRepository&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;set&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Key2&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;make_shared&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt; &lt;span class="c1"&gt;// Set the shared_ptr manually.&lt;/span&gt;

    &lt;span class="c1"&gt;// Note: I use &amp;#39;*&amp;#39; as get returns a shared_ptr.&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;myRepository&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Print &amp;quot;test&amp;quot;.&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;myRepository&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Key1&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Print 1337.&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;myRepository&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Key2&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Print 42.&lt;/span&gt;

    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;myRepository&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;//             ^^^ Compilation error: which int shall be selected? Key1 or Key2?&lt;/span&gt;

    &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;watcher&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;myRepository&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getWatcher&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// Create a watcher object to observe changes on std::string.&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;watcher&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;hasBeenChanged&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 0: no changes since the watcher creation.&lt;/span&gt;

    &lt;span class="n"&gt;myRepository&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;emplace&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;yo&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Emplace a new value into the std::string slot.&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;watcher&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;hasBeenChanged&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 1: the std::string slot has been changed.&lt;/span&gt;

    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;watcher&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Poll the value and print &amp;quot;yo&amp;quot;.&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;watcher&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;hasBeenChanged&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 0: no changes since the last polling.&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;EXIT_SUCCESS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;First and foremost, its name &lt;strong&gt;repository&lt;/strong&gt; might not be well-suited for its responsibility. If your native language is the same as shakespeare and come-up with a better term, please feel free to submit it. In our internal usage, &lt;strong&gt;config repository&lt;/strong&gt; sounded great!&lt;/p&gt;
&lt;p&gt;I start by describing the slots necessary for my application by creating a new type &lt;strong&gt;MyRepository&lt;/strong&gt; using a &lt;a href="http://en.cppreference.com/w/cpp/language/type_alias"&gt;type alias&lt;/a&gt;. As you can see, I use the type of the slots as a key for accessing elements. But in case of contention, I must use a second key: an "empty type" ; like &lt;strong&gt;Key1&lt;/strong&gt; and &lt;strong&gt;Key2&lt;/strong&gt; in this example.
If using types as keys seems odd for you, fear not! Here is the most rational explanation I can share with you: we are trying to benefit from our "know-it-all compiler". Your compiler is mainly manipulating types, one can change its flow using these types during the compilation process. Note that these structs are not even complete (no definition), it has &lt;strong&gt;no impact&lt;/strong&gt; for the &lt;strong&gt;runtime memory&lt;/strong&gt; or &lt;strong&gt;runtime execution&lt;/strong&gt; and that's the amazing part of &lt;strong&gt;meta-programming&lt;/strong&gt;. The dispatch of an expression such as &lt;strong&gt;"myRepository.get&amp;lt; int, Key1&amp;gt;()"&lt;/strong&gt; is done during your build-time.&lt;/p&gt;
&lt;p&gt;You may also notice that every slot is actually a &lt;a href="http://en.cppreference.com/w/cpp/memory/shared_ptr"&gt;std::shared_ptr&lt;/a&gt;. It enforces a clean ressource management: in a multithreaded application, one must be really careful of the lifetime of heap objects. &lt;strong&gt;std::shared_ptr&lt;/strong&gt; in this case permits me to ensure that even if someone replaces a value in a slot, other components on other threads manipulating the old value won't end up with a &lt;strong&gt;dangling pointer/reference&lt;/strong&gt; bomb in their hands. Another solution would be to use plain value objects, but not only it would require copying big objects in every other components but it would also remove polymorphism.&lt;/p&gt;
&lt;p&gt;As for the updates signalisation, you first create a watcher object that establishes a contract between a desired slot to watch and your context. You can thereafter query in thread-safe way weither an update has been made and, if so, poll the latest changes. The watcher object is actually a &lt;a href="http://en.cppreference.com/w/cpp/memory/unique_ptr"&gt;std::unique_ptr&lt;/a&gt; for a special class, it cannot be moved nor copied without your permission and will automagically disable the signalisation contract between the slot and your context, once destroyed. We will dive deeper in this topic in the comming sections.&lt;/p&gt;
&lt;p&gt;Within our application, the repository object is encapsulated into a RuntimeContext object. This RuntimeContext object is created explicitely within our main entry point and passed as a reference to a great part of our components. We therefore keep the possibility to test our code easily by setting this RuntimeContext with different implementations. Here is a simplified version of our usage:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// runtimecontext.hpp&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;quot;repository.hpp&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="c1"&gt;// Incomplete types used as compile-time keys.&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Key1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Key2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;ConfigType1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Defined in another file.&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;ConfigType2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Defined in another file.&lt;/span&gt;

&lt;span class="c1"&gt;// Create a type for our repository.&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;ConfigRepository&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Repository&lt;/span&gt;
    &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;
        &lt;span class="n"&gt;Slot&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;ConfigType1&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;Slot&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;ConfigType2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Key1&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;Slot&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;ConfigType2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Key2&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;RuntimeContext&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;ILogger&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;logger&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;// ...&lt;/span&gt;
    &lt;span class="n"&gt;ConfigRepository&lt;/span&gt; &lt;span class="n"&gt;configRepository&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="c1"&gt;// Main.cpp&lt;/span&gt;

&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;quot;runtimecontext.hpp&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;RuntimeContext&lt;/span&gt; &lt;span class="n"&gt;runtimeContext&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;// Setup:&lt;/span&gt;
    &lt;span class="n"&gt;runtimeContext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;logger&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;StdOutLogger&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="c1"&gt;// ...&lt;/span&gt;

    &lt;span class="c1"&gt;// Let&amp;#39;s take a reference to the context and change the configuration repository when necessary. &lt;/span&gt;
    &lt;span class="n"&gt;startConfigurationMonitorThread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runtimeContext&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// Let&amp;#39;s take a reference and pass it down to all our components in various threads.&lt;/span&gt;
    &lt;span class="n"&gt;startOurApplicationLogic&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runtimeContext&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;EXIT_SUCCESS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Time for a C++11 implementation:&lt;/h3&gt;
&lt;p&gt;We can decompose the solution in 3 steps: at first we need to implement a map that accepts &lt;strong&gt;multiple types&lt;/strong&gt;, we then need to work on the &lt;strong&gt;thread safety&lt;/strong&gt; and finish by the &lt;strong&gt;watcher mechanism&lt;/strong&gt;. Let's first fulfill the mission of this post: introducing you to &lt;strong&gt;variadic templates&lt;/strong&gt; to solve the multiple-type problem.&lt;/p&gt;
&lt;h4&gt;Variadic templates:&lt;/h4&gt;
&lt;p&gt;You may not have heard of &lt;strong&gt;variadic templates&lt;/strong&gt; in &lt;strong&gt;C++11&lt;/strong&gt; but I bet that you already used &lt;strong&gt;variadic functions&lt;/strong&gt; like &lt;strong&gt;printf&lt;/strong&gt; in &lt;strong&gt;C&lt;/strong&gt; (maybe in a previous unsafe life). As &lt;a href="https://en.wikipedia.org/wiki/Variadic_function"&gt;wikipedia&lt;/a&gt; kindly explains "a variadic function is a function of indefinite which accepts a variable number of arguments". In other words, a &lt;strong&gt;variadic function&lt;/strong&gt; has potentially an infinite number of &lt;strong&gt;parameters&lt;/strong&gt;. Likewise, a &lt;strong&gt;variadic template&lt;/strong&gt; has potentially an infinite number of &lt;strong&gt;parameters&lt;/strong&gt;. Let's see how to use them!&lt;/p&gt;
&lt;h5&gt;Usage for variadic function templates:&lt;/h5&gt;
&lt;p&gt;Let's say that you wish to create a template that accept an infinite number of class as arguments. You will use the following notation:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;class&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You specify a group of template parameters using the ellipsis notation named &lt;strong&gt;T&lt;/strong&gt;. Note that this &lt;strong&gt;ellipsis&lt;/strong&gt; notation is consistent with &lt;strong&gt;C&lt;/strong&gt;'s variadic function notation. This group of parameters, called a &lt;strong&gt;parameter-pack&lt;/strong&gt;, can then be used in your function template or your class template by &lt;strong&gt;expanding&lt;/strong&gt; them. One must use the &lt;strong&gt;ellipsis&lt;/strong&gt; notation again (this time after T) to &lt;strong&gt;expand&lt;/strong&gt; the parameter pack &lt;strong&gt;T&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;class&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;...)&lt;/span&gt;
&lt;span class="c1"&gt;//              ^ pack T       ^expansion&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Your function content.&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now that we have expanded &lt;strong&gt;T&lt;/strong&gt;, what can we do Sir? Well, first you give to your expanded parameter &lt;strong&gt;types&lt;/strong&gt;, a fancy &lt;strong&gt;name&lt;/strong&gt; like &lt;strong&gt;t&lt;/strong&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;class&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;//                                ^ your fancy t.&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Your function content.&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If &lt;strong&gt;T = T1, T2&lt;/strong&gt;, then &lt;strong&gt;T... t = T1 t1, T2 t2&lt;/strong&gt; and &lt;strong&gt;t = t1, t2&lt;/strong&gt;. Brilliant, but is that all? Sure no! You can then &lt;strong&gt;expand&lt;/strong&gt; again &lt;strong&gt;t&lt;/strong&gt; using an "suffix-ellipsis" again:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;class&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;anotherFunction&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;...);&lt;/span&gt;
    &lt;span class="c1"&gt;//                ^ t is expanded here! &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Finally, you can call this function &lt;strong&gt;f&lt;/strong&gt; as you would with a normal function template:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;class&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;anotherFunction&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;...);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;foo&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;bar&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Note: the argument deduction avoids us to use f&amp;lt;int, const char*, const char*&amp;gt;&lt;/span&gt;
&lt;span class="c1"&gt;// f(1, &amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot;) calls a generated f(int t1, const char* t2, const char* t3)&lt;/span&gt;
&lt;span class="c1"&gt;// with T1 = int, T2 = const char* and T3 = const char*,&lt;/span&gt;
&lt;span class="c1"&gt;// that itself calls anotherFunction(t1, t2, t3) equivalent to call anotherFunction(1, &amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Actually, the &lt;strong&gt;expansion mechanism&lt;/strong&gt; is creating &lt;strong&gt;comma-separated&lt;/strong&gt; replication of the &lt;strong&gt;pattern&lt;/strong&gt; you apply the &lt;strong&gt;ellipsis&lt;/strong&gt; onto. If you think I am tripping out with template-related wording, here is a much more concret example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;class&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;anotherFunction&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;...);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;class&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;static_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)...);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Call f(int* t1, int* t2).&lt;/span&gt;
    &lt;span class="c1"&gt;// Do a subcall to g(static_cast&amp;lt;double&amp;gt;(*t1), static_cast&amp;lt;double&amp;gt;(*t2)).&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;EXIT_SUCCESS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I could use the pattern &lt;strong&gt;'*'&lt;/strong&gt; for &lt;strong&gt;f&lt;/strong&gt; parameters and therefore take them as a pointer! In the same manner, I applied the pattern &lt;strong&gt;'static_cast&amp;lt; double&amp;gt;(*)&lt;/strong&gt; to get the value of each arguments and cast them as doubles before forwarding them to &lt;strong&gt;g&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;One last example before moving to &lt;strong&gt;variadic class templates&lt;/strong&gt;. One can combine "normal" template parameters with parameter packs and initiate a compile recursion on function templates. Let's take a look at this printing function:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;HEAD&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;HEAD&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Stop: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;HEAD&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;TAIL&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;HEAD&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;TAIL&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;tail&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Recurse: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tail&lt;/span&gt;&lt;span class="p"&gt;...);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1337&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;foo&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// Print:&lt;/span&gt;
    &lt;span class="c1"&gt;// Recurse: 42&lt;/span&gt;
    &lt;span class="c1"&gt;// Recurse: 1337&lt;/span&gt;
    &lt;span class="c1"&gt;// Stop: foo&lt;/span&gt;

    &lt;span class="c1"&gt;// Call print&amp;lt;int, int, const char*&amp;gt; (second version of print).&lt;/span&gt;
    &lt;span class="c1"&gt;// The first int (head) is printed and we call print&amp;lt;int, const char*&amp;gt; (second version of print).&lt;/span&gt;
    &lt;span class="c1"&gt;// The second int (head again) is printed and we call print&amp;lt;const char*&amp;gt; (first version of print).&lt;/span&gt;
    &lt;span class="c1"&gt;// We reach recursion stopping condition, only one element left.&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;EXIT_SUCCESS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;Variadic templates&lt;/strong&gt; are very interesting and I wouldn't be able to cover all their features within this post. It roughly feels like functional programming using your compiler, and even some &lt;strong&gt;Haskellers&lt;/strong&gt; might listen to you if you bring that topic during a dinner. For those interested, I would challenge them to write a type-safe version of &lt;strong&gt;printf&lt;/strong&gt; using variadic templates with the help of this &lt;a href="http://en.cppreference.com/w/cpp/language/parameter_pack"&gt;reference&lt;/a&gt;. After that, you will run and scream of fear at the precense of &lt;strong&gt;C&lt;/strong&gt;'s &lt;strong&gt;vargs&lt;/strong&gt;.&lt;/p&gt;
&lt;h5&gt;"Variadic" inheritance:&lt;/h5&gt;
&lt;p&gt;Sometimes during my programming sessions, I have a very awkward sensation that my crazy code will never compile and, yet, I finally see "build finished" in my terminal. I am talking about that kind of Frankenstein constructions:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;class&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nl"&gt;C&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="c1"&gt;// Variadic inheritance&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;

&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Yes, we can now create a class inheriting of an infinite number of bases. If you remember my explanation about pattern replications separated by commas, you can imaginge that &lt;strong&gt;struct C: public T...&lt;/strong&gt; will be "transformed" in &lt;strong&gt;struct C: public A, public B&lt;/strong&gt;, &lt;strong&gt;public T&lt;/strong&gt; being the pattern. We start to be able to combine multiple types, each exposing a small amount of methods, to create a flexible concret type. That's one step closer to our multi-type map, and if you are interested in this concept, take a look at &lt;a href="https://en.wikipedia.org/wiki/Mixin"&gt;mixins&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Instead of inheriting directly from multiple types, couldn't we inherit from some types that encapsulate our types? Absolutely! A traditional map has some &lt;strong&gt;slots&lt;/strong&gt; accessible using keys and these slots contain a value. If you give me base-class you are looking for, I can give you access to the value it contains:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;SlotA&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;SlotB&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="c1"&gt;// Note: private inheritance, no one can access directly to the slots other than C itself.&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nl"&gt;Repository&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="n"&gt;SlotA&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="n"&gt;SlotB&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;setSlotA&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// I access the base-class&amp;#39;s value&lt;/span&gt;
        &lt;span class="c1"&gt;// Since we have multiple base with a value field, we need to &amp;quot;force&amp;quot; the access to SlotA.&lt;/span&gt;
        &lt;span class="n"&gt;SlotA&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;getSlotA&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;SlotA&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;setSlotB&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;SlotB&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;getSlotB&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;SlotB&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;


&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Repository&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setSlotA&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getSlotA&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Print: 42.&lt;/span&gt;

    &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setSlotB&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;toto&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getSlotB&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Print: &amp;quot;toto&amp;quot;.&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;EXIT_SUCCESS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This code is not generic at all! We know how to create a generic &lt;strong&gt;Slot&lt;/strong&gt; using a simple template, and we acquired the magic "create varidiac inheritance" skill. If my &lt;strong&gt;Repository&lt;/strong&gt; class inherit from &lt;strong&gt;Slot&amp;lt; TypeA&amp;gt;&lt;/strong&gt; and you call a method template with &lt;strong&gt;TypeA&lt;/strong&gt; as a template argument, I can call the &lt;strong&gt;doGet&lt;/strong&gt; method of the &lt;strong&gt;Slot&amp;lt; TypeA&amp;gt;&lt;/strong&gt; base-class and give you back the &lt;strong&gt;value&lt;/strong&gt; of &lt;strong&gt;TypeA&lt;/strong&gt; in that repository. Let's fix the previous ugly copy-paste code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Slot&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;protected&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;doGet&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;// A nice encapsulation, that will be usefull later on.&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;value_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;doSet&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// Same encapsulation.&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;value_&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;Type&lt;/span&gt; &lt;span class="n"&gt;value_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;class&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;Slots&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Repository&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="n"&gt;Slots&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="c1"&gt;// inherit from our slots...&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="c1"&gt;// Give me a type and,&lt;/span&gt;
    &lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;Slot&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;doGet&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// I can select the Base class.&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Slot&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;doSet&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="c1"&gt;// Incomplete types used as compile-time keys.&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Key1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Key2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// Create a type for our repository.&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;MyRepository&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Repository&lt;/span&gt;
        &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;
                &lt;span class="n"&gt;Slot&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;       &lt;span class="c1"&gt;// Let&amp;#39;s pick the type of our slots.&lt;/span&gt;
                &lt;span class="n"&gt;Slot&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
        &lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;MyRepository&lt;/span&gt; &lt;span class="n"&gt;myRepository&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;myRepository&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;set&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;toto&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;myRepository&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Notice the type deduction: we pass an int, so it writes in the int slot.&lt;/span&gt;

    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;myRepository&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Print: &amp;quot;toto&amp;quot;.&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;myRepository&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Print: 42.&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;EXIT_SUCCESS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This repository starts to take shape, but we are not yet done! If you try to have two int slots, you will raise a compilation error: "base class 'Slot&lt;int&gt;' specified more than once as a direct base class". We need to add another key-type to our slot class with a default value and we need to modify our repository methods to handle it:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;DefaultSlotKey&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// No needs for a definition&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Key&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;DefaultSlotKey&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="c1"&gt;// The Key type will never be trully used. &lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Slot&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;class&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;Slots&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Repository&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="n"&gt;Slots&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Key&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;DefaultSlotKey&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="c1"&gt;// The default key must be here too.&lt;/span&gt;
    &lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;Slot&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Key&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;doGet&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Key&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;DefaultSlotKey&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Slot&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Key&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;doSet&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Key1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// No need for definition.&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Key2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// Now you can do:&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;MyRepository&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Repository&lt;/span&gt;
    &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;
            &lt;span class="n"&gt;Slot&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;       &lt;span class="c1"&gt;// Let&amp;#39;s pick the type of our slots.&lt;/span&gt;
            &lt;span class="n"&gt;Slot&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Key1&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;Slot&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Key2&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Here is a UML representation of this Repository using distinct &lt;strong&gt;Keys&lt;/strong&gt; for the type &lt;strong&gt;std::string&lt;/strong&gt;:
&lt;img alt="A nice UML diagram of my classes" src="https://jguegant.github.io/blogs/tech/images/repository_uml.png"&gt;&lt;/p&gt;
&lt;p&gt;Our repository class is missing an &lt;strong&gt;emplace&lt;/strong&gt; method, right? &lt;strong&gt;emplace&lt;/strong&gt; is taking a variable number of arguments with different types and &lt;strong&gt;forward&lt;/strong&gt; them to create an object within one of our slots. A variable number of arguments and types must remind you something... &lt;strong&gt;variadic templates&lt;/strong&gt;! Let's create this variadic &lt;strong&gt;emplace&lt;/strong&gt; method as well as its equivalent in the Slot class:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// In class Slot:&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;class&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;Args&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;doEmplace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Args&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// Here the pattern is const  &amp;amp;.&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;value_&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;...);&lt;/span&gt; &lt;span class="c1"&gt;// copy-operator (might use move semantics).&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// In class Repository:&lt;/span&gt;
&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Key&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;DefaultSlotKey&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;Args&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;emplace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Args&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// Here the pattern is const  &amp;amp;.&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Slot&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Key&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;doEmplace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;...);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// Usage:&lt;/span&gt;
&lt;span class="n"&gt;myRepository&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;emplace&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Create a std::string &amp;quot;aaaa&amp;quot;.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;One last improvement for the future users of your repositories! If one morning, badly awake, a coworker of yours is trying to get a type or key that doesn't exist (like myRepository.get&amp;lt; double&amp;gt;();), he might be welcomed by such a message:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;home&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;jguegant&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Coding&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ConfigsRepo&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nl"&gt;cpp&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;36&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;33&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nl"&gt;error&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;non&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;member&lt;/span&gt; &lt;span class="n"&gt;function&lt;/span&gt; &lt;span class="n"&gt;without&lt;/span&gt; &lt;span class="n"&gt;an&lt;/span&gt; &lt;span class="n"&gt;object&lt;/span&gt; &lt;span class="n"&gt;argument&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;Slot&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Key&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;doGet&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
           &lt;span class="o"&gt;~~~~~~~~~~~~~~~~~^~~~~&lt;/span&gt;
&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;home&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;jguegant&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Coding&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ConfigsRepo&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nl"&gt;cpp&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;67&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;18&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nl"&gt;note&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="n"&gt;instantiation&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;function&lt;/span&gt; &lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="n"&gt;specialization&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;Repository&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Slot&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;DefaultSlotKey&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Slot&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;__1&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;basic_string&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;DefaultSlotKey&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;DefaultSlotKey&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;requested&lt;/span&gt; &lt;span class="n"&gt;here&lt;/span&gt;
    &lt;span class="n"&gt;myRepository&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
                 &lt;span class="o"&gt;^&lt;/span&gt;
&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;home&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;jguegant&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Coding&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ConfigsRepo&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nl"&gt;cpp&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;36&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;33&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nl"&gt;error&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;doGet&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;protected&lt;/span&gt; &lt;span class="n"&gt;member&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;Slot&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;DefaultSlotKey&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;Slot&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Key&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;doGet&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
                                &lt;span class="o"&gt;^&lt;/span&gt;
&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;home&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;jguegant&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Coding&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ConfigsRepo&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nl"&gt;cpp&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;11&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nl"&gt;note&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;declared&lt;/span&gt; &lt;span class="k"&gt;protected&lt;/span&gt; &lt;span class="n"&gt;here&lt;/span&gt;
    &lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;doGet&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
          &lt;span class="o"&gt;^&lt;/span&gt;
&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="n"&gt;errors&lt;/span&gt; &lt;span class="n"&gt;generated&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This message is very confusing, our class does not inherit from &lt;strong&gt;Slot&amp;lt; double, DefaultSlotKey&amp;gt;&lt;/strong&gt;! And we are talking about a &lt;strong&gt;clang&lt;/strong&gt; output, I wonder what &lt;strong&gt;gcc&lt;/strong&gt; or &lt;strong&gt;MSVC&lt;/strong&gt; could produce... If you do not want to be assinated from your moody colleague with a spoon, here is a nice solution using &lt;strong&gt;C++11&lt;/strong&gt;'s &lt;a href="http://en.cppreference.com/w/cpp/language/static_assert"&gt;static_asserts&lt;/a&gt;. &lt;strong&gt;Static asserts&lt;/strong&gt; give you the possibility to generate your own compiler error messages in the same fashion as normal asserts but at compile-time. Using a the trait like &lt;strong&gt;std::is_base_of&lt;/strong&gt;, you can suggest the user of your repository to check twice his type. Let's put this &lt;strong&gt;static_assert&lt;/strong&gt; at the beggining of all the methods of &lt;strong&gt;Repository&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;static_assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;is_base_of&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Slot&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Key&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Repository&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Slots&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
          &lt;span class="s"&gt;&amp;quot;Please ensure that this type or this key exists in this repository&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We are done for this part (finally...), time to think about multi-threading! If you want to know more about the magic behind &lt;strong&gt;std::is_base_of&lt;/strong&gt;, I would suggest you to read my previous post on &lt;a href="https://jguegant.github.io/blogs/tech/sfinae-introduction.html"&gt;SFINAE&lt;/a&gt;, it might give you few hints. Here is a &lt;a href="https://gist.github.com/Jiwan/c1daf7a80ebeb166dc61"&gt;gist&lt;/a&gt; of what we achieved so far. Did you notice the change on &lt;strong&gt;emplace&lt;/strong&gt;? If you do not understand it, have a look at &lt;a href="http://thbecker.net/articles/rvalue_references/section_07.html"&gt;this explanation on perfect forwarding&lt;/a&gt;. Sadly, it would be a way too long topic for this post (trust me on that point!) and has a minor impact on our repository right now.&lt;/p&gt;
&lt;h4&gt;Let's play safe:&lt;/h4&gt;
&lt;p&gt;The repository we just succeeded to craft can now be used in a single-thread environment without further investigation. But the initial decision was to make this class manipulable from multiple-threads without any worries considering the safety of our operations. As explained in the beginning of this post, we will not use direct values as we currently do, but instead allocate our objects on the heap and use some &lt;strong&gt;shared pointers&lt;/strong&gt; to strictly control their &lt;strong&gt;lifetime&lt;/strong&gt;. No matter which version (recent or deprecated) of the object a thread is manipulating, it's lifetime will be extended until the last thread using it definitely release it. It also implies that the objects themselves are thread-safe. In the case of read-only objects like configs or assets, it shouldn't be too much a burden. In this &lt;a href="https://gist.github.com/Jiwan/cb66d01c38128a351f42"&gt;gist&lt;/a&gt;, you will find a repository version using &lt;strong&gt;std::shared_ptrs&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;std::shared_ptr&lt;/strong&gt; is an amazing feature of &lt;strong&gt;C++11&lt;/strong&gt; when dealing with multi-threading, but has its weakness. Within my code (in the previous gist link) a race condition can occur:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// What if I try to copy value_ at the return point...&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;doGet&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;value_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// ... meanwhile another thread is changing value_ to value?&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;doSet&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;value_&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As specified: "If multiple threads of execution access the &lt;strong&gt;same&lt;/strong&gt; std::shared_ptr object without synchronization and any of those accesses uses a non-const member function of shared_ptr then a data race will occur". Note that we are talking about the &lt;strong&gt;same&lt;/strong&gt; shared pointer. Multiple shared pointer &lt;strong&gt;copies&lt;/strong&gt; pointing to the same object are fine, as long as these copies originated from the same shared pointer in first place. Copies are sharing the same &lt;strong&gt;control block&lt;/strong&gt;, where the &lt;strong&gt;reference counters&lt;/strong&gt; (one for shared_ptr and one for weak_ptr) are located, and the specification says "the control block of a shared_ptr is thread-safe: different std::shared_ptr objects can be accessed using mutable operations, such as operator= or reset, simultaneously by multiple threads, even when these instances are copies, and share the same control block internally.".&lt;/p&gt;
&lt;p&gt;Depending on the age of your compiler and its standard library, I suggest two solutions:&lt;/p&gt;
&lt;h5&gt;1) A global mutex:&lt;/h5&gt;
&lt;p&gt;A straightforward solution relies on a &lt;a href="http://en.cppreference.com/w/cpp/thread/mutex"&gt;std::mutex&lt;/a&gt; that we lock during &lt;strong&gt;doGet&lt;/strong&gt; and &lt;strong&gt;doSet&lt;/strong&gt; execution:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;...&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;doGet&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// The lock is enabled until value_ has been copied!&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;lock_guard&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mutex_&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;value_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;doSet&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// The lock is enabled until value has been copied into value!&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;lock_guard&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mutex_&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;value_&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;mutex&lt;/span&gt; &lt;span class="n"&gt;mutex_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This solution is ideal if you have a &lt;strong&gt;Linux&lt;/strong&gt; distribution that only ships &lt;strong&gt;gcc 4.8.x&lt;/strong&gt; like mine. While not particularly elegant, it doesn't have a great impact on performances compared to the next solution. &lt;/p&gt;
&lt;h5&gt;2) Atomic access functions:&lt;/h5&gt;
&lt;p&gt;Starting from &lt;strong&gt;gcc 4.9&lt;/strong&gt;, one can use &lt;a href="http://en.cppreference.com/w/cpp/memory/shared_ptr/atomic"&gt;atomic access functions&lt;/a&gt; to manipulate shared pointers. I dream of a day where a specialisation for &lt;strong&gt;std::atomic&amp;lt; std::shared_ptr&lt;T&gt;&amp;gt;&lt;/strong&gt; exists, but from now, we will resort to use &lt;strong&gt;std::atomic_load&lt;/strong&gt; and &lt;strong&gt;std::atomic_exchange&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;...&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;doGet&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;atomic_load&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;value_&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;doSet&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;atomic_exchange&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;value_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;value_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;Atomics&lt;/strong&gt; are elegants and can often bring a great increase of performances if using lock-free instructions internally. Sadly, in the case of &lt;strong&gt;shared_ptrs&lt;/strong&gt;, &lt;strong&gt;atomic_is_lock_free&lt;/strong&gt; will return you &lt;strong&gt;false&lt;/strong&gt;. By digging in &lt;strong&gt;libstdc++&lt;/strong&gt; and &lt;strong&gt;libc++&lt;/strong&gt;, you will find some mutexes. &lt;strong&gt;gcc&lt;/strong&gt; seems to use a fixed size "pool" of mutexes attributed to a shared_ptr according to a hash of its pointee address, when dealing with atomic operations. In other words, no rocket-science for atomic shared pointers until now.&lt;/p&gt;
&lt;h4&gt;Our own watchers:&lt;/h4&gt;
&lt;p&gt;"...I shall live and die at my post. I am the sword in the darkness. I am the watcher on the walls. I am the shield that guards the realms of men..." &lt;strong&gt;-- The Night's Watch oath&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;We want to be able to seal a bond between one of the slot and a context. By context, I mean the lifetime of an object in a thread, a function or a method. If an update has been made on that slot, we must be signaled in that context and to retrieve the new update. The bond must be destroyed if the context does not exist anymore. It should reminds you the Night's Watch oath ... as well as the &lt;a href="https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization"&gt;RAII idiom&lt;/a&gt;: "holding a resource is tied to object lifetime: resource acquisition is done during object creation, by the constructor, while resource deallocation is done during object destruction, by the destructor. If objects are destroyed properly, resource leaks do not occur.". A strong ownership policy can be obtained with the help of a &lt;a href="http://en.cppreference.com/w/cpp/memory/unique_ptr"&gt;std::unique_ptr&lt;/a&gt; and the signalisation can be done using a &lt;strong&gt;boolean flag&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;We will, therefore, encapsulate a &lt;a href="http://en.cppreference.com/w/cpp/atomic/atomic"&gt;std::atomic_bool&lt;/a&gt; into a class &lt;strong&gt;Watcher&lt;/strong&gt; automagically registered to a slot once created, and unregistered once destructed. This &lt;strong&gt;Watcher&lt;/strong&gt; class also takes as a reference the slot in order to query its value as you can see:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Key&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Watcher&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;Watcher&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Slot&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Key&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;slot&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;slot_&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;slot&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
            &lt;span class="n"&gt;hasBeenChanged_&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;Watcher&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Watcher&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;delete&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;               &lt;span class="c1"&gt;// Impossible to copy that class.&lt;/span&gt;

    &lt;span class="n"&gt;Watcher&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Watcher&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;delete&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// Impossible to copy that class.&lt;/span&gt;

    &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nf"&gt;hasBeenChanged&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;hasBeenChanged_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;triggerChanges&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;hasBeenChanged_&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="nf"&gt;get&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;decltype&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;declval&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Slot&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Key&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;doGet&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;hasBeenChanged_&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Note: even if there is an update of the value between this line and the getValue one,&lt;/span&gt;
        &lt;span class="c1"&gt;// we will still have the latest version.&lt;/span&gt;
        &lt;span class="c1"&gt;// Note 2: atomic_bool automatically use a barrier and the two operations can&amp;#39;t be inversed.&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;slot_&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;doGet&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;Slot&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Key&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;slot_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;atomic_bool&lt;/span&gt; &lt;span class="n"&gt;hasBeenChanged_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As for the automatic registration, we will add two private methods &lt;strong&gt;registerWatcher&lt;/strong&gt; and &lt;strong&gt;unregisterWatcher&lt;/strong&gt; to our &lt;strong&gt;Slot&lt;/strong&gt; class that add or remove a watcher from an internal list. The list is always protected, when accessed, with a &lt;strong&gt;std::mutex&lt;/strong&gt; and tracks all the current watchers that must be signaled when &lt;strong&gt;set&lt;/strong&gt; is called on that slot. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Key&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Slot&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;ThisType&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Slot&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Key&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;WatcherType&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Watcher&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Key&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;registerWatcher&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;WatcherType&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;newWatcher&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;lock_guard&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;watchers_mutex_&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;watchers_&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;newWatcher&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;unregisterWatcher&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;WatcherType&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;toBeDelete&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;lock_guard&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;watchers_mutex_&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;watchers_&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;erase&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;remove&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;watchers_&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;watchers_&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;toBeDelete&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;watchers_&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;

        &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="n"&gt;toBeDelete&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Now that we removed the watcher from the list, we can proceed to delete it.&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;lock_guard&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;watchers_mutex_&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="nl"&gt;watcher&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;watchers_&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;watcher&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;triggerChanges&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// Let&amp;#39;s raise the hasBeenChanged_ atomic boolean flag. &lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;WatcherType&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;watchers_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// All the registered watchers are in that list.&lt;/span&gt;

&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You may have notice that we are passing a bare &lt;strong&gt;WatcherType&lt;/strong&gt; pointers. The ownership is actually given to whoever is using that watcher encapsulated within a &lt;strong&gt;std::unique_ptr&lt;/strong&gt;. &lt;strong&gt;C++11&lt;/strong&gt;'s unique pointers are designed such as you can pass a &lt;strong&gt;custom deleter&lt;/strong&gt;, or a &lt;strong&gt;delete callback&lt;/strong&gt; so to speak. Hence, we can create a method that get a &lt;strong&gt;Watcher&lt;/strong&gt; for a &lt;strong&gt;Slot&lt;/strong&gt;, and register as the deleter of that &lt;strong&gt;Watcher&lt;/strong&gt; a &lt;strong&gt;lambda function&lt;/strong&gt; designed to call &lt;strong&gt;unregisterWatcher&lt;/strong&gt;. Note that the slot MUST always lives longer than the unique pointer and its associated watcher (it should not be a problem in most cases). Let's finish that &lt;strong&gt;Slot&lt;/strong&gt; class forever and ever:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Key&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Slot&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;ThisType&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Slot&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Key&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;WatcherType&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Watcher&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Key&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;// We use unique_ptr for a strong ownership policy.&lt;/span&gt;
    &lt;span class="c1"&gt;// We use std::function to declare the type of our deleter.&lt;/span&gt;
    &lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;WatcherTypePtr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;unique_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;WatcherType&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;WatcherType&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="p"&gt;...&lt;/span&gt;

&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;WatcherTypePtr&lt;/span&gt; &lt;span class="n"&gt;doGetWatcher&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// Create a unique_ptr and pass a lambda as a deleter.&lt;/span&gt;
        &lt;span class="c1"&gt;// The lambda capture &amp;quot;this&amp;quot; and will call unregisterWatcher.&lt;/span&gt;
        &lt;span class="n"&gt;WatcherTypePtr&lt;/span&gt; &lt;span class="n"&gt;watcher&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;WatcherType&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;](&lt;/span&gt;&lt;span class="n"&gt;WatcherType&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;toBeDelete&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;unregisterWatcher&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;toBeDelete&lt;/span&gt;&lt;span class="p"&gt;);});&lt;/span&gt;

        &lt;span class="n"&gt;registerWatcher&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;watcher&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;

        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;watcher&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Are we done? Hell no, but we will be really soon. All we need is to expose the possibility to acquire a watcher from the repository itself. In the same manner as &lt;strong&gt;set&lt;/strong&gt; and &lt;strong&gt;get&lt;/strong&gt;, we simply dispatch using the type and the key on one of our slot:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Key&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;DefaultSlotKey&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;Slot&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Key&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;WatcherTypePtr&lt;/span&gt; &lt;span class="n"&gt;getWatcher&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;// typename is used for disambiguate&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;Slot&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Key&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;doGetWatcher&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;WAIT&lt;/strong&gt;, don't close that page too fast. If you want to be able to snub everyone, you can replace this ugly &lt;strong&gt;typename Slot&lt;Type, Key&gt;::WatcherTypePtr&lt;/strong&gt; with &lt;strong&gt;auto&lt;/strong&gt; and claim that your repository class is &lt;strong&gt;C++14&lt;/strong&gt; only! Grab the full code of what we build together on &lt;a href="https://gist.github.com/Jiwan/31f8f837e4f4b90fed13"&gt;gist&lt;/a&gt; and enjoy!&lt;/p&gt;
&lt;h3&gt;Conclusion:&lt;/h3&gt;
&lt;p&gt;Once again, I hope you enjoyed this post about one of my favourite subject: C++. I might not be the best teacher nor the best author but I wish that you learnt something today! Please, if you any suggestions or questions, feel free to post anything in the commentaries. My broken English being what it is, I kindly accept any help for my written mistakes.&lt;/p&gt;
&lt;p&gt;Many thanks to my colleagues that greatly helped me by reviewing my code and for the time together.&lt;/p&gt;</content><category term="C++"></category><category term="C++11"></category><category term="C++14"></category><category term="variadic templates"></category><category term="meta programming"></category></entry><entry><title>An introduction to C++'s SFINAE concept: compile-time introspection of a class member</title><link href="https://jguegant.github.io/blogs/tech/sfinae-introduction.html" rel="alternate"></link><published>2015-10-31T14:00:00+01:00</published><updated>2015-10-18T14:00:00+02:00</updated><author><name>Jean Guegant</name></author><id>tag:jguegant.github.io,2015-10-31:/blogs/tech/sfinae-introduction.html</id><summary type="html">&lt;!-- http://stackoverflow.com/questions/18570285/using-sfinae-to-detect-a-member-function --&gt;

&lt;h3&gt;Trivia:&lt;/h3&gt;
&lt;p&gt;As a C++ enthusiast, I usually follow the annual C++ conference &lt;a href="http://cppcon.org/"&gt;cppconf&lt;/a&gt; or at least try to keep myself up-to-date with the major events that happen there. One way to catch up, if you can't afford a plane ticket or the ticket, is to follow the &lt;a href="https://www.youtube.com/channel/UCMlGfpWw-RUdWX_JbLCukXg"&gt;youtube channel&lt;/a&gt; dedicated …&lt;/p&gt;</summary><content type="html">&lt;!-- http://stackoverflow.com/questions/18570285/using-sfinae-to-detect-a-member-function --&gt;

&lt;h3&gt;Trivia:&lt;/h3&gt;
&lt;p&gt;As a C++ enthusiast, I usually follow the annual C++ conference &lt;a href="http://cppcon.org/"&gt;cppconf&lt;/a&gt; or at least try to keep myself up-to-date with the major events that happen there. One way to catch up, if you can't afford a plane ticket or the ticket, is to follow the &lt;a href="https://www.youtube.com/channel/UCMlGfpWw-RUdWX_JbLCukXg"&gt;youtube channel&lt;/a&gt; dedicated to this conference. This year, I was impressed by &lt;strong&gt;Louis Dionne&lt;/strong&gt; talk entitled "C++ Metaprogramming: A Paradigm Shift". One feature called &lt;strong&gt;is_valid&lt;/strong&gt; that can be found in Louis's &lt;a href="http://github.com/boostorg/hana"&gt;Boost.Hana&lt;/a&gt; library particulary caught my attention. This genious &lt;strong&gt;is_valid&lt;/strong&gt; function heavily rely on an even more "magic" C++ programming technique coined with the term &lt;strong&gt;SFINAE&lt;/strong&gt; discovered at the end of the previous century. If this acronym doesn't speak to you, don't be scared, we are going to dive straight in the subject.&lt;/p&gt;
&lt;p&gt;Note: for the sake of your sanity and the fact that &lt;em&gt;errare humanum est&lt;/em&gt;, this article might not be 100% accurate!&lt;/p&gt;
&lt;h3&gt;Introspection in C++?&lt;/h3&gt;
&lt;p&gt;Before explaining what is &lt;strong&gt;SFINAE&lt;/strong&gt;, let's explore one of its main usage: &lt;strong&gt;introspection&lt;/strong&gt;. As you might be aware, C++ doesn't excel when it comes to examine the type or properties of an object at runtime. The best ability provided by default would be &lt;a href="https://en.wikipedia.org/wiki/Run-time_type_information"&gt;RTTI&lt;/a&gt;. Not only &lt;strong&gt;RTTI&lt;/strong&gt; isn't always available, but it also gives you barely more than the current type of the manipulated object. Dynamic languages or those having &lt;strong&gt;reflection&lt;/strong&gt; on the other hand are really convenient in some situations like &lt;strong&gt;serialization&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;For instance, in Python, using reflection, one can do the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;A&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="c1"&gt;# Simply overrides the &amp;#39;object.__str__&amp;#39; method.&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__str__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;I am a A&amp;quot;&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;B&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="c1"&gt;# A custom method for my custom objects that I want to serialize.&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;I am a B&amp;quot;&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;C&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="c1"&gt;# Oups! &amp;#39;serialize&amp;#39; is not a method. &lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;serialize&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__str__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;I am a C&amp;quot;&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="c1"&gt;# Let&amp;#39;s check if obj has an attribute called &amp;#39;serialize&amp;#39;.&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;hasattr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;serialize&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="c1"&gt;# Let&amp;#39;s check if this &amp;#39;serialize&amp;#39; attribute is a method.&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;hasattr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;__call__&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="c1"&gt;# Else we call the __str__ method.&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="c1"&gt;# output: I am a A.&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="c1"&gt;# output: I am a B.&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="c1"&gt;# output: I am a C.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As you can see, during serialization, it comes pretty handy to be able to check if an object has an attribute and to query the type of this attribute. In our case, it permits us to use the &lt;strong&gt;serialize&lt;/strong&gt; method if available and fall back to the more generic method &lt;strong&gt;str&lt;/strong&gt; otherwise. Powerful, isn't it? Well, we can do it &lt;strong&gt;in plain C++&lt;/strong&gt;!&lt;/p&gt;
&lt;p&gt;Here is the &lt;strong&gt;C++14&lt;/strong&gt; solution mentionned in &lt;strong&gt;Boost.Hana&lt;/strong&gt; documentation, using &lt;strong&gt;is_valid&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;boost/hana.hpp&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;hana&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;boost&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;hana&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// Check if a type has a serialize method.&lt;/span&gt;
&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;hasSerialize&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;hana&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;is_valid&lt;/span&gt;&lt;span class="p"&gt;([](&lt;/span&gt;&lt;span class="k"&gt;auto&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;decltype&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;});&lt;/span&gt;

&lt;span class="c1"&gt;// Serialize any kind of objects.&lt;/span&gt;
&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;hana&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;if_&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hasSerialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="c1"&gt;// Serialize is selected if available!&lt;/span&gt;
                     &lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="k"&gt;auto&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt;
                     &lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="k"&gt;auto&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;to_string&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// Type A with only a to_string overload.&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;

&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;to_string&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;I am a A!&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// Type B with a serialize method.&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;I am a B!&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="c1"&gt;// Type C with a &amp;quot;wrong&amp;quot; serialize member (not a method) and a to_string overload.&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;to_string&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;I am a C!&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As you can see, it only requires a bit more of boilerplate than Python, but not as much as you would expect from a language as complexe as C++. How does it work? Well if you are too lazy to read the rest, here is the simplest answer I can give you: unlike dynamically typed languages, your compiler has access a lot of static type information once fired. It makes sense that we can constraint your compiler to do a bit of work on these types! The next question that comes to your mind is "How to?". Well, right below we are going to explore the various options we have to enslave our favorite compiler for fun and profit! And we will eventually recreate our own &lt;strong&gt;is_valid&lt;/strong&gt;.&lt;/p&gt;
&lt;h3&gt;The old-fashioned C++98-way:&lt;/h3&gt;
&lt;p&gt;Whether your compiler is a dinosaur, your boss refuses to pay for the latest Visual Studio license or you simply love archeology, this chapter will interest you. It's also interesting for the people stuck between C++11 and C++14. The solution in C++98 relies on 3 key concepts: &lt;strong&gt;overload resolution&lt;/strong&gt;, &lt;strong&gt;SFINAE&lt;/strong&gt; and the static behavior of &lt;strong&gt;sizeof&lt;/strong&gt;. &lt;/p&gt;
&lt;h4&gt;Overload resolution:&lt;/h4&gt;
&lt;p&gt;A simple function call like "&lt;strong&gt;f(obj);&lt;/strong&gt;"" in &lt;strong&gt;C++&lt;/strong&gt; activates a mechanism to figure out which &lt;strong&gt;f&lt;/strong&gt; function shoud be called according to the argument &lt;strong&gt;obj&lt;/strong&gt;. If a &lt;strong&gt;set&lt;/strong&gt; of &lt;strong&gt;f&lt;/strong&gt; functions could accept &lt;strong&gt;obj&lt;/strong&gt; as an argument, the compiler must choose the most appropriate function, or in other words &lt;strong&gt;resolve&lt;/strong&gt; the best &lt;strong&gt;overload&lt;/strong&gt;! Here is a good cppreference page explaining the full process: &lt;a href="http://en.cppreference.com/w/cpp/language/overload_resolution"&gt;Overload resolution&lt;/a&gt;. The rule of thumb in this case is &lt;em&gt;the compiler picks the candidate function whose parameters match the arguments most closely is the one that is called&lt;/em&gt;. Nothing is better than a good example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// int can&amp;#39;t be convert into a string.&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// int can be implicitly convert into a double, so this version could be selected, but...&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// ... this version using the type int directly is even more close!&lt;/span&gt;

&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Call f(int i);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In C++ you also have some sink-hole functions that accept everything. First, function templates accept any kind of parameter (let's say T). But the true black-hole of your compiler, the devil variable vacuum, the oblivion of the forgotten types are the &lt;a href="http://en.cppreference.com/w/cpp/utility/variadic"&gt;variadic functions&lt;/a&gt;. Yes, exactly like the horrible C &lt;strong&gt;printf&lt;/strong&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(...);&lt;/span&gt; &lt;span class="c1"&gt;// Variadic functions are so &amp;quot;untyped&amp;quot; that...&lt;/span&gt;
&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// ...this templated function got the precedence!&lt;/span&gt;

&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Call the templated function version of f.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The fact that function templates are less generic than variadic functions is the first point you must remember!&lt;/p&gt;
&lt;p&gt;Note: A &lt;strong&gt;templated function&lt;/strong&gt; can actually be more precise than a &lt;strong&gt;normal function&lt;/strong&gt;. However, in case of a draw, the &lt;strong&gt;normal function&lt;/strong&gt; will have the precedence. &lt;/p&gt;
&lt;h4&gt;SFINAE:&lt;/h4&gt;
&lt;p&gt;I am already teasing you with the power for already few paragraphs and here finally comes the explanation of this not so complex acronym. &lt;strong&gt;SFINAE&lt;/strong&gt; stands for &lt;strong&gt;S&lt;/strong&gt;ubstitution &lt;strong&gt;F&lt;/strong&gt;ailure &lt;strong&gt;I&lt;/strong&gt;s &lt;strong&gt;N&lt;/strong&gt;ot &lt;strong&gt;A&lt;/strong&gt;n &lt;strong&gt;E&lt;/strong&gt;rror. In rough terms, a &lt;strong&gt;substitution&lt;/strong&gt; is the mechanism that tries to replace the template parameters with the provided types or values. In some cases, if the &lt;strong&gt;substitution&lt;/strong&gt; leads to an invalid code, the compiler shouldn't throw a massive amount of errors but simply continue to try the other available &lt;strong&gt;overloads&lt;/strong&gt;. The &lt;strong&gt;SFINAE&lt;/strong&gt; concept simply guaranties such a "sane" behavior for a "sane" compiler. For instance:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt; The compiler will try this overload since it&amp;#39;s less generic than the variadic.&lt;/span&gt;
&lt;span class="cm"&gt; T will be replace by int which gives us void f(const int&amp;amp; t, int::iterator* b = nullptr);&lt;/span&gt;
&lt;span class="cm"&gt; int doesn&amp;#39;t have an iterator sub-type, but the compiler doesn&amp;#39;t throw a bunch of errors.&lt;/span&gt;
&lt;span class="cm"&gt; It simply tries the next overload. &lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;iterator&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;it&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;nullptr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// The sink-hole.&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(...)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Calls void f(...) { }&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;All the expressions won't lead to a &lt;strong&gt;SFINAE&lt;/strong&gt;. A broad rule would be to say that all the &lt;strong&gt;substitutions&lt;/strong&gt; out of the function/methods &lt;strong&gt;body&lt;/strong&gt; are "safes". For a better list, please take a look at this &lt;a href="http://en.cppreference.com/w/cpp/language/sfinae"&gt;wiki page&lt;/a&gt;. For instance, a wrong substitution within a function &lt;strong&gt;body&lt;/strong&gt; will lead to a horrible C++ template error:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// The compiler will be really unhappy when it will later discover the call to hahahaICrash. &lt;/span&gt;
&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hahahaICrash&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(...)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// The sink-hole wasn&amp;#39;t even considered.&lt;/span&gt;

&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;The operator sizeof:&lt;/h4&gt;
&lt;p&gt;The &lt;strong&gt;sizeof operator&lt;/strong&gt; is really a nice tool! It permits us to returns the size in bytes of a type or an expression at compilation time. &lt;strong&gt;sizeof&lt;/strong&gt; is really interesting as it accurately evaluates an expression as precisely as if it were compiled.
One can for instance do:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;type_test&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;type_test&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

&lt;span class="c1"&gt;// In the following lines f won&amp;#39;t even be truly called but we can still access to the size of its return type.&lt;/span&gt;
&lt;span class="c1"&gt;// Thanks to the &amp;quot;fake evaluation&amp;quot; of the sizeof operator.&lt;/span&gt;
&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;arrayTest&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;())];&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Output 42.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;But wait! If we can manipulate some compile-time integers, couldn't we do some compile-time comparison? The answer is: absolutely yes, my dear reader! Here we are:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;yes&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Size: 1 byte.&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;yes&lt;/span&gt; &lt;span class="n"&gt;no&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="c1"&gt;// Size: 2 bytes.&lt;/span&gt;

&lt;span class="c1"&gt;// Two functions using our type with different size.&lt;/span&gt;
&lt;span class="n"&gt;yes&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;f1&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;no&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;f2&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f1&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f2&lt;/span&gt;&lt;span class="p"&gt;()))&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Output 0.&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f1&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f1&lt;/span&gt;&lt;span class="p"&gt;()))&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Output 1.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;Combining everything:&lt;/h4&gt;
&lt;p&gt;Now we have all the tools to create a solution to check the existence of a method within a type at compile time. You might even have already figured it out most of it by yourself. So let's create it:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;hasSerialize&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// For the compile time comparison.&lt;/span&gt;
    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;yes&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;yes&lt;/span&gt; &lt;span class="n"&gt;no&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

    &lt;span class="c1"&gt;// This helper struct permits us to check that serialize is truly a method.&lt;/span&gt;
    &lt;span class="c1"&gt;// The second argument must be of the type of the first.&lt;/span&gt;
    &lt;span class="c1"&gt;// For instance reallyHas&amp;lt;int, 10&amp;gt; would be substituted by reallyHas&amp;lt;int, int 10&amp;gt; and works!&lt;/span&gt;
    &lt;span class="c1"&gt;// reallyHas&amp;lt;int, &amp;amp;C::serialize&amp;gt; would be substituted by reallyHas&amp;lt;int, int &amp;amp;C::serialize&amp;gt; and fail!&lt;/span&gt;
    &lt;span class="c1"&gt;// Note: It only works with integral constants and pointers (so function pointers work).&lt;/span&gt;
    &lt;span class="c1"&gt;// In our case we check that &amp;amp;C::serialize has the same signature as the first argument!&lt;/span&gt;
    &lt;span class="c1"&gt;// reallyHas&amp;lt;std::string (C::*)(), &amp;amp;C::serialize&amp;gt; should be substituted by &lt;/span&gt;
    &lt;span class="c1"&gt;// reallyHas&amp;lt;std::string (C::*)(), std::string (C::*)() &amp;amp;C::serialize&amp;gt; and work!&lt;/span&gt;
    &lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;U&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;U&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;reallyHas&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;// Two overloads for yes: one for the signature of a normal method, one is for the signature of a const method.&lt;/span&gt;
    &lt;span class="c1"&gt;// We accept a pointer to our helper struct, in order to avoid to instantiate a real instance of this type.&lt;/span&gt;
    &lt;span class="c1"&gt;// std::string (C::*)() is function pointer declaration.&lt;/span&gt;
    &lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;yes&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;reallyHas&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;::*&lt;/span&gt;&lt;span class="p"&gt;)(),&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;*&lt;/span&gt; &lt;span class="cm"&gt;/*unused*/&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;yes&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;reallyHas&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;::*&lt;/span&gt;&lt;span class="p"&gt;)()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;*&lt;/span&gt; &lt;span class="cm"&gt;/*unused*/&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;// The famous C++ sink-hole.&lt;/span&gt;
    &lt;span class="c1"&gt;// Note that sink-hole must be templated too as we are testing test&amp;lt;T&amp;gt;(0).&lt;/span&gt;
    &lt;span class="c1"&gt;// If the method serialize isn&amp;#39;t available, we will end up in this method.&lt;/span&gt;
    &lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;no&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;(...)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* dark matter */&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;// The constant used as a return value for the test.&lt;/span&gt;
    &lt;span class="c1"&gt;// The test is actually done here, thanks to the sizeof compile-time evaluation.&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;yes&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="c1"&gt;// Using the struct A, B, C defined in the previous hasSerialize example.&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;hasSerialize&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;hasSerialize&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;hasSerialize&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The &lt;strong&gt;reallyHas&lt;/strong&gt; struct is kinda tricky but necessary to ensure that serialize is a method and not a simple member of the type. You can do a lot of test on a type using variants of this solution (test a member, a sub-type...) and I suggest you to google a bit more about &lt;strong&gt;SFINAE&lt;/strong&gt; tricks. Note: if you truly want a pure compile-time constant and avoid some errors on old compilers, you can replace the last &lt;strong&gt;value&lt;/strong&gt; evaluation by: "&lt;strong&gt;enum { value = sizeof(test&lt;T&gt;(0)) == sizeof(yes) };&lt;/strong&gt;". &lt;/p&gt;
&lt;p&gt;You might also wonder why it doesn't work with &lt;strong&gt;inheritence&lt;/strong&gt;. &lt;strong&gt;Inheritence&lt;/strong&gt; in C++ and &lt;strong&gt;dynamic polymorphism&lt;/strong&gt; is a concept available at runtime, or in other words, a data that the compiler won't have and can't guess! However, compile time type inspection is much more efficient (0 impact at runtime) and almost as powerful as if it were at runtime.
For instance:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// Using the previous A struct and hasSerialize helper.&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nl"&gt;D&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;I am a D!&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;testHasSerialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="cm"&gt;/*t*/&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;hasSerialize&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Here we lost the type of d at compile time.&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;testHasSerialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Output 1.&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;testHasSerialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Output 0.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Last but no least, our test cover the main cases but not the tricky ones like a Functor: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;E&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Functor&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="p"&gt;()()&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;I am a E!&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;

    &lt;span class="n"&gt;Functor&lt;/span&gt; &lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="n"&gt;E&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Succefully call the functor.&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;testHasSerialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Output 0.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The trade-off for a full coverage would be the readability. As you will see, C++11 shines in that domain!&lt;/p&gt;
&lt;h4&gt;Time to use our genius idea:&lt;/h4&gt;
&lt;p&gt;Now you would think that it will be super easy to use our &lt;strong&gt;hasSerialize&lt;/strong&gt; to create a &lt;strong&gt;serialize&lt;/strong&gt; function! Okay let's try it:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hasSerialize&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// error: no member named &amp;#39;serialize&amp;#39; in &amp;#39;A&amp;#39;.&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;to_string&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;It might be hard to accept, but the error raised by your compiler is absolutely normal! If you consider the code that you will obtain after substitution and compile-time evaluation:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// Dead branching, but the compiler will still consider it!&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// error: no member named &amp;#39;serialize&amp;#39; in &amp;#39;A&amp;#39;.&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;to_string&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Your compiler is really a good guy and won't drop any dead-branch, and &lt;strong&gt;obj&lt;/strong&gt; must therefore have both a &lt;strong&gt;serialize method&lt;/strong&gt; and a &lt;strong&gt;to_string overload&lt;/strong&gt; in this case. The solution consists in spliting the serialize function into two different functions: one where we solely use &lt;strong&gt;obj.serialize()&lt;/strong&gt; and one where we use &lt;strong&gt;to_string&lt;/strong&gt; according to &lt;strong&gt;obj's type&lt;/strong&gt;. We come back to an earlier problem that we already solved, how to split according to a type? &lt;strong&gt;SFINAE&lt;/strong&gt;, for sure! At that point we could re-work our &lt;strong&gt;hasSerialize&lt;/strong&gt; function into a &lt;strong&gt;serialize&lt;/strong&gt; function and make it return a &lt;strong&gt;std::string&lt;/strong&gt; instead of compile time &lt;strong&gt;boolean&lt;/strong&gt;. But we won't do it that way! It's cleaner to separate the &lt;strong&gt;hasSerialize&lt;/strong&gt; test from its usage &lt;strong&gt;serialize&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;We need to find a clever &lt;strong&gt;SFINAE&lt;/strong&gt; solution on the signature of "&lt;strong&gt;template &amp;lt;class T&gt; std::string serialize(const T&amp;amp; obj)&lt;/strong&gt;". I bring you the last piece of the puzzle called &lt;strong&gt;enable_if&lt;/strong&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="c1"&gt;// Default template version.&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;enable_if&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt; &lt;span class="c1"&gt;// This struct doesn&amp;#39;t define &amp;quot;type&amp;quot; and the substitution will fail if you try to access it.&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="c1"&gt;// A specialisation used if the expression is true. &lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;enable_if&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;// This struct do have a &amp;quot;type&amp;quot; and won&amp;#39;t fail on access.&lt;/span&gt;

&lt;span class="c1"&gt;// Usage:&lt;/span&gt;
&lt;span class="n"&gt;enable_if&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Compiler happy. t&amp;#39;s type is int.&lt;/span&gt;
&lt;span class="n"&gt;enable_if&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;hasSerialize&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;t2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Compiler happy. t&amp;#39;s type is int.&lt;/span&gt;

&lt;span class="n"&gt;enable_if&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;t3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Compiler unhappy. no type named &amp;#39;type&amp;#39; in &amp;#39;enable_if&amp;lt;false, int&amp;gt;&amp;#39;;&lt;/span&gt;
&lt;span class="n"&gt;enable_if&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;hasSerialize&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;t4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// no type named &amp;#39;type&amp;#39; in &amp;#39;enable_if&amp;lt;false, int&amp;gt;&amp;#39;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As you can see, we can trigger a substitution failure according to a compile time expression with &lt;strong&gt;enable_if&lt;/strong&gt;. Now we can use this failure on the "&lt;strong&gt;template &amp;lt;class T&gt; std::string serialize(const T&amp;amp; obj)&lt;/strong&gt;" signature to dispatch to the right version. Finally, we have the true solution of our problem:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;enable_if&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;hasSerialize&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;enable_if&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;!&lt;/span&gt;&lt;span class="n"&gt;hasSerialize&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;to_string&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// The following lines work like a charm!&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Two details worth being noted! Firstly we use &lt;strong&gt;enable_if&lt;/strong&gt; on the return type, in order to keep the paramater deduction, otherwise we would have to specify the type explicitely "&lt;strong&gt;serialize&amp;lt;A&gt;(a)&lt;/strong&gt;". Second, even the version using &lt;strong&gt;to_string&lt;/strong&gt; must use the &lt;strong&gt;enable_if&lt;/strong&gt;, otherwise &lt;strong&gt;serialize(b)&lt;/strong&gt; would have two potential overloads available and raise an ambiguity. If you want to check the full code of this C++98 version, here is a &lt;a href="https://gist.github.com/Jiwan/2573fc47e4fa5025306b"&gt;gist&lt;/a&gt;.
Life is much easier in C++11, so let's see the beauty of this new standard!&lt;/p&gt;
&lt;p&gt;Note: it's also important to know that this code creates a &lt;strong&gt;SFINAE&lt;/strong&gt; on an expression ("&lt;strong&gt;&amp;amp;C::serialize&lt;/strong&gt;"). Whilst this feature wasn't required by the &lt;strong&gt;C++98&lt;/strong&gt; standard, it was already in use depending on your compiler. It trully became a safe choice in &lt;strong&gt;C++11&lt;/strong&gt;.&lt;/p&gt;
&lt;h3&gt;When C++11 came to our help:&lt;/h3&gt;
&lt;p&gt;After the great century leap year in 2000, people were fairly optimistic about the coming years. Some even decided to design a new standard for the next generation of &lt;strong&gt;C++&lt;/strong&gt; coders like me! Not only this standard would ease &lt;strong&gt;TMP&lt;/strong&gt; headaches (&lt;strong&gt;T&lt;/strong&gt;emplate &lt;strong&gt;M&lt;/strong&gt;eta &lt;strong&gt;P&lt;/strong&gt;rogramming side-effects), but it would be available in the first decade, hence its code-name &lt;strong&gt;C++0x&lt;/strong&gt;. Well, the standard sadly came the next decade (2011 ==&amp;gt; &lt;strong&gt;C++11&lt;/strong&gt;), but it brought a lot of features interesting for the purpose of this article. Let's review them!&lt;/p&gt;
&lt;h4&gt;decltype, declval, auto &amp;amp; co:&lt;/h4&gt;
&lt;p&gt;Do you remember that the &lt;strong&gt;sizeof operator&lt;/strong&gt; does a "fake evaluation" of the expression that you pass to it, and return gives you the size of the type of the expression? Well &lt;strong&gt;C++11&lt;/strong&gt; adds a new operator called &lt;strong&gt;decltype&lt;/strong&gt;. &lt;a href="http://en.cppreference.com/w/cpp/language/decltype"&gt;decltype&lt;/a&gt; gives you the type of the of the expression it will evaluate. As I am kind, I won't let you google an example and give it to you directly:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;decltype&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;test&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Evaluate b.serialize(), which is typed as std::string.&lt;/span&gt;
&lt;span class="c1"&gt;// Equivalent to std::string test = &amp;quot;test&amp;quot;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="http://en.cppreference.com/w/cpp/utility/declval"&gt;declval&lt;/a&gt; is an utility that gives you a "fake reference" to an object of a type that couldn't be easily construct. &lt;strong&gt;declval&lt;/strong&gt; is really handy for our &lt;strong&gt;SFINAE&lt;/strong&gt; constructions. &lt;strong&gt;cppreference&lt;/strong&gt; example is really straightforward, so here is a copy:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Default&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;NonDefault&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;NonDefault&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;NonDefault&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;decltype&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Default&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="n"&gt;n1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// int n1&lt;/span&gt;
&lt;span class="c1"&gt;//  decltype(NonDefault().foo()) n2 = n1; // error: no default constructor&lt;/span&gt;
    &lt;span class="k"&gt;decltype&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;declval&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;NonDefault&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="n"&gt;n2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;n1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// int n2&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;n2 = &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n2&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The &lt;strong&gt;auto specifier&lt;/strong&gt; &lt;em&gt;specifies that the type of the variable that is being declared will be automatically deduced&lt;/em&gt;. &lt;a href="http://en.cppreference.com/w/cpp/language/auto"&gt;auto&lt;/a&gt; is equivalent of &lt;strong&gt;var&lt;/strong&gt; in C#. &lt;strong&gt;auto&lt;/strong&gt; in &lt;strong&gt;C++11&lt;/strong&gt; has also a less famous but nonetheless usage for function declaration. Here is a good example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// Famous usage, auto deduced that test is a boolean, hurray!&lt;/span&gt;



&lt;span class="c1"&gt;//                             vvv t wasn&amp;#39;t declare at that point, it will be after as a parameter!&lt;/span&gt;
&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;decltype&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;   &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// Compilation error&lt;/span&gt;

&lt;span class="c1"&gt;// Less famous usage:&lt;/span&gt;
&lt;span class="c1"&gt;//                    vvv auto delayed the return type specification!&lt;/span&gt;
&lt;span class="c1"&gt;//                    vvv                vvv the return type is specified here and use t!&lt;/span&gt;
&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;decltype&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;   &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// No compilation error.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As you can see, &lt;strong&gt;auto&lt;/strong&gt; permits to use the trailing return type syntax and use &lt;strong&gt;decltype&lt;/strong&gt; coupled with an expression involving one of the function argument. Does it means that we can use it to test the existence of &lt;strong&gt;serialize&lt;/strong&gt; with a SFINAE? Yes Dr. Watson! &lt;strong&gt;decltype&lt;/strong&gt; will shine really soon, you will have to wait for the &lt;strong&gt;C++14&lt;/strong&gt; for this tricky &lt;strong&gt;auto&lt;/strong&gt; usage (but since it's a C++11 feature, it ends up here).&lt;/p&gt;
&lt;h4&gt;constexpr:&lt;/h4&gt;
&lt;p&gt;C++11 also came with a new way to do compile-time computations! The new keyword &lt;strong&gt;constexpr&lt;/strong&gt; is a hint for your compiler, meaning that this expression is constant and could be evaluate directly at compile time. In C++11, &lt;a href="http://en.cppreference.com/w/cpp/language/constexpr"&gt;constexpr&lt;/a&gt; has a lot of rules and only a small subset of VIEs (Very Important Expression) expressions can be used (no loops...)! We still have enough for creating a compile-time factorial function:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;factorial&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;factorial&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;factorial&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Call to a constexpr function.&lt;/span&gt;
&lt;span class="c1"&gt;// Will be replace by a good compiler by:&lt;/span&gt;
&lt;span class="c1"&gt;// int i = 120;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;constexpr&lt;/strong&gt; increased the usage of &lt;strong&gt;std::true_type&lt;/strong&gt; &amp;amp; &lt;strong&gt;std::false_type&lt;/strong&gt; from the STL. As their name suggest, these types encapsulate a constexpr boolean "true" and a constrexpr boolean "false". Their most important property is that a class or a struct can inherit from them. For instance:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nl"&gt;testStruct&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;true_type&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;// Inherit from the true type.&lt;/span&gt;

&lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;testVar&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;testStruct&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// Generate a compile-time testStruct.&lt;/span&gt;
&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;testStruct&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Equivalent to: test = true;&lt;/span&gt;
&lt;span class="n"&gt;test&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;testVar&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// true_type has a constexpr converter operator, equivalent to: test = true;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;Blending time:&lt;/h4&gt;
&lt;h5&gt;First solution:&lt;/h5&gt;
&lt;p&gt;In cooking, a good recipe requires to mix all the best ingredients in the right proportions. If you don't want to have a spaghetti code dating from 1998 for dinner, let's revisit our C++98 &lt;strong&gt;hasSerialize&lt;/strong&gt; and &lt;strong&gt;serialize&lt;/strong&gt; functions with "fresh" ingredients from 2011. Let's start by removing the rotting &lt;strong&gt;reallyHas&lt;/strong&gt; trick with a tasty &lt;strong&gt;decltype&lt;/strong&gt; and bake a bit of &lt;strong&gt;constexpr&lt;/strong&gt; instead of &lt;strong&gt;sizeof&lt;/strong&gt;. After 15min in the oven (or fighting with a new headache), you will obtain:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;hasSerialize&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// We test if the type has serialize using decltype and declval.&lt;/span&gt;
    &lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;decltype&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;declval&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="cm"&gt;/* unused */&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// We can return values, thanks to constexpr instead of playing with sizeof.&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;(...)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;// int is used to give the precedence!&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You might be a bit puzzled by my usage of &lt;strong&gt;decltype&lt;/strong&gt;. The C++ comma operator "&lt;strong&gt;,&lt;/strong&gt;" can create a chain of multiple expressions. In &lt;strong&gt;decltype&lt;/strong&gt;, all the expressions will be evaluated, but only the last expression will be considered for the type. The &lt;strong&gt;serialize&lt;/strong&gt; doesn't need any changes, minus the fact that the &lt;strong&gt;enable_if&lt;/strong&gt; function is now provided in the &lt;strong&gt;STL&lt;/strong&gt;. For your tests, here is a &lt;a href="https://gist.github.com/Jiwan/21f65ddbd91e7ce93384"&gt;gist&lt;/a&gt;.&lt;/p&gt;
&lt;h5&gt;Second solution:&lt;/h5&gt;
&lt;p&gt;Another C++11 solution described in &lt;strong&gt;Boost.Hanna&lt;/strong&gt; documentation and using &lt;strong&gt;std::true_type&lt;/strong&gt; and &lt;strong&gt;std::false_type&lt;/strong&gt;, would be this one:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// Primary template, inherit from std::false_type.&lt;/span&gt;
&lt;span class="c1"&gt;// ::value will return false. &lt;/span&gt;
&lt;span class="c1"&gt;// Note: the second unused template parameter is set to default as std::string!!!&lt;/span&gt;
&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nl"&gt;hasSerialize&lt;/span&gt;
        &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;false_type&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;

&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="c1"&gt;// Partial template specialisation, inherit from std::true_type.&lt;/span&gt;
&lt;span class="c1"&gt;// ::value will return true. &lt;/span&gt;
&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;hasSerialize&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;decltype&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;declval&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
        &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;true_type&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;

&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This solution is, in my own opinion, more sneaky! It relies on a not-so-famous-property of default template parameters. But if your soul is already (stack-)corrupted, you may be aware that the &lt;strong&gt;default parameters&lt;/strong&gt; are propagated in the &lt;strong&gt;specialisations&lt;/strong&gt;. So when we use &lt;strong&gt;hasSerialize&amp;lt;OurType&gt;::value&lt;/strong&gt;, the default parameter comes into play and we are actually looking for &lt;strong&gt;hasSerialize&amp;lt;OurType, std::string&gt;::value&lt;/strong&gt; both on the &lt;strong&gt;primary template&lt;/strong&gt; and the &lt;strong&gt;specialisation&lt;/strong&gt;. In the meantime, the &lt;strong&gt;substitution&lt;/strong&gt; and the evaluation of &lt;strong&gt;decltype&lt;/strong&gt; are processed and our &lt;strong&gt;specialisation&lt;/strong&gt; has the signature &lt;strong&gt;hasSerialize&amp;lt;OurType, std::string&gt;&lt;/strong&gt; if &lt;strong&gt;OurType&lt;/strong&gt; has a &lt;strong&gt;serialize&lt;/strong&gt; method that returns a &lt;strong&gt;std::string&lt;/strong&gt;, otherwise the substitution fails. The &lt;strong&gt;specialisation&lt;/strong&gt; has therefore the precedence in the good cases. One will be able to use the &lt;a href="http://en.cppreference.com/w/cpp/types/void_t"&gt;std::void_t&lt;/a&gt; C++17 helper in these cases. Anyway, here is a &lt;a href="https://gist.github.com/Jiwan/160a64a5d1d25e4bdf6b"&gt;gist&lt;/a&gt; you can play with!&lt;/p&gt;
&lt;p&gt;I told you that this second solution hides a lot of complexity, and we still have a lot of C++11 features unexploited like &lt;strong&gt;nullptr&lt;/strong&gt;, &lt;strong&gt;lambda&lt;/strong&gt;, &lt;strong&gt;r-values&lt;/strong&gt;. No worries, we are going to use some of them in &lt;strong&gt;C++14&lt;/strong&gt;!&lt;/p&gt;
&lt;h3&gt;The supremacy of C++14:&lt;/h3&gt;
&lt;p&gt;According to the Gregorian calendar in the upper-right corner of my XFCE environment, we are in 2015! I can turn on the &lt;strong&gt;C++14&lt;/strong&gt; compilation flag on my favorite compiler safely, isn't it? Well, I can with &lt;strong&gt;clang&lt;/strong&gt; (is &lt;strong&gt;MSVC&lt;/strong&gt; using a maya calendar?).
Once again, let's explore the new features, and use them to build something wonderful! We will even recreate an &lt;strong&gt;is_valid&lt;/strong&gt;, like I promised at the beggining of this article.&lt;/p&gt;
&lt;h4&gt;auto &amp;amp; lambdas:&lt;/h4&gt;
&lt;h6&gt;Return type inference:&lt;/h6&gt;
&lt;p&gt;Some cool features in &lt;strong&gt;C++14&lt;/strong&gt; come from the relaxed usage of the &lt;strong&gt;auto&lt;/strong&gt; keyword (the one used for type inference).&lt;/p&gt;
&lt;p&gt;Now, &lt;strong&gt;auto&lt;/strong&gt; can be used on the return type of a function or a method. For instance:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="nf"&gt;myFunction&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;// Automagically figures out that myFunction returns ints.&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;It works as long as the type is easily "guessable" by the compiler. We are coding in C++ after all, not OCaml! &lt;/p&gt;
&lt;h6&gt;A feature for functional lovers:&lt;/h6&gt;
&lt;p&gt;&lt;strong&gt;C++11&lt;/strong&gt; introduced &lt;a href="http://en.cppreference.com/w/cpp/language/lambda"&gt;lambdas&lt;/a&gt;. A lambda has the following syntax: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;[capture-list](params) -&amp;gt; non-mandatory-return-type { ...body... }&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;A useful example in our case would be:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;l1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;// Return type figured-out by the return statement.&lt;/span&gt;
&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;l3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;// Fixed return type.&lt;/span&gt;
&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;l2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;decltype&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;// Return type dependant to the B type.&lt;/span&gt;

&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;l1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Output: I am a B!&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;l2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Output: I am a B!&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;l3&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Output: I am a B!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;C++14&lt;/strong&gt; brings a small change to the &lt;strong&gt;lambdas&lt;/strong&gt; but with a big impact! &lt;strong&gt;Lambdas&lt;/strong&gt; accept &lt;strong&gt;auto parameters&lt;/strong&gt;: the parameter type is deduced according the argument. &lt;strong&gt;Lambdas&lt;/strong&gt; are implemented as an object having an newly created &lt;strong&gt;unnamed type&lt;/strong&gt;, also called &lt;strong&gt;closure type&lt;/strong&gt;. If a &lt;strong&gt;lambda&lt;/strong&gt; has some &lt;strong&gt;auto parameters&lt;/strong&gt;, its "Functor operator" &lt;strong&gt;operator()&lt;/strong&gt; will be simply templated. Let's take a look:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// ***** Simple lambda unamed type *****&lt;/span&gt;
&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;l4&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;l4&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Output 9.&lt;/span&gt;

&lt;span class="c1"&gt;// Equivalent to:&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;l4UnamedType&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="p"&gt;()(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="n"&gt;l4UnamedType&lt;/span&gt; &lt;span class="n"&gt;l4Equivalent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;l4UnamedType&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;l4Equivalent&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Output 9 too.&lt;/span&gt;



&lt;span class="c1"&gt;// ***** auto parameters lambda unnamed type *****&lt;/span&gt;

&lt;span class="c1"&gt;// b&amp;#39;s type is automagically deduced!&lt;/span&gt;
&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;l5&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="k"&gt;auto&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;decltype&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;l5&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Output: I am a B!&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;l5&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Error: no member named &amp;#39;serialize&amp;#39; in &amp;#39;A&amp;#39;.&lt;/span&gt;

&lt;span class="c1"&gt;// Equivalent to:&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;l5UnamedType&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="p"&gt;()(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;decltype&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="c1"&gt;// /!\ This signature is nice for a SFINAE!&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="n"&gt;l5UnamedType&lt;/span&gt; &lt;span class="n"&gt;l5Equivalent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;l5UnamedType&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;l5Equivalent&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Output: I am a B!&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;l5Equivalent&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Error: no member named &amp;#39;serialize&amp;#39; in &amp;#39;A&amp;#39;.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;More than the &lt;strong&gt;lambda&lt;/strong&gt; itself, we are interested by the generated &lt;strong&gt;unnamed type&lt;/strong&gt;: its lambda &lt;strong&gt;operator()&lt;/strong&gt; can be used as a SFINAE! And as you can see, writing a &lt;strong&gt;lambda&lt;/strong&gt; is less cumbersome than writing the equivalent type. It should remind you the beggining of my initial solution:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// Check if a type has a serialize method.&lt;/span&gt;
&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;hasSerialize&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;hana&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;is_valid&lt;/span&gt;&lt;span class="p"&gt;([](&lt;/span&gt;&lt;span class="k"&gt;auto&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;decltype&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;And the good new is that we have everything to recreate &lt;strong&gt;is_valid&lt;/strong&gt;, right now!&lt;/p&gt;
&lt;h4&gt;The making-of a valid &lt;strong&gt;is_valid&lt;/strong&gt;:&lt;/h4&gt;
&lt;p&gt;Now that we have a really stylish manner to generate a &lt;strong&gt;unnamed types&lt;/strong&gt; with potential &lt;strong&gt;SFINAE&lt;/strong&gt; properties using &lt;strong&gt;lambdas&lt;/strong&gt;, we need to figure out how to use them! As you can see, &lt;strong&gt;hana::is_valid&lt;/strong&gt; is a function that takes our lambda as a parameter and return a type. We will call the type returned by &lt;strong&gt;is_valid&lt;/strong&gt; the &lt;strong&gt;container&lt;/strong&gt;. The &lt;strong&gt;container&lt;/strong&gt; will be in charge to keep the lambda's &lt;strong&gt;unnamed type&lt;/strong&gt; for a later usage. Let's start by writing the &lt;strong&gt;is_valid&lt;/strong&gt; function and its the &lt;strong&gt;containter&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;UnnamedType&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;container&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Remembers UnnamedType.&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;UnnamedType&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;is_valid&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;UnnamedType&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// We used auto for the return type: it will be deduced here.&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;container&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;UnnamedType&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;is_valid&lt;/span&gt;&lt;span class="p"&gt;([](&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="k"&gt;auto&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;decltype&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{})&lt;/span&gt;
&lt;span class="c1"&gt;// Now &amp;#39;test&amp;#39; remembers the type of the lambda and the signature of its operator()!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The next step consists at extending &lt;strong&gt;container&lt;/strong&gt; with the operator &lt;strong&gt;operator()&lt;/strong&gt; such as we can call it with an argument. This argument type will be tested against the &lt;strong&gt;UnnamedType&lt;/strong&gt;! In order to do a test on the argument type, we can use once again a SFINAE on a reacreated 'UnnamedType' object! It gives us this solution:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;UnnamedType&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;container&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="c1"&gt;// Let&amp;#39;s put the test in private.&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;// We use std::declval to &amp;#39;recreate&amp;#39; an object of &amp;#39;UnnamedType&amp;#39;.&lt;/span&gt;
    &lt;span class="c1"&gt;// We use std::declval to also &amp;#39;recreate&amp;#39; an object of type &amp;#39;Param&amp;#39;.&lt;/span&gt;
    &lt;span class="c1"&gt;// We can use both of these recreated objects to test the validity!&lt;/span&gt;
    &lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;Param&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;testValidity&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="cm"&gt;/* unused */&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;decltype&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;declval&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;UnnamedType&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;()(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;declval&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Param&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;()),&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;true_type&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// If substitution didn&amp;#39;t fail, we can return a true_type.&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;true_type&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;Param&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;false_type&lt;/span&gt; &lt;span class="n"&gt;testValidity&lt;/span&gt;&lt;span class="p"&gt;(...)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// Our sink-hole returns a false_type.&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;false_type&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;// A public operator() that accept the argument we wish to test onto the UnnamedType.&lt;/span&gt;
    &lt;span class="c1"&gt;// Notice that the return type is automatic!&lt;/span&gt;
    &lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;Param&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="p"&gt;()(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Param&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// The argument is forwarded to one of the two overloads.&lt;/span&gt;
        &lt;span class="c1"&gt;// The SFINAE on the &amp;#39;true_type&amp;#39; will come into play to dispatch.&lt;/span&gt;
        &lt;span class="c1"&gt;// Once again, we use the int for the precedence.&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;testValidity&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Param&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;UnnamedType&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;is_valid&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;UnnamedType&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// We used auto for the return type: it will be deduced here.&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;container&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;UnnamedType&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// Check if a type has a serialize method.&lt;/span&gt;
&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;hasSerialize&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;is_valid&lt;/span&gt;&lt;span class="p"&gt;([](&lt;/span&gt;&lt;span class="k"&gt;auto&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;decltype&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If you are a bit lost at that point, I suggest you take your time and re-read all the previous example. You have all the weapons you need, now fight &lt;strong&gt;C++&lt;/strong&gt;!&lt;/p&gt;
&lt;p&gt;Our &lt;strong&gt;hasSerialize&lt;/strong&gt; now takes an argument, we therefore need some changes for our serialize function. We can simply post-pone the return type using &lt;strong&gt;auto&lt;/strong&gt; and use the argument in a &lt;strong&gt;decltype&lt;/strong&gt; as we learn. Which gives us:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// Notice how I simply swapped the return type on the right?&lt;/span&gt;
&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;enable_if&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;decltype&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hasSerialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;enable_if&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;!&lt;/span&gt;&lt;span class="k"&gt;decltype&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hasSerialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;to_string&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;FINALLY!!!&lt;/strong&gt; We do have a working &lt;strong&gt;is_valid&lt;/strong&gt; and we could use it for serialization! If I were as vicious as my SFINAE tricks, I would let you copy each code pieces to recreate a fully working solution. But today, Halloween's spirit is with me and here is &lt;a href="https://gist.github.com/Jiwan/7a586c739a30dd90d259"&gt;gist&lt;/a&gt;. Hey, hey! Don't close this article so fast! If you are true a warrior, you can read the last part!&lt;/p&gt;
&lt;h4&gt;For the fun:&lt;/h4&gt;
&lt;p&gt;There are few things I didn't tell you, on purpose. This article would otherwise be twice longer, I fear. I highly suggest you to google a bit more about what I am going to speak about.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Firstly, if you wish to have a solution that works with the &lt;strong&gt;Boost.Hana&lt;/strong&gt; static &lt;strong&gt;if_&lt;/strong&gt;, you need to change the return type of our &lt;strong&gt;testValidity&lt;/strong&gt; methods by Hana's equivalents, like the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;Param&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;test_validity&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="cm"&gt;/* unused */&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;decltype&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;declval&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;UnnamedType&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;()(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;declval&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Param&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;()),&lt;/span&gt; &lt;span class="n"&gt;boost&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;hana&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;true_c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// If substitution didn&amp;#39;t fail, we can return a true_type.&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;boost&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;hana&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;true_c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;Param&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;decltype&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;boost&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;hana&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;false_c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;test_validity&lt;/span&gt;&lt;span class="p"&gt;(...)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Our sink-hole returns a false_type.&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;boost&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;hana&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;false_c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The static &lt;strong&gt;if_&lt;/strong&gt; implementation is really interesting, but at least as hard as our &lt;strong&gt;is_valid&lt;/strong&gt; problem solved in this article. I might dedicate another article about it, one day!&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Did you noticed that we only check one argument at a time? Couldn't we do something like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;is_valid&lt;/span&gt;&lt;span class="p"&gt;([](&lt;/span&gt;&lt;span class="k"&gt;auto&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;auto&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;decltype&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;serialize&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;});&lt;/span&gt;
&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Actually we can, using some &lt;a href="http://en.cppreference.com/w/cpp/language/parameter_pack"&gt;parameter packs&lt;/a&gt;. Here is the solution:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;UnnamedType&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;container&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="c1"&gt;// Let&amp;#39;s put the test in private.&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;// We use std::declval to &amp;#39;recreate&amp;#39; an object of &amp;#39;UnnamedType&amp;#39;.&lt;/span&gt;
    &lt;span class="c1"&gt;// We use std::declval to also &amp;#39;recreate&amp;#39; an object of type &amp;#39;Param&amp;#39;.&lt;/span&gt;
    &lt;span class="c1"&gt;// We can use both of these recreated objects to test the validity!&lt;/span&gt;
    &lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;Params&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;test_validity&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="cm"&gt;/* unused */&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;decltype&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;declval&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;UnnamedType&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;()(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;declval&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Params&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;()...),&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;true_type&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// If substitution didn&amp;#39;t fail, we can return a true_type.&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;true_type&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;Params&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;false_type&lt;/span&gt; &lt;span class="n"&gt;test_validity&lt;/span&gt;&lt;span class="p"&gt;(...)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// Our sink-hole returns a false_type.&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;false_type&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;// A public operator() that accept the argument we wish to test onto the UnnamedType.&lt;/span&gt;
    &lt;span class="c1"&gt;// Notice that the return type is automatic!&lt;/span&gt;
    &lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;Params&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="p"&gt;()(&lt;/span&gt;&lt;span class="n"&gt;Params&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;...)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// The argument is forwarded to one of the two overloads.&lt;/span&gt;
        &lt;span class="c1"&gt;// The SFINAE on the &amp;#39;true_type&amp;#39; will come into play to dispatch.&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;test_validity&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Params&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;UnnamedType&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;is_valid&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;UnnamedType&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// We used auto for the return type: it will be deduced here.&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;container&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;UnnamedType&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;This code is working even if my types are incomplete, for instance a forward declaration, or a normal declaration but with a missing definition. What can I do? Well, you can insert a check on the size of your type either in the &lt;strong&gt;SFINAE&lt;/strong&gt; construction or before calling it: "&lt;strong&gt;static_assert( sizeof( T ), "type is incomplete." );&lt;/strong&gt;".&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Finally, why are using the notation "&lt;strong&gt;&amp;amp;&amp;amp;&lt;/strong&gt;" for the &lt;strong&gt;lambdas&lt;/strong&gt; parameters? Well, these are called &lt;strong&gt;forwarding references&lt;/strong&gt;. It's a really complex topic, and if you are interested, here is good &lt;a href="http://thbecker.net/articles/rvalue_references/section_01.html"&gt;article&lt;/a&gt; about it. You need to use "&lt;strong&gt;auto&amp;amp;&amp;amp;&lt;/strong&gt;" due to the way &lt;strong&gt;declval&lt;/strong&gt; is working in our &lt;strong&gt;is_valid&lt;/strong&gt; implementation!&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Notes:&lt;/h4&gt;
&lt;p&gt;This is my first serious article about &lt;strong&gt;C++&lt;/strong&gt; on the web and I hope you enjoyed it! I would be glad if you have any suggestions or questions and that you wish to share with me in the commentaries.&lt;/p&gt;
&lt;p&gt;Anyway, thanks to &lt;a href="https://github.com/Naav"&gt;Naav&lt;/a&gt; and &lt;a href="https://github.com/superboum"&gt;Superboum&lt;/a&gt; for rereading this article and theirs suggestions. Few suggestions were also provided by the reddit community or in the commentaries of this post, thanks a lot guys!&lt;/p&gt;</content><category term="C++"></category><category term="C++11"></category><category term="C++14"></category><category term="TMP"></category><category term="meta programming"></category></entry></feed>
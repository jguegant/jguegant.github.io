
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="robots" content="index, follow" />

  <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,400;0,700;1,400&family=Source+Sans+Pro:ital,wght@0,300;0,400;0,700;1,400&display=swap" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="https://jguegant.github.io/blogs/tech/theme/stylesheet/style.min.css">


    <link id="pygments-light-theme" rel="stylesheet" type="text/css"
          href="https://jguegant.github.io/blogs/tech/theme/pygments/monokai.min.css">


  <link rel="stylesheet" type="text/css" href="https://jguegant.github.io/blogs/tech/theme/font-awesome/css/fontawesome.css">
  <link rel="stylesheet" type="text/css" href="https://jguegant.github.io/blogs/tech/theme/font-awesome/css/brands.css">
  <link rel="stylesheet" type="text/css" href="https://jguegant.github.io/blogs/tech/theme/font-awesome/css/solid.css">


    <link href="https://jguegant.github.io/blogs/tech/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Jean Guegant's Blog Atom">



<!-- Google Analytics -->
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-68827527-1', 'auto');
  ga('send', 'pageview');
</script>
<!-- End Google Analytics -->  


<meta name="author" content="Jean Guegant" />
<meta name="description" content="Time to go back to the roots! Me and a few colleagues have been travelling across the old continent to attend the renowned Meeting C++ conference in Berlin. Fully backed by our employer, King, we were able to enjoy a yearly dose of C++ talks at an excellent venue. I …" />
<meta name="keywords" content="C++, event, meetingcpp">


<meta property="og:site_name" content="Jean Guegant's Blog"/>
<meta property="og:title" content="Trip report - Meeting C++ 2019"/>
<meta property="og:description" content="Time to go back to the roots! Me and a few colleagues have been travelling across the old continent to attend the renowned Meeting C++ conference in Berlin. Fully backed by our employer, King, we were able to enjoy a yearly dose of C++ talks at an excellent venue. I …"/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="https://jguegant.github.io/blogs/tech/trip-report-meetingcpp-2019.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2019-11-29 22:30:00+01:00"/>
<meta property="article:modified_time" content="2019-11-29 22:30:00+01:00"/>
<meta property="article:author" content="https://jguegant.github.io/blogs/tech/author/jean-guegant.html">
<meta property="article:section" content="C++"/>
<meta property="article:tag" content="C++"/>
<meta property="article:tag" content="event"/>
<meta property="article:tag" content="meetingcpp"/>
<meta property="og:image" content="https://jguegant.github.io/blogs/tech/images/myself.png">

  <title>Jean Guegant's Blog &ndash; Trip report - Meeting C++ 2019</title>

</head>
<body class="light-theme">
  <aside>
    <div>
      <a href="https://jguegant.github.io/blogs/tech">
        <img src="https://jguegant.github.io/blogs/tech/images/myself.png" alt="Jean Guegant" title="Jean Guegant">
      </a>

      <h1>
        <a href="https://jguegant.github.io/blogs/tech">Jean Guegant</a>
      </h1>

<p>Software Engineer - C++, security, game development and random thoughts.</p>

      <nav>
        <ul class="list">


              <li>
                <a target="_self"
                   href="https://jguegant.github.io/blogs/tech/pages/about.html#about">
                  About
                </a>
              </li>
              <li>
                <a target="_self"
                   href="https://jguegant.github.io/blogs/tech/pages/contact.html#contact">
                  Contact
                </a>
              </li>

        </ul>
      </nav>

      <ul class="social">
          <li>
            <a  class="sc-linkedin" href="https://se.linkedin.com/in/jguegant" target="_blank">
              <i class="fab fa-linkedin"></i>
            </a>
          </li>
          <li>
            <a  class="sc-github" href="https://github.com/Jiwan" target="_blank">
              <i class="fab fa-github"></i>
            </a>
          </li>
      </ul>
    </div>

  </aside>
  <main>

    <nav>
      <a href="https://jguegant.github.io/blogs/tech">Home</a>

      <a href="https://jguegant.github.io/blogs/tech/archives.html">Archives</a>
      <a href="https://jguegant.github.io/blogs/tech/categories.html">Categories</a>
      <a href="https://jguegant.github.io/blogs/tech/tags.html">Tags</a>

      <a href="https://jguegant.github.io/blogs/tech/feeds/all.atom.xml">Atom</a>

    </nav>

<article class="single">
  <header>
      
    <h1 id="trip-report-meetingcpp-2019">Trip report - Meeting C++ 2019</h1>
    <p>
      Posted on Fri 29 November 2019 in <a href="https://jguegant.github.io/blogs/tech/category/c.html">C++</a>

    </p>
  </header>


  <div>
    <p>Time to go back to the roots!
Me and a few colleagues have been travelling across the old continent to attend the renowned <a href="https://meetingcpp.com/">Meeting C++</a> conference in Berlin.<br>
Fully backed by our employer, <a href="https://discover.king.com/about/">King</a>, we were able to enjoy a yearly dose of C++ talks at an excellent venue.
I was thrilled at the idea of retrying the "German C++ experience" and my expectation were once again met! 
<strong>C++20</strong> being right at the corner, I also had in mind to prioritise talks on this topic as much as possible.</p>
<p>As the tradition goes, I will relate a bit my experience of the event and dress-up a list of the talks I would highly suggest to search for! </p>
<p><center><img width=50% height=50% src="https://jguegant.github.io/blogs/tech/images/berlin-night.jpg"/></center></p>
<h1>A tour of Meeting (2019):</h1>
<p>I did a decent <a href="https://jguegant.github.io/blogs/tech/trip-report-meetingcpp-2017.html">introduction of the event two years ago</a> and most of it stand true.
Rather than doing another summary, I will compare and contrast my experience at <strong>Meeting C++</strong> with the one I had last year at <strong>Cppcon</strong>. </p>
<h2>The venue:</h2>
<p>When it comes to the facilities of the venue, I found the rooms in the Andels Hotel to have unequal quality.
While the two big rooms on the lower floors are excellent, the upper floor ones are really long and narrow. 
If the nature made you of a short stature or you don't have the best eyesight (or both like me), you will have a hard time following some of the slides.
I cannot remember having any issue with that at <strong>CppCon</strong>. Having rooms with inclined rows helps a lot!</p>
<p>Note: apparently, the organisers are well-aware of this issue and may come up with a nice solution for the next round of Meeting C++! </p>
<p>Probably to avoid having crammed rooms and irritating noises, <strong>Meeting C++</strong> also has this concept of closing doors of the tracks as soon as the talk starts and not letting annoying enter. I am not quite convinced by this idea, it extremely frustrating to not be able to move to another talk if the current one is not to your taste. </p>
<h2>The German cuisine:</h2>
<p>Being French, a detail often comes to my mind... the food provided during the event!
Unlike <strong>CppCon</strong>, this event offers catering all day long, and tasty one mind you. 
Obviously you cannot expect conference meals to deserve a <a href="https://en.wikipedia.org/wiki/Michelin">Michelin stars's</a>, but there was plenty and with a lot of variety. Is that a must-do for a conference? Probably not, but it is both really convenient and it also brings a LOT of interactions between members of the community. People will tend to have more casual conversations if they are dinning in the same place rather than going out. From what I can recall, <strong>CppCon</strong> provided snacks here and there, but nothing worth remembering.</p>
<h2>The talks:</h2>
<p>Last but not least, the speakers! On one hand, <strong>Meeting C++</strong> has more diversity: the speakers are coming from all around Europe and you may discover a lot of new names and some hidden gems that didn't/wouldn't make it to <strong>CppCon</strong> - not everyone is willing or can afford to travel to the USA. On the other hand, the amount of C++ committee members and famous speakers per square kilometre felt higher at <strong>CppCon</strong> which probably made the talks of a slightly better quality overall.</p>
<p><strong>Meeting C++</strong> offers you the possibility to go to four different tracks for a given time slot.
It is enough choices that you will always find a talk to your liking.
The talks are also explicitly tagged with a level of experience required to enjoy them: beginner to advanced.
Once again, going only to talks with topics that you like is often not the best strategy to fully enjoy this conference.
It can be very rewarding to go out of your comfort zone and try a talk not a single word on its title make sense to you. 
Likewise, do not underestimate the quality of beginner talks. You may learn more than you would expect!</p>
<p>I have had a first hand, albeit short, experience on what it takes to be a speaker at such an event.
I gave a lightning talk highly inspired on the <a href="https://jguegant.github.io/blogs/tech/trip-report-meetingcpp-2017.html">performing try emplace post</a> I did at the beginning of this year.
While it went rather smoothly (if not for a small technical issue with my slides), I felt intimidated when I went on stage in front of maybe 300 people (best-guess estimation). </p>
<p><center><img width=50% height=50% src="https://jguegant.github.io/blogs/tech/images/my-lightning-talk-meeting-cpp-2019.jpg"/></center></p>
<p>You can find a pdf version of the slides right <a href="https://jguegant.github.io/blogs/tech/images/associative-containers-the-art-of-inserting-gracefully.pdf">here</a> and maybe a YouTube record of that talk will pop at one point on the <a href="https://www.youtube.com/user/MeetingCPP">Meeting C++ channel</a>.
It was interesting to see that the <strong>lightning talks</strong> were a lot more formal than at <strong>CppCon</strong> where jokes and bad-puns are a constant.
I believe that the lightning talks format was changed recently at <strong>Meeting C++</strong>: it used to be its own dedicated track on a full afternoon, and it became a more casual evening event. We, the lightning speakers, were also informed a bit late on where, when and how should the talks happen.</p>
<p>Doing a presentation on an innovative topic, interesting and understandable by all requires a lot of upfront work.
Having to do it in a foreign language, for one hour, in front of a rather massive crowd is even more demanding.
I am still amazed by what all these speakers gave us during these three days! </p>
<h1>The chief's suggestions of the year:</h1>
<p>Here comes again the menu of the talks I particularly enjoyed. The legend follow the usual rules:</p>
<ul>
<li>💀 : The difficulty of the talk (💀: Beginner friendly, 💀💀: Intermediate, 💀💀💀: High exposure to C++'s dark corners)</li>
<li>★ : My interest for the talk (★: Good talk, ★★: Tasty talk, ★★★: Legendary talk)</li>
</ul>
<p>No need to say that I will not spoil everything in the talks, but I will simply try to give an idea of what the talk was about. If the talk seems to be of your taste, I highly encourage you to watch the video record of it or the slides. 
 If your talk or a talk that you liked very much is not part of this menu, do not feel too disenchanted about it.
 I had to curate this list to a few talks or I would have to write an entire novel.
 Feel free to post your opinion about the talks in the comment section.</p>
<h3>[Keynote] Design Rationale for <chrono> - Howard Hinnant - 💀💀★★:</h3>
<ul>
<li>Slides: <a href="https://meetingcpp.com/mcpp/slides/2019/Hinnant.pdf">link</a></li>
<li>Video: <a href="">coming soon</a></li>
</ul>
<p>The <strong>Howard Hinnant</strong>, himself, came to present his new-born baby: the support of dates, calendars and time-zones in the <a href="https://en.cppreference.com/w/cpp/chrono">chrono header</a>. 
For those out-of-the-loop, <a href="https://howardhinnant.github.io/HowardHinnant.html">Howard Hinnant</a> has been a massive contributor to what C++ is nowadays.
He is known for bringing <strong>move semantics</strong> to the language, introducing <code>std::unique_ptr</code>, being lead author of <strong>libc++</strong>... a myriad of things... and the notion of time in the standard through the header <code>&lt;chrono&gt;</code>. It should not come as surprise that Howard is also the man being the dates and calendars coming to the new C++ standard. </p>
<p>Howard's talk was very educating on this addition to <strong>C++20</strong>. Within two hours, I had a fairly good overview of what we will get and more importantly an answer to why <strong>chrono</strong> is so verbose.
Here is the gist of what we will have:</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/chrono/time_point">std::chrono::time_point</a> (already in C++11) get a specialized alias <code>sys_days</code> equal to <code>std::chrono::time_point&lt;std::chrono::system_clock, std::chrono::days&gt;</code>. In other word <code>sys_days</code> represent a time point using the system clock and expressed in days. This <code>sys_days</code> can be thought as an integer representing a value in days.</li>
<li>We can convert this <code>sys_days</code> time point into a <a href="https://en.cppreference.com/w/cpp/chrono/year_month_day">year_month_day</a> representation and vice-versa.
This is the same representation of that time point but in a much more human-friendly way: it uses the Gregorian calendar to express that point in time. 
A time point in the Gregorian calendar is made of three parts: a year, a month and a day of the month.
The new standard offers lots of arithmetic operators, conversion operators, helpers structs... to manipulate these parts easily.</li>
<li>A new type, with a self-explanatory name, <a href="https://en.cppreference.com/w/cpp/chrono/time_zone">std::chrono::time_zone</a> has been introduced.
If you combine a <code>sys_days</code> with a <code>time_zone</code>, you obtain a <code>zoned_time</code>. <code>zoned_time</code> handles conversion from one <code>time_zone</code> to another for you.
It is highly convenient! </li>
<li>Finally, almost all the types in the <code>&lt;chrono&gt;</code> header have conversion facilities to and from strings. It even works with the new <a href="https://en.cppreference.com/w/cpp/utility/format">std::format</a> library. </li>
</ul>
<p>Equipped with this extended <code>&lt;chrono&gt;</code> header, you can easily write such things:</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">d</span> <span class="o">=</span> <span class="n">January</span><span class="o">/</span><span class="mi">9</span><span class="o">/</span><span class="mi">2019</span><span class="p">;</span> <span class="n">d</span><span class="p">.</span><span class="n">year</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">2020</span><span class="n">y</span><span class="p">;</span> <span class="n">d</span> <span class="o">=</span> <span class="n">sys_days</span><span class="p">{</span><span class="n">d</span><span class="p">}</span> <span class="o">+</span> <span class="n">weeks</span><span class="p">{</span><span class="mi">2</span><span class="p">})</span> <span class="p">{</span>
    <span class="n">zoned_time</span> <span class="n">london</span><span class="p">{</span><span class="s">&quot;Europe/London&quot;</span><span class="p">,</span> <span class="n">local_days</span><span class="p">{</span><span class="n">d</span><span class="p">}</span> <span class="o">+</span> <span class="mi">18</span><span class="n">h</span><span class="p">};</span>    
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">london</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>    
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">zoned_time</span><span class="p">{</span><span class="s">&quot;America/New_York&quot;</span><span class="p">,</span> <span class="n">london</span><span class="p">}</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>In this example, we are displaying the time in "New York" every two weeks, starting from the 9th of January, for the year 2019, when it is 18.00 in "London".
As Howard pointed out, this is far from being trivial to do by hand: both the UK and USA have different daylight savings rules.</p>
<p>Some people may complain of the <strong>verbosity</strong>. Firstly, I find the code very readable even without prior knowledge of this new part of <code>&lt;chrono&gt;</code>
Second, <strong>safety</strong> was a key-point in Howard's design. At multiple time, he gave us example on how his design prevents wrongdoings at compile-time. 
For instance: what is a time difference? Can this be considered a date? Can <code>2 hours</code> be translated to a date in a calendar? Probably not! </p>
<p>I am quite eager to get this part of C++20! </p>
<h3>[Talk] 10 techniques to understand existing code - Jonathan Boccara - 💀★★★:</h3>
<ul>
<li>Slides: <a href="https://meetingcpp.com/mcpp/slides/2019/understand_code.pdf">link</a></li>
<li>Video: <a href="">coming soon</a></li>
</ul>
<p><strong>Jonathan Boccara</strong>, known for his awesome blog <a href="https://www.fluentcpp.com/">fluentcpp.com</a>, is always a safe bet when it comes to C++ talks.
You should not necessarily expect learning bleeding-edge techniques with Jonathan, but he is extremely talented at putting words on things!</p>
<p>This time, he was presenting us his favourite approaches to code you have never seen before. Especially, when it comes to intricate code-bases.
My favourite analogy was the <strong>stronghold</strong> one: start your exploration of the code from a place (a function, a routine...) that is crucial in the code-base and that you can easily understand. Like a <strong>fog of war</strong> in a video-game, the rest of the code is unknown to you at first. But slowly, you can explore the rest of the map/code-base by sending minions/yourself into the callers or the callees related to that function. One strategy to know where to "expand your territory for a maximum of profit" is by looking at <strong>call stacks</strong>: by jumping in the frames above the current function, this can give you an idea of what is the critical path of your program.</p>
<p>Here is an awesome representation, from Jonathan, of <strong>call stacks</strong> in a video-game universe:</p>
<p><center><img width=50% height=50% src="https://jguegant.github.io/blogs/tech/images/call-stack-fog-of-war.png"/></center></p>
<p>Not only this applies to decipher a code-base, but it is also a very efficient technique in <strong>reverse engineering</strong>.
When trying to reverse a native application, it is often quite rewarding to put a breakpoint on the system calls: these are your strongholds.
Without source-code, you have very little places where you know what the assembly you are reading does.
System calls are well documented and exposed, so it is naturally a good place to start.</p>
<p>I believe that I am already applying most of these techniques on a daily-basis.
But if I had to explain to a junior programmer what programming on a large code-base is all about, 
I would probably recommend that person to have a look at this talk.</p>
<h3>[Talk] Testing Legacy Code - Fuzzing for Better Input Data - Tina Ulbrich, Niel Waldren - 💀💀★★★:</h3>
<ul>
<li>Slides: <a href="https://meetingcpp.com/mcpp/slides/2019/Testing%20Legacy%20Code%20-%20Fuzzing%20for%20Better%20Input%20Data.pdf">link</a></li>
<li>Video: <a href="">coming soon</a></li>
</ul>
<p>During such conferences, you may end-up for various reasons (entering the wrong door, following someone, not getting on time to a room...) into a talk that you did not expect on your schedule. Sometimes, you may regret your unfortunate choice as much as <code>std::vector&lt;bool&gt;</code> being in the standard, but it can also turn out into your favour: you may discover one of the best presentation of that day. This is exactly what happened to me with the talk from <strong>Tina Ulbrich</strong> and <strong>Niel Waldren</strong> about <a href="https://en.wikipedia.org/wiki/Fuzzing">fuzzing</a> and unit-testing.</p>
<p>Usually, <strong>fuzzing</strong> consists in feeding an application or part of an application with pseudo-random data to explore as much code-path as possible.
The end-goal is to find code-paths that lead to crashes or bugs which can be exploit for malicious purposes.<br>
Once an exploit found, the fuzzer will often try to reduce the "buggy input" to a minimal set to clearly isolate the corner case.</p>
<p>I have heard about fuzzing for a while, but I never had the opportunity to use it myself.
This technique is really appealing if you are working in the security business or if your application is critical part of system.
If you are developing an application a bit less demanding on the stability, like video-games, fuzzing is not necessarily the number one priority.
<strong>Tina</strong> and <strong>Niel</strong> twisted the usage of fuzzing to find exploits to improve the test-coverage of their library.
They used <a href="https://llvm.org/docs/LibFuzzer.html">libFuzzer</a> which is, from what I understand, a LLVM library that combine <a href="https://clang.llvm.org/docs/SanitizerCoverage.html">LLVM's code coverage tool - SanitizerCoverage</a> with a fuzzer engine like <a href="http://lcamtuf.coredump.cx/afl/">AFL</a>.
<strong>libFuzzer</strong> will try to maximize the code-coverage with the minimum input data.
This is really appealing for all projects relying on unit-tests. </p>
<p><strong>Tina</strong> and <strong>Niel</strong> did a step by step explanation on how to use <strong>libFuzzer</strong> and what are its benefits:</p>
<ul>
<li>How to tweak the random data you receive to valid parameters.</li>
<li>How to reuse the best input data corpus to write new unit-tests for your application.</li>
<li>Why you can use this to detect very subtle changes in your API's behaviour. Changes that you would not necessarily catch with usual unit-tests.</li>
<li>A lot more...</li>
</ul>
<p>I will have a second watch of their talk as soon as their video is available on the conference's Youtube channel.
It was a very innovative topic to me!</p>
<h3>[Talk] Modules - The Beginner's Guide - Daniela Engert - 💀💀★★:</h3>
<ul>
<li>Slides: <a href="https://meetingcpp.com/mcpp/slides/2019/modules-the-beginners-guide-meetingcpp2019.pdf">link</a></li>
<li>Video: <a href="">coming soon</a></li>
</ul>
<p>Out of the three major language features coming to C++20 (concepts, coroutines and modules), I was the least familiar with <strong>modules</strong>.
The committee is often very active on the standard until the last months before the release of a version. 
While I had a rough idea of module were about in C++, I did not bother to learn about the syntax and the exact implementation.
You never know if the feature you read about in a white paper while look any different in the actual standard!
So, I was very grateful that <a href="https://github.com/DanielaE">Daniela Engert</a> came up with that talk right before 2020.
Being so close to the standard release, the module part was unlikely to change too much! </p>
<p>So what are modules in a few words?
Traditionally, a C++ code-base is separated into multiple <strong>compilation units</strong> which are in most case your <code>.cpp</code> files.
These compilation units are <strong>compiled</strong> separately and <strong>combined</strong> by the <strong>linker</strong>.
If you want to share functions or objects between two compilation units, you must have a <strong>common interface</strong> for them: one or more <strong>header files</strong> (.h/.hpp) that declare what is available.
The problem is that header files are:</p>
<p>1) Shared in a very primitive way. The <code>#include</code> directive is doing dumb copy-paste of the header content into your cpp file.
2) Often full of complicated content for the compiler and not just few declarations. In those, you can have macros, templates, inline functions, include of includes... </p>
<p>This results in your compiler doing a lot of unnecessary work parsing these headers for all the compilation units. 
Wouldn't it be better if compilation units themselves could expose directly what they provide instead of using these hackish headers?
This is exactly what modules try to solve!</p>
<p>So writing a very basic module becomes as simple as writing a <code>.cpp</code> file with few annotations to expose what we want:</p>
<div class="highlight"><pre><span></span><code><span class="k">export</span> <span class="k">module</span> <span class="n">my</span><span class="p">.</span><span class="k">module</span><span class="p">;</span> <span class="c1">// This is the name of our module</span>
<span class="k">export</span> <span class="kt">int</span> <span class="n">e</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span> <span class="c1">// Expose a variable.</span>

<span class="k">export</span> <span class="kt">int</span> <span class="nf">bar</span><span class="p">()</span> <span class="p">{</span> 
    <span class="k">return</span> <span class="n">foo</span><span class="p">(</span><span class="n">e</span><span class="p">);</span> <span class="c1">// Expose a function.</span>

<span class="p">}</span> 

<span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span> <span class="k">return</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// No export keyword == no exposition.</span>
</code></pre></div>

<p>When compiling this <code>.cpp</code> file, this will create two others files: an object file that contains binary code (OBJ) and a file for interfacing with that module called Binary Module Interface. Unlike a header file, the BMI file and its associated OBJ file can have a highly <strong>optimized representation</strong> of what is available in the module. </p>
<p>As a user of a module into another compilation unit, you will pass this BMI file as parameter to your compiler and write an import statement:</p>
<div class="highlight"><pre><span></span><code><span class="k">import</span> <span class="k">module</span> <span class="n">my</span><span class="p">.</span><span class="k">module</span><span class="p">;</span> <span class="c1">// Ask the compiler to use that module in here.</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">bar</span><span class="p">();</span> <span class="c1">// This is using bar from the other module.</span>
<span class="p">}</span>
</code></pre></div>

<p>And voilà! These are the new C++ module in all their glory.
Except that it gets quite a lot more complicated when you are mixing old header includes, namespaces, special support for standard headers...
<strong>Daniela</strong> was really good at explaining all these quirks that you may encounter in the rough transition that will happen from headers to modules.</p>
<p>As for performance, she observed an improvement from 1546 milliseconds to 62 milliseconds when using a library as a module on a huge-scale project at work. 
This gives a lot of hope on what modules will offer to us when available on all major compilers!</p>
<h3>[Talk] C++20 The small things - Timur Doumler - 💀★★:</h3>
<ul>
<li>Slides: <a href="https://meetingcpp.com/mcpp/slides/2019/talk.pdf">link</a></li>
<li>Video: <a href="https://www.youtube.com/watch?v=Xb6u8BrfHjw">cppcon link</a></li>
</ul>
<p>You probably have heard of the major features coming to C++20: concepts, coroutines and modules. And you would think that this is enough on your C++ plate for a few years.
Well, even without these three features, C++20 still has plenty to offer. This is what <a href="https://twitter.com/timur_audio">Timur Doumler</a> demonstrated to us for one hour!   </p>
<p>Amongst a plethora of small improvements, here are my favourite so far:</p>
<h4>Designated initialisers</h4>
<p>Let's imagine that you have a <code>struct</code> with quite a few members in it. Now let's pretend that we want to initialize this structure with a few variables using the <a href="https://en.cppreference.com/w/cpp/language/aggregate_initialization">aggregate initilization from C++11</a>.
What are the chances that you assign the correct members from the first try? </p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">my_struct</span> 
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">a2</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">b2</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">b3</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">c</span><span class="p">;</span>
    <span class="c1">// ...</span>
<span class="p">};</span>

<span class="n">my_struct</span> <span class="n">s</span><span class="p">{</span><span class="mi">42</span><span class="p">,</span> <span class="mi">43</span><span class="p">,</span> <span class="mi">1337</span><span class="p">,</span> <span class="mi">54</span><span class="p">,</span> <span class="cm">/*...*/</span><span class="p">};</span>
</code></pre></div>

<p>I tell you, the chances are low. You will have to double-check the <code>struct</code> definition more than once to order things accurately!
So what if you could specify which member you designate? This is where C++20 comes to save the day:</p>
<div class="highlight"><pre><span></span><code><span class="n">my_struct</span> <span class="n">s</span><span class="p">{.</span><span class="n">a1</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span> <span class="p">.</span><span class="n">b</span><span class="o">=</span><span class="mi">43</span><span class="p">,</span> <span class="p">.</span><span class="n">a2</span><span class="o">=</span><span class="mi">1337</span><span class="p">,</span> <span class="p">.</span><span class="n">b2</span><span class="o">=</span><span class="mi">54</span><span class="p">,</span> <span class="cm">/*...*/</span><span class="p">};</span>
</code></pre></div>

<p>I can hear YOU the C programmer, this has been in C99 for a while...
And you will also point with your smug face that you must respect the order (by appearance in the definition) of the members when using C++'s designated initializers unlike C.
It happens that C++ has much more complicated rules of evaluation than C. Allowing for random order of assignment could be troublesome.
What this is feature is about is 1) <strong>safety</strong> 2) a nice way to get <strong>auto-completion</strong> from your IDE on what member you need to fill in.</p>
<h4>Improved lambdas</h4>
<p>If you want to capture a <strong>parameter pack</strong> within a lambda before C++20, you will have to be <a href="https://stackoverflow.com/questions/47496358/c-lambdas-how-to-capture-variadic-parameter-pack-from-the-upper-scope">extremely creative</a>. This is even more frustrating that lambdas are great to combine with templates.
This very tedious task becomes trivial in C++20:</p>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">foo</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span> 
    <span class="k">return</span> <span class="p">[...</span><span class="n">args</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">args</span><span class="p">)]()</span> <span class="p">{</span> 
        <span class="c1">// Do whatever you want with args...</span>
    <span class="p">};</span> 
<span class="p">}</span>
</code></pre></div>

<p>std::mindblowing()! Sprinkling a bit of <code>...</code> where it should... works as expected!</p>
<p>Lambdas become, in C++20, allowed in a <strong>unevaluated contexts</strong>. What are unevaluated contexts? Whenever you have an expression within a <code>sizeof(...)</code> or <code>decltype</code>.
Is that something you would frequently do? Actually yes. Whenever you want a custom deleter for your <code>std::unique_ptr</code>:</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Before C++20:</span>
<span class="k">const</span> <span class="k">auto</span> <span class="n">custom_deleter</span> <span class="o">=</span> <span class="p">[](</span><span class="n">handle</span><span class="o">*</span> <span class="n">h</span><span class="p">){</span> <span class="cm">/* Do something with h. */</span> <span class="n">release</span><span class="p">(</span><span class="n">h</span><span class="p">);</span> <span class="p">};</span> 
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">handle</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="n">custom_deleter</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">;</span>

<span class="c1">// Becomes a one liner:</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">handle</span><span class="p">,</span> <span class="k">decltype</span><span class="p">([](</span><span class="n">handle</span><span class="o">*</span> <span class="n">h</span><span class="p">){</span> <span class="cm">/* Do something with h. */</span> <span class="n">release</span><span class="p">(</span><span class="n">h</span><span class="p">);</span> <span class="p">})</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">;</span>
</code></pre></div>

<p><strong>Timur</strong> came up with other examples like having a custom comparison template parameter for <code>std::set</code>.</p>
<h4>Extended Non-Type Template Parameter (NTTP)</h4>
<p>If you are a <strong>template meta-programming</strong> (TMP) enthusiast like me, this will be a game changer!
Right now, the standard only allow integer-like (integer, enumeration, pointers...) and types as template parameter. This is highly restrictive and frustrating at times.
When pushing template meta-programming to its limit, you will often want to manipulate strings. Right now you will need to decompose your string into <code>char</code> that you pass as template arguments.</p>
<p>For instance, these bits of code would never work in <strong>C++17</strong>:</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">vec2</span> 
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="n">vec2</span> <span class="n">V</span><span class="o">&gt;</span> <span class="c1">// error: vec2 - illegal type for non-type template parameter  </span>
<span class="k">struct</span> <span class="nc">my_struct</span> 
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">V</span><span class="p">.</span><span class="n">y</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">V</span><span class="p">.</span><span class="n">x</span><span class="o">&gt;</span> <span class="n">bla</span><span class="p">;</span>
<span class="p">};</span>


<span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">InitValue</span><span class="o">&gt;</span> <span class="c1">// error: std::string - illegal type for non-type template parameter  </span>
<span class="k">struct</span> <span class="nc">my_struct2</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="n">InitValue</span><span class="p">;</span>  
<span class="p">};</span>
</code></pre></div>

<p>Good news! These restrictions have been lifted as long as your <strong>non-type template parameter</strong>'s type (I know the usage of "type" twice here is confusing):</p>
<ul>
<li>1) Has a comparison operator available (<code>operator==</code>) at compile time: it is <strong>constexpr</strong>.
The goal is that the compiler should be able to check if two template instantiations are the same by checking if all template parameters are equal. </li>
<li>2) Can be constructed at compile-time: its construction can be done in a constexpr context.</li>
</ul>
<h3>[Talk] Compile Time Regular Expressions with Deterministic Finite Automaton - Hana Dusíková - 💀💀💀★:</h3>
<p>Speaking of template meta-programming, NTTP and strings, <a href="https://twitter.com/hankadusikova">Hana Dusíková</a> improved her <a href="https://github.com/hanickadot/compile-time-regular-expressions">compile-time regular expression</a> library. 
At last year's <strong>CppCon</strong>, Hana impressed the crowd with her library: it exploited template meta-programming in C++17 to its maximum to generate a regex parser at compile-time from a string literal. 
This makes her library ridiculously fast compared to <code>std::regex</code>, which works at runtime. Surprisingly, the library does not affect compilation at all. 
In fact, it improves a lot the compilation time compared to <code>std::regex</code>! Does this implies that there is such a thing as "Zero-cost Abstractions"? Maybe...</p>
<p>I have to admit that I was part of the people who missed the chance to see her talk live when I could have...
So this year, I took my revenge and went to her follow-up talk.
Using some of the C++20 template features, Hana succeeded to make a new regexp engine using a <a href="https://en.wikipedia.org/wiki/Deterministic_finite_automaton">Deterministic Finite Automaton</a>. Do not ask me to summarise properly what I have witnessed during this talk, it was... complicated!
But it is also fascinating, it combines a hefty does of meta-programming with language theory: that's a lot of mental stimulation.</p>
<p>If that sounds fun to you, I would probably suggest to watch her <a href="https://www.youtube.com/watch?v=QM3W36COnE4">initial talk</a> and come back to this one afterwards.</p>
<h3>[Other]:</h3>
<p>There are a lot of other talks that would be worth using your <strong>Google-Fu</strong> to find them:</p>
<ul>
<li>Using C++20's Three-way Comparison &lt;=&gt; - Jonathan Müller</li>
<li>Oh No! More Modern CMake - Deniz Bahadir</li>
<li>C++20 Coroutines - Milosz Warzecha  </li>
<li>And many more...</li>
</ul>
<p>You will surely find the <strong>lightning talks</strong> on the <a href="https://www.youtube.com/user/MeetingCPP/videos">Meeting C++'s Youtube Channel</a> at one point.
These short talks are like snack foods, they vary a lot in their content and quality and don't take long to process. </p>
<h1>Conclusion:</h1>
<p>This was another very fruitful event for the <strong>C++</strong> community. I am glad that our beloved C++ language receive so much attention by its users and the committee. 
It will be interesting to see how long it will take for the major compiler to be fully C++20 compliant: this <strong>release is massive</strong>!
I was slightly overwhelmed by the amount of new features.<br>
I am also wondering how much of the newly acquired C++20 knowledge will stay true once the standard is released.
I guess that I will have to check that by going to another C++ event next year ;) </p>
  </div>
  <div class="tag-cloud">
    <p>
      <a href="https://jguegant.github.io/blogs/tech/tag/c.html">C++</a>
      <a href="https://jguegant.github.io/blogs/tech/tag/event.html">event</a>
      <a href="https://jguegant.github.io/blogs/tech/tag/meetingcpp.html">meetingcpp</a>
    </p>
  </div>





<!-- Disqus -->
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'jeanguegantswebsite';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>
    Please enable JavaScript to view comments.
</noscript>
<!-- End Disqus -->
</article>

    <footer>
<p>
  &copy; 2015  - This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/deed.en_US" target="_blank">Creative Commons Attribution-ShareAlike</a>
</p>
<p>
Built with <a href="http://getpelican.com" target="_blank">Pelican</a> using <a href="http://bit.ly/flex-pelican" target="_blank">Flex</a> theme
</p><p>
  <a rel="license"
     href="http://creativecommons.org/licenses/by-sa/4.0/"
     target="_blank">
    <img alt="Creative Commons License"
         title="Creative Commons License"
         style="border-width:0"
           src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png"
         width="80"
         height="15"/>
  </a>
</p>    </footer>
  </main>




<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Jean Guegant's Blog ",
  "url" : "https://jguegant.github.io/blogs/tech",
  "image": "https://jguegant.github.io/blogs/tech/images/myself.png",
  "description": ""
}
</script>

</body>
</html>